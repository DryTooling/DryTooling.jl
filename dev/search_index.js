var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"D.¬†J.¬†Gunn. Transfer of heat or mass to particles in fixed and fluidised beds. International¬†Journal¬†of¬†Heat¬†and¬†Mass¬†Transfer 21, 467‚Äì476 (1978).\n\n\n\nH.¬†Kramers and P.¬†Croockewit. The passage of granular solids through inclined rotary kilns. Chemical¬†Engineering¬†Science 1, 259‚Äì265 (1952).\n\n\n\n","category":"page"},{"location":"DryToolingKinetics/#DryToolingKinetics","page":"Kinetics","title":"DryToolingKinetics","text":"","category":"section"},{"location":"DryToolingKinetics/","page":"Kinetics","title":"Kinetics","text":"CurrentModule = DryToolingKinetics\nDocTestSetup  = quote\n    using DryToolingKinetics\nend","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/#Parte-1-Primeiros-passos","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"","category":"section"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"Tradicionalmente, o primeiro contato com uma linguagem de programa√ß√£o se faz atrav√©s da implementa√ß√£o se seu programa Hello, World! que nada mas faz que imprimir esta senten√ßa em um terminal. Em Julia usamos a fun√ß√£o println() contendo o texto a ser apresentado entre aspas duplas (veremos mais sobre texto na pr√≥xima se√ß√£o) para implementar este programa, como se segue:","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"julia> println(\"Ol√°, Mundo!\")\nOl√°, Mundo!","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/#Tipos-b√°sicos","page":"Parte 1 - Primeiros passos","title":"Tipos b√°sicos","text":"","category":"section"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"O interesse principal de programa√ß√£o √© o fato de podermos atribuir valores √† nomes e em seguida realizar a manipula√ß√£o necess√°ria. Uma vez implementado o algoritmo, podemos simplesmente modificar os valores e reutiliz√°-lo.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"Esse processo chama-se atribui√ß√£o de vari√°veis e √© realizado utilizando o s√≠mbolo de igualdade = com o nome da vari√°vel √† esquerda e seu valor a direita.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"warning: Aten√ß√£o\nVeremos mais tarde que a compara√ß√£o de igualdade se faz com um duplo sinal == e que devemos tomar cuidado com isso quando estamos tendo um primeiro contato com programa√ß√£o. A igualdade simples = √©, na maioria das linguagens modernas, um s√≠mbolo de atribui√ß√£o de valor.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"Vamos criar uma vari√°vei favorite_number_1 e atribuir seu valor:","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"julia> favorite_number_1 = 13\n13","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"Agora poder√≠amos realizar opera√ß√µes com favorite_number_1. Faremos isso mais tarde com outras vari√°veis porque antes √© importante de introduzirmos o conceito de tipos. Toda vari√°vel √© de um dado tipo de dado, o que implica o tamanho (fixo ou vari√°vel) de sua representa√ß√£o na mem√≥ria do computador. Com a fun√ß√£o typeof() inspecionamos o tipo de uma vari√°vel.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"Vemos que o tipo de 13 ‚Äì um n√∫mero inteiro ‚Äì √© representado em Julia por Int64.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"julia> typeof(favorite_number_1)\nInt64","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"Existem diversos tipos num√©ricos suportados por Julia, mas aqui vamos ver somente os tipos b√°sicos utilizados mais comumente em computa√ß√£o num√©rica. Atribuindo um valor aproximado de œÄ a favorite_number_2 obtemos um objeto de tipo Float64, utilizado para representar n√∫meros reais em dupla precis√£o.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"note: Aritm√©tica de ponto flutuante de dupla precis√£o\nA maioria dos n√∫meros reais n√£o podem ser representados com precis√£o arbitr√°ria em um computador. Um n√∫mero real em dupla precis√£o √© representado com 64 bits na mem√≥ria. Representa√ß√µes de precis√£o arbitr√°ria s√£o hoje em dia dispon√≠veis mas tem um custo de opera√ß√£o proibitivo para a maioria das aplica√ß√µes. A matem√°tica necess√°ria para a compreens√£o da representa√ß√£o na mem√≥ria √© discutida no livro texto.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"julia> favorite_number_2 = 3.141592\n3.141592\n\njulia> typeof(favorite_number_2)\nFloat64","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"Uma particularidade de Julia dado o seu car√°ter cient√≠fico √© o suporte √† n√∫meros irracionais. Podemos assim representar œÄ de maneira otimizada como discutiremos num momento oportuno.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"tip: Caract√©res especiais\nJulia suporta progra√ß√£o usando quaisquer caract√©res UNICODE. Isso inclui letras gregas, subscritos, s√≠mbolos matem√°ticos... Em notebooks Pluto ou em editores conectados √† um Julia Language Server podemos entrar esses s√≠mbolos digitando seu equivalente em LaTeX e pressionando a tecla <TAB>. Uma lista detalhada de caracteres suportados √© apresentada aqui.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"julia> favorite_number_3 = œÄ\nœÄ = 3.1415926535897...\n\njulia> typeof(favorite_number_3)\nIrrational{:œÄ}","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"Por exemplo, tamb√©m temos o n√∫mero de Euler representado como irracional. Como este n√∫mero √© representado pela letra e, para evitar conflitos com outras vari√°veis ele precisa ser acessado pelo caminho completo do m√≥dulo definindo as constantes matem√°ticas.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"julia> favorite_number_4 = MathConstants.e\n‚ÑØ = 2.7182818284590...\n\njulia> typeof(favorite_number_4)\nIrrational{:‚ÑØ}","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"Outro exemplo de constante irracional √© a propor√ß√£o √°urea.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"julia> Base.MathConstants.golden\nœÜ = 1.6180339887498...","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"A lista completa pode ser acessada com names(module) como se segue:","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"julia> names(MathConstants)\n10-element Vector{Symbol}:\n :MathConstants\n :catalan\n :e\n :eulergamma\n :golden\n :pi\n :Œ≥\n :œÄ\n :œÜ\n :‚ÑØ","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"O nome de vari√°veis tamb√©m pode ser um emoji ‚Äì evite isso em programas, evidentemente.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"julia> ü•∞ = \"Julia\"\n\"Julia\"\n\njulia> typeof(ü•∞)\nString","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"Usando essa possibilidade podemos brincar com o conceito como abaixo:","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"begin\nüê∂ = 1\nüòÄ = 0\nüòû = -1\n# Vamos ver se a express√£o a seguir √© avaliada como verdadeira.\n# Todo texto ap√≥s um `#` √© considerado um coment√°rio por Julia.\n# Abaixo vemos um novo operador de compara√ß√£o de igualdade `==`.\nüê∂ + üòû == üòÄ\nend\n\n# output\n\ntrue","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/#Coment√°rios","page":"Parte 1 - Primeiros passos","title":"Coment√°rios","text":"","category":"section"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"Vimos no bloco acima o primeiro bloco de coment√°rios identificado por linhas iniciando com #. Como coment√°rios n√£o s√£o express√µes, vemos abaixo que m√∫ltiplas linhas s√£o aceitas em uma √∫nica c√©lula contando que haja apenas uma express√£o no contexto. Coment√°rios s√£o desej√°veis para que entendamos mais tarde qual era o objetivo de uma dada opera√ß√£o. Confie em mim, anos mais tarde um c√≥digo que parecia evidente no momento da sua escritura, quando voc√™ tem o conceito a ser expresso fresco na cabe√ßa, pode parecer um texto em basco.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"begin\n# Em Julia, toda linha come√ßando por um `#` √© considerada um\n# coment√°rio. Coment√°rios ap√≥s declara√ß√µes tamb√©m s√£o poss√≠veis:\n\ncomment = 1;  # Um coment√°rio ap√≥s uma declara√ß√£o.\n\n#=\nComent√°rios de multiplas linhas tamb√©m podem ser escritos usando\no par `#=` seguido de texto e ent√£o `=#` no lugar de iniciar\ndiversas linhas com `#`, o que torna sua edi√ß√£o mais f√°cil.\n=#\nend","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/#Aritm√©tica-b√°sica","page":"Parte 1 - Primeiros passos","title":"Aritm√©tica b√°sica","text":"","category":"section"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"Podemos usar Julia em modo interativo como uma calculadora.","category":"page"},{"location":"Learning/JuliaParaCientistas/001-primeiros-passos/","page":"Parte 1 - Primeiros passos","title":"Parte 1 - Primeiros passos","text":"Vemos abaixo a adi√ß√£o + e subtra√ß√£o -,...","category":"page"},{"location":"DryToolingCore/abstract/#Abstract-types","page":"Abstract types","title":"Abstract types","text":"","category":"section"},{"location":"DryToolingCore/abstract/#Problem-solving-and-physical-models","page":"Abstract types","title":"Problem solving and physical models","text":"","category":"section"},{"location":"DryToolingCore/abstract/","page":"Abstract types","title":"Abstract types","text":"DryToolingCore.AbstractMatrixProblem\nDryToolingCore.AbstractIterativeSolver\nDryToolingCore.AbstractSolutionStorage\nDryToolingCore.AbstractPhysicalModel","category":"page"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractMatrixProblem","page":"Abstract types","title":"DryToolingCore.AbstractMatrixProblem","text":"Base type for linear algebra problems.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractIterativeSolver","page":"Abstract types","title":"DryToolingCore.AbstractIterativeSolver","text":"Base type for (nonlinear) iterative solvers.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractSolutionStorage","page":"Abstract types","title":"DryToolingCore.AbstractSolutionStorage","text":"Base type for storing simulation solution.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractPhysicalModel","page":"Abstract types","title":"DryToolingCore.AbstractPhysicalModel","text":"Base type for physical models.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#Transport,-thermodynamics,-and-kinetics","page":"Abstract types","title":"Transport, thermodynamics, and kinetics","text":"","category":"section"},{"location":"DryToolingCore/abstract/","page":"Abstract types","title":"Abstract types","text":"DryToolingCore.AbstractTransportModel\nDryToolingCore.AbstractSolidTransport\nDryToolingCore.AbstractGasThermo\nDryToolingCore.AbstractSolidThermo\nDryToolingCore.AbstractSolidMaterial\nDryToolingCore.AbstractMixtureSubstance\nDryToolingCore.AbstractMixturePhase\nDryToolingCore.AbstractKineticsMechanism","category":"page"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractTransportModel","page":"Abstract types","title":"DryToolingCore.AbstractTransportModel","text":"Base type for transport models.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractSolidTransport","page":"Abstract types","title":"DryToolingCore.AbstractSolidTransport","text":"Base type for transport models.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractGasThermo","page":"Abstract types","title":"DryToolingCore.AbstractGasThermo","text":"Base type for thermodynamic models.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractSolidThermo","page":"Abstract types","title":"DryToolingCore.AbstractSolidThermo","text":"Base type for thermodynamic models.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractSolidMaterial","page":"Abstract types","title":"DryToolingCore.AbstractSolidMaterial","text":"Base type for solid materials.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractMixtureSubstance","page":"Abstract types","title":"DryToolingCore.AbstractMixtureSubstance","text":"Base type for simplified mixture substances.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractMixturePhase","page":"Abstract types","title":"DryToolingCore.AbstractMixturePhase","text":"Base type for simplified mixture phases.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractKineticsMechanism","page":"Abstract types","title":"DryToolingCore.AbstractKineticsMechanism","text":"Base type for coded kinetics mechanisms.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#Finite-volume-method-and-relatives","page":"Abstract types","title":"Finite volume method and relatives","text":"","category":"section"},{"location":"DryToolingCore/abstract/","page":"Abstract types","title":"Abstract types","text":"DryToolingCore.AbstractDiffusionModel1D\nDryToolingCore.AbstractGrid1D","category":"page"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractDiffusionModel1D","page":"Abstract types","title":"DryToolingCore.AbstractDiffusionModel1D","text":"Base type for diffusion (heat, species, ...) models.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractGrid1D","page":"Abstract types","title":"DryToolingCore.AbstractGrid1D","text":"Base type of one-dimensional grids.\n\n\n\n\n\n","category":"type"},{"location":"Learning/JuliaParaCientistas/#Julia-para-Cientistas","page":"Julia para Cientistas","title":"Julia para Cientistas","text":"","category":"section"},{"location":"Learning/JuliaParaCientistas/","page":"Julia para Cientistas","title":"Julia para Cientistas","text":"Primeiros Passos","category":"page"},{"location":"Learning/JuliaParaCientistas/","page":"Julia para Cientistas","title":"Julia para Cientistas","text":"1. [Manipulacao Textual](002-manipulacao-textual.md)\n1. [Estruturas De Dados](003-estruturas-de-dados.md)\n1. [Estruturas De Dados](004-estruturas-de-dados.md)\n1. [Lacos E Condicionais](005-lacos-e-condicionais.md)\n1. [Funcoes E Despacho](006-funcoes-e-despacho.md)\n1. [Pacotes E Ecossistema](007-pacotes-e-ecossistema.md)\n1. [Avaliando Performance](008-avaliando-performance.md)\n1. [Algebra Linear](009-algebra-linear.md)\n1. [Expressoes Regulares](010-expressoes-regulares.md)\n1. [Execucao Concorrente](011-execucao-concorrente.md)\n1. [Trabalhando Com Arquivos](012-trabalhando-com-arquivos.md)\n1. [Bibliotecas Graficas](013-bibliotecas-graficas.md)\n1. [Graficos Para Publicacoes](014-graficos-para-publicacoes.md)\n1. [Tipos De Dados E Estruturas](015-tipos-de-dados-e-estruturas.md)\n1. [Metaprogramacao E Macros](016-metaprogramacao-e-macros.md)\n1. [Interoperacao Com C](017-interoperacao-com-c.md)","category":"page"},{"location":"toc/#Table-of-contents","page":"Table of Contents","title":"Table of contents","text":"","category":"section"},{"location":"toc/","page":"Table of Contents","title":"Table of Contents","text":"Depth = 4","category":"page"},{"location":"dev/#Developement","page":"Developement","title":"Developement","text":"","category":"section"},{"location":"dev/","page":"Developement","title":"Developement","text":"DryTooling is an unpublished rolling release package set composed of several sub-packages currently not following any versioning semantics. That means that new features are added and only the commits track differences. This is temporary and will be modified when all the old code base that is giving origing to the package is migrated here. Nonetheless, the package will probably not be published to Julia registries because of the way its governance works. DryTooling tries to be self-contained in several aspects because of the needs of perfect integration between functionalities of several of its foreseen end applications. That is currently incompatible with using some of the state-of-the-art packages from Julia ecosystem.","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"This page aims at providing a tutorial for managing DryTooling.","category":"page"},{"location":"dev/#Adding-new-packages","page":"Developement","title":"Adding new packages","text":"","category":"section"},{"location":"dev/","page":"Developement","title":"Developement","text":"To add a new package to the framework launch a terminal under the src/ directory of the parent repository and state a julia REPL. Then change to pkg> mode by pressing ] and run generate DryTooling<package-name>.jl, where you should replace the <package-name> by the actual package's name.","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"Packages must use cammel-case naming scheme and start with DryTooling.\nDo not forget to add a .jl to the end of the package name.","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"This will create a subdirectory with the given package name and its own src/ directory and Project.toml file.","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"Next you need to add the package to the documentation workflow. Update docs/make.jl following the pattern for existing sub-packages, i.e, add the package name without .jl extension to global DRYTOOLING and below, with other subpackages, add a using directive for the package. Keep packages in alphabetical order as displayed in file explorer for ease of verification.","category":"page"},{"location":"dev/#Generating-the-documentation","page":"Developement","title":"Generating the documentation","text":"","category":"section"},{"location":"dev/","page":"Developement","title":"Developement","text":"Documentation is generated by a GitHub Actions workflow at every commit to the main branch.","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"Because of the multiple package in a repository structure, this documentation follows intrinsically a rolling release logic. Because the packages are not registered, they also do not appear in the docs/Project.toml. So it is up to the maintainers to ensure that section [deps] of docs/Project.toml points to ALL dependencies of ALL subpackages. ","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"For generating the documentation locally, from a Julia session running from docs/ , this is automalically done by  make.jl and the following is run from the REPL:","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"(@v1.9) pkg> activate .\n  Activating project at `D:\\DryTooling.jl\\docs`\n\njulia> include(\"make.jl\")\n   Resolving package versions...\n   ...","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"Notice that this will backup docs/Project.toml and revert changes automatically. If the process fails, DO NOT commit changes to docs/Project.toml, otherwise GitHub Actions workflow will fail (because packages are not registered).","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/#Kramers'-model","page":"Kramers' model","title":"Kramers' model","text":"","category":"section"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"using CairoMakie\nusing CSV\nusing DataFrames\nusing Latexify\nusing Printf\nusing DryToolingGranular\n\n\"Partial data from Kramers (1952) Table 3\"\nconst DATA_TABLE3 = \"\"\"\\\nœÅ,Œ≥,tan(Œ≤),n,mÃá,prod_dimless,Œ∑ÃÑ·µ£,hold_real\n1480.0,36.0,0.0094,0.059,5.15e-03,18.3,0.111,8.10\n1480.0,36.0,0.0094,0.090,2.68e-03,6.25,0.054,5.00\n1480.0,36.0,0.0094,0.195,1.32e-02,14.2,0.088,7.75\n1480.0,36.0,0.0094,0.232,7.24e-03,6.55,0.043,3.85\n1480.0,36.0,0.0100,0.040,6.38e-03,29.7,0.169,13.3\n1480.0,36.0,0.0100,0.040,5.00e-03,23.2,0.144,11.2\n1480.0,36.0,0.0100,0.069,9.20e-03,24.8,0.150,10.6\n1480.0,36.0,0.0100,0.069,6.53e-03,17.6,0.113,8.50\n1480.0,36.0,0.0100,0.106,1.50e-02,27.8,0.162,12.2\n1480.0,36.0,0.0100,0.159,1.20e-02,14.0,0.092,7.49\n1480.0,36.0,0.0100,0.238,1.55e-02,12.1,0.083,7.48\n1480.0,36.0,0.0100,0.238,1.19e-02,9.22,0.068,6.13\n\"\"\"\n\n\"Compares approximate analytical to numerical solution.\"\nfunction solvekiln(; L, D, Œ¶, œâ, Œ≤, Œ≥, d, show = true)\n    model = RotaryKilnBedSolution(;\n        model = SymbolicLinearKramersModel(),\n        L     = L,\n        R     = D / 2.0,\n        Œ¶     = Œ¶ / 3600.0,\n        œâ     = œâ / 60.0,\n        Œ≤     = deg2rad(Œ≤),\n        Œ≥     = deg2rad(Œ≥),\n        d     = d / 1000.0\n    )\n\n    optim = kramersnlapprox(;\n        z = model.z,\n        R = D / 2.0,\n        Œ¶ = Œ¶ / 3600.0,\n        œâ = œâ / 60.0,\n        Œ≤ = deg2rad(Œ≤),\n        Œ≥ = deg2rad(Œ≥),\n        d = d / 1000.0\n    )\n\n    f = nothing\n    ax = nothing\n\n    if show\n        f = Figure()\n        ax = Axis(f[1, 1])\n\n        lines!(ax, 100model.z/L, 100model.h, linewidth = 3, label = \"Numerical\")\n        lines!(ax, 100optim.z/L, 100optim.h, linewidth = 3, label = \"Analytical\")\n\n        a = @sprintf(\"%.1f\", model.Œ∑‚Çò)\n        b = @sprintf(\"%.1f\", optim.Œ∑‚Çò)\n        title = \"Loading: $(a)% (numerical) | $(b)% (analytical)\"\n\n        ax.title = title\n        ax.xlabel = \"Coordinate [%]\"\n        ax.ylabel = \"Bed height [cm]\"\n        ax.xticks = 0.0:20.0:100.0\n        xlims!(ax, extrema(ax.xticks.val))\n    end\n\n    return model, optim, f, ax\nend\n\n\"Reference case for alumina kiln testing.\"\nfunction aluminakiln(mÃá, œâ; show = false)\n    # Density of bed [kg/m¬≥]\n    œÅ = 800.0\n    L = 34.0\n    D = 1.5\n    Œ≤ = atan(0.025)\n\n    model, optim, f, ax = solvekiln(\n        L = L,\n        D = D,\n        Œ¶ = (1000// 24) * mÃá / œÅ,\n        œâ = œâ,\n        Œ≤ = rad2deg(Œ≤),\n        Œ≥ = 33.0,\n        d = 0.050,\n        show = show\n    )\n\n    œÑ‚Çö = perrayresidence(L, œâ, D, Œ≤)\n\n    return model, optim, f, ax, œÑ‚Çö\nend\n\n\"Run `aluminakiln` against some known conditions.\"\nfunction scanaluminakiln()\n    mÃálist = [33.6, 43.2]\n    œâlist = [0.85, 1.20]\n\n    df = DataFrame(\n        mÃá = Float64[],\n        œâ = Float64[],\n        Œ∑ÃÑ = Float64[],\n        œÑ·µ¢ = Float64[],\n        œÑ‚Çö = Float64[]\n    )\n\n    for mÃá ‚àà mÃálist, œâ ‚àà œâlist\n        model, _, _, _, œÑ = aluminakiln(mÃá, œâ, show = false)\n        Œ∑ÃÑ = round(model.Œ∑‚Çò, digits = 0)\n        œÑ·µ¢ = round(model.œÑ / 60.0, digits = 0)\n        œÑ‚Çö = round(œÑ, digits = 0)\n        push!(df, [mÃá œâ Œ∑ÃÑ œÑ·µ¢ œÑ‚Çö])\n    end\n\n    return df\nend\n\nlet\n    # @info(\"Solution of reference case\")\n\n    in1_to_m1(v) = 0.0254 * v\n    ft1_to_m1(v) = in1_to_m1(12.0) * v\n    ft3_to_m3(v) = ft1_to_m1(1.0)^3 * v\n\n    # Kiln length [m]\n    L = ft1_to_m1(45.0)\n\n    # Kiln diameter [m]\n    D = 2 * ft1_to_m1(3.1)\n\n    # Volume flow rate [m¬≥/h]\n    Œ¶ = ft3_to_m3(6.1) * 60\n\n    # Rotation rate (+0.0005) [rev/min]\n    œâ = 0.0505 * 60.0\n\n    # Kiln slope (0.5in/ft) [¬∞]\n    Œ≤ = rad2deg(atan(0.5 / 12))\n\n    # Repose angle [¬∞]\n    Œ≥ = 45.0\n\n    # Particle size [mm]\n    d = 0.050\n\n    # Conversions to match model inputs.\n    R = D / 2.0\n    Œ¶ = Œ¶ / 3600.0\n    œâ = œâ / 60.0\n    Œ≤ = deg2rad(Œ≤)\n    Œ≥ = deg2rad(Œ≥)\n    d = d / 1000.0\n\n    # Create problem container.\n    kramers = RotaryKilnBedSolution(;\n        model = SymbolicLinearKramersModel(),\n        L     = L,\n        R     = R,\n        Œ¶     = Œ¶,\n        œâ     = œâ,\n        Œ≤     = Œ≤,\n        Œ≥     = Œ≥,\n        d     = d\n    )\n\n    optim = kramersnlapprox(;\n        z = kramers.z,\n        R = R,\n        Œ¶ = Œ¶,\n        œâ = œâ,\n        Œ≤ = Œ≤,\n        Œ≥ = Œ≥,\n        d = d\n    )\n\n    global kramers_NŒ¶ = dimlessNŒ¶(R, Œ≤, œâ, Œ¶, Œ≥)\n    global kramers_N‚Çñ = dimlessN‚Çñ(L, R, Œ≤, Œ≥)\n    global kramers_Œ∑ÃÑ‚Çõ = sullivansŒ∑‚Çò(R, Œ≤, œâ, Œ¶, Œ≥)\n    global kramers_ref = kramers\n    global optim_ref = optim\n\n    global RESULTS_TABLE = DataFrame(\n        Quantity  = [\n            \"NŒ¶\",\n            \"N‚Çñ\",\n            \"Œ∑ÃÑ·µ£\",\n            \"Œ∑ÃÑ·µ¢\",\n        ],\n        Reference = [\n            \"1.15\",\n            \"1.17\",\n            \"5.65\",\n            @sprintf(\"%.2f\", optim_ref.Œ∑‚Çò)\n        ],\n        Computed  = [\n            @sprintf(\"%.2f\", kramers_NŒ¶),\n            @sprintf(\"%.2f\", kramers_N‚Çñ),\n            @sprintf(\"%.2f\", kramers_Œ∑ÃÑ‚Çõ),\n            @sprintf(\"%.2f\", kramers_ref.Œ∑‚Çò)\n        ]\n    )\nend\n\nconst TABLE3 = let\n    # @info(\"Verification of *Table 3*\")\n\n    D‚Çñ = 0.197\n    L‚Çñ = 1.780\n    d‚Çñ = 0.0012\n\n    table3 = DataFrame(CSV.File(IOBuffer(DATA_TABLE3)))\n    table3[!, \"Œ∑ÃÑ·µ¢\"] = zeros(length(table3[!, \"Œ∑ÃÑ·µ£\"]))\n    table3[!, \"Œ∑ÃÑ·µ£\"] *= 100\n\n    model = SymbolicLinearKramersModel()\n\n    for (i, row) in enumerate(eachrow(table3))\n        Œ¶ = 3600.0 * row[\"mÃá\"] / row[\"œÅ\"]\n        œâ = row[\"n\"] * 60.0\n        Œ≤ = rad2deg(atan(row[\"tan(Œ≤)\"]))\n        Œ≥ = row[\"Œ≥\"]\n\n        kramers = RotaryKilnBedSolution(;\n            model = model,\n            L     = L‚Çñ,\n            R     = D‚Çñ / 2.0,\n            Œ¶     = Œ¶ / 3600.0,\n            œâ     = œâ / 60.0,\n            Œ≤     = deg2rad(Œ≤),\n            Œ≥     = deg2rad(Œ≥),\n            d     = d‚Çñ / 1000.0\n        )\n\n        table3[i, \"Œ∑ÃÑ·µ¢\"] = round(kramers.Œ∑‚Çò, digits = 1)\n    end\n\n    exclude = [\"œÅ\", \"Œ≥\", \"prod_dimless\", \"hold_real\"]\n    select(table3, Not(exclude))\nend\n\nconst DIMLESSPLOT = let\n    @info(\"Dimensionless profiles solution\")\n\n    œÅ = 1480.0\n    L = 20.0\n    D = 0.197\n    Œ¶ = 5.15e-03 / œÅ * 3600\n    œâ = 0.059 * 60\n    Œ≤ = rad2deg(atan(0.0094))\n    Œ≥ = 36.0\n\n    # Conversions to match model inputs.\n    R = D / 2.0\n    Œ¶ = Œ¶ / 3600.0\n    œâ = œâ / 60.0\n    Œ≤ = deg2rad(Œ≤)\n    Œ≥ = deg2rad(Œ≥)\n\n    # Things held constant in loop.\n    NŒ¶ = dimlessNŒ¶(R, Œ≤, œâ, Œ¶, Œ≥)\n    N‚Çñ = dimlessN‚Çñ(L, R, Œ≤, Œ≥)\n    model = SymbolicLinearKramersModel()\n\n    f = Figure()\n    ax = Axis(f[1, 1])\n\n    for d in [0.05, 0.10, 0.15, 0.193, 0.25]\n        kramers = RotaryKilnBedSolution(;\n            model = model,\n            L     = L,\n            R     = R,\n            Œ¶     = Œ¶,\n            œâ     = œâ,\n            Œ≤     = Œ≤,\n            Œ≥     = Œ≥,\n            d     = d * R * NŒ¶\n        )\n\n        # Dimensionless axes.\n        z = kramers.z\n        h = kramers.h / (R * NŒ¶)\n        z = @. (L - z) / L * 1 / (NŒ¶ * N‚Çñ)\n        z = @. z[1] - z\n\n        label = @sprintf(\"%.3f\", d)\n        lines!(ax, z, h; linewidth = 2, label = label)\n    end\n\n    ax.title = \"Dimensionless loading curves\"\n    ax.xlabel = \"Coordinate\"\n    ax.ylabel = \"Bed height\"\n    ax.xticks.val = 0.0:0.1:0.5\n    ax.yticks.val = 0.05:0.05:0.25\n    xlims!(ax, extrema(ax.xticks.val))\n    ylims!(ax, extrema(ax.yticks.val))\n    axislegend(ax; position = :rb)\n\n    f\nend","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/#Sample-reference-case","page":"Kramers' model","title":"Sample reference case","text":"","category":"section"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"Here we make use of the current implementation to check if it correctly approximates the last example provided in reference paper from Kramers (1952). To minimize rounding errors causes by unit conversions, we provide the required functions to convert from imperial to international system in the solution process.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"The next table summarizes the results. It is seen that the dimensionless numbers are well approximated. It must be emphasized that the reference estimates Œ∑ÃÑ·µ£ by a graphical method ‚Äì it was 1952 ‚Äì and the current value is considered a good enough approximation. Additionally, the equation was not integrated numerically as done here, but engineering relationships were used in the approximation. That said, the proper loading to be considered in our days is Œ∑ÃÑ·µ¢.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"mdtable(RESULTS_TABLE, latex=false) # hide","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"Note: the last value in column Reference above is not provided in Kramers' paper but computed from the approximate analytical solution provided by the authors. As we see here, it may get >20% error under some circumstances.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/#Verification-of-*Table-3*","page":"Kramers' model","title":"Verification of Table 3","text":"","category":"section"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"In the next cell we provide the kiln dimensions used by Kramers (1952) to experimentally validate the model. Some data from their Tab. 3 is then loaded and all rows are simulated with current model. Fractional hold-up seems to be well correlated at least to a few percent of the reference value.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"mdtable(TABLE3, latex=false) # hide","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/#Dimensionless-profiles","page":"Kramers' model","title":"Dimensionless profiles","text":"","category":"section"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"Next step in validation is to check profiles in dimensionless format, as done by Kramers in their Fig. 3. Notice that here we used the numerical integration curves instead of the analytical approximation of profiles, so reproduction and consequences of results are not exactly the same.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"DIMLESSPLOT # hide","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/#Comparison-with-analytical","page":"Kramers' model","title":"Comparison with analytical","text":"","category":"section"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"The final step in model validation is to compare the approximate analytical solution proposed by Kramers and the results of numerical integration. It is worth mentioning that numerical integration remains the recommended method because one does not need to verify the ranges of validity of analytical approximation for every use case.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"let                                    # hide\n    _, _, f, ax = solvekiln(           # hide\n        L = 10.0,                      # hide\n        D = 1.0,                       # hide\n        Œ¶ = 1.0,                       # hide\n        œâ = 1.0,                       # hide\n        Œ≤ = 3.0,                       # hide\n        Œ≥ = 45.0,                      # hide\n        d = 0.001                      # hide\n    )                                  # hide\n                                       # hide\n    ax.yticks = 0.0:4.0:20.0           # hide\n    ylims!(ax, extrema(ax.yticks.val)) # hide\n    f                                  # hide\nend                                    # hide","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/#Industrial-cases","page":"Kramers' model","title":"Industrial cases","text":"","category":"section"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"The following illustrates a practical use case of the model. Next we scan a parameter space to confirm once again the model suitability as an alternative to analytical engineering estimations as per Peray's notebook.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"let                                                 # hide\n    mÃá = 33.6                                        # hide\n    œâ = 0.85                                        # hide\n    _, _, f, ax, _ = aluminakiln(mÃá, œâ, show = true) # hide\n    ax.yticks = 0.0:6.0:30.0                        # hide\n    ylims!(ax, extrema(ax.yticks.val))              # hide\n    f                                               # hide\nend                                                 # hide","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"The following table confirms the expected values as per Peray.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"mdtable(scanaluminakiln(), latex=false) # hide","category":"page"},{"location":"DryToolingCore/#DryToolingCore","page":"DryToolingCore","title":"DryToolingCore","text":"","category":"section"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"CurrentModule = DryToolingCore\nDocTestSetup  = quote\n    using DryToolingCore\nend","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"The core package of DryTooling ecosystem provides shared functionalities and types that are used in several other more specialized packages. This allows for standardization of interfaces, employed quantities, and avoid boilerplate code. Rather than documenting the exposed functionalities in implemented order, this page organizes everything to facilitate the understanding of the end-user. Here you find the constants by multi-purpose functionalities. All abstract types were grouped in a dedicated page.","category":"page"},{"location":"DryToolingCore/#Physical-constants","page":"DryToolingCore","title":"Physical constants","text":"","category":"section"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.GAS_CONSTANT\nDryToolingCore.ZERO_CELSIUS\nDryToolingCore.ONE_ATM\nDryToolingCore.STEFAN_BOLTZMANN","category":"page"},{"location":"DryToolingCore/#DryToolingCore.GAS_CONSTANT","page":"DryToolingCore","title":"DryToolingCore.GAS_CONSTANT","text":"Ideal gas constant [8.31446261815324 J mol^-1 K^-1].\n\n\n\n\n\n","category":"constant"},{"location":"DryToolingCore/#DryToolingCore.ZERO_CELSIUS","page":"DryToolingCore","title":"DryToolingCore.ZERO_CELSIUS","text":"Zero degrees Celsius in Kelvin [273.15 K].\n\n\n\n\n\n","category":"constant"},{"location":"DryToolingCore/#DryToolingCore.ONE_ATM","page":"DryToolingCore","title":"DryToolingCore.ONE_ATM","text":"Atmospheric pressure at sea level [101325.0 Pa].\n\n\n\n\n\n","category":"constant"},{"location":"DryToolingCore/#DryToolingCore.STEFAN_BOLTZMANN","page":"DryToolingCore","title":"DryToolingCore.STEFAN_BOLTZMANN","text":"Stefan-Boltzmann constant [5.670374419e-8 W m^-2 K^-4]\n\n\n\n\n\n","category":"constant"},{"location":"DryToolingCore/#Haskell-like-array-slicing","page":"DryToolingCore","title":"Haskell-like array slicing","text":"","category":"section"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"Those who know Haskell probably started learning it by manipulating lists with head and tail. Those functionalities are not available in Julia by default and array slicing - with an ugly syntax - is required. Since this is done often in the fields of application of DryTooling, both head and tail together with a body functions are available in its core. They are simple wrapers over the @view macro and work with both iterable types and arrays. The following snippet illustrates their usage.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> v = collect(1:4);\n\njulia> head(v) == [1; 2; 3]\ntrue\n\njulia> tail(v) == [2; 3; 4]\ntrue\n\njulia> body(v) == [2; 3]\ntrue","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"More examples are provided in the following documentation ahead of each of the functions.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> head(1:4)\n1:3\n\njulia> head([1, 2, 3, 4])\n3-element view(::Vector{Int64}, 1:3) with eltype Int64:\n 1\n 2\n 3\n","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.head","category":"page"},{"location":"DryToolingCore/#DryToolingCore.head","page":"DryToolingCore","title":"DryToolingCore.head","text":"head(z)\n\nAccess view of array head. See also tail and body.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> tail([1, 2, 3, 4])\n3-element view(::Vector{Int64}, 2:4) with eltype Int64:\n 2\n 3\n 4\njulia> tail(1:4)\n2:4","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.tail","category":"page"},{"location":"DryToolingCore/#DryToolingCore.tail","page":"DryToolingCore","title":"DryToolingCore.tail","text":"tail(z)\n\nAccess view of array tail. See also head and body.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> body([1, 2, 3, 4])\n2-element view(::Vector{Int64}, 2:3) with eltype Int64:\n 2\n 3\njulia> body(1:4)\n2:3","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.body","category":"page"},{"location":"DryToolingCore/#DryToolingCore.body","page":"DryToolingCore","title":"DryToolingCore.body","text":"body(z)\n\nAccess view of array body. See also  head and tail.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/#Handling-of-discontinuous-functions","page":"DryToolingCore","title":"Handling of discontinuous functions","text":"","category":"section"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"Discontinuous functions are all over in real world applications. Whether they handle discrete signals sent to controllers or represent a material property change in the solution domain of a heat transfer simulation, they are often represented by a single or a composition of Heaviside step functions. Again, because its implementation is pretty simple and optimization routines require a differentiable form of this function, DryTooling implements heaviside and interval as proposed in this StackOverflow answer.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> heaviside(-1) == 0\ntrue\n\njulia> heaviside(-1.0) == 0.0\ntrue\n\njulia> heaviside(0.0) == 0.5\ntrue\n\njulia> heaviside(1.0) == 1.0\ntrue\n\njulia> interval(10; a = 0, b = 10) == 0.5\ntrue","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"We see below that heaviside also works on ranges","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> heaviside(-2:2)\n5-element Vector{Float64}:\n 0.0\n 0.0\n 0.5\n 1.0\n 1.0","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.heaviside","category":"page"},{"location":"DryToolingCore/#DryToolingCore.heaviside","page":"DryToolingCore","title":"DryToolingCore.heaviside","text":"heaviside(t)\n\nProvides a Heaviside function compatible with automatic differentiation. This is a requirement for conceiving, e.g., model predictive controls with discontinuous functions under ModelingToolkit.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"By implementation inheritance that is also the case for interval:","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> interval(0:6; a = 2, b = 5)\n7-element Vector{Float64}:\n 0.0\n 0.0\n 0.5\n 1.0\n 1.0\n 0.5\n 0.0","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.interval","category":"page"},{"location":"DryToolingCore/#DryToolingCore.interval","page":"DryToolingCore","title":"DryToolingCore.interval","text":"interval(x; a=-Inf, b=Inf)\n\nReturns 1 if x  (a b), 1/2 for x = a  x = b, or 0.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"As it is the case for representation of specific heats using NASA7/NASA9 or Shomate polynomials, functions defined by parts with an specific change point are also required in physical modeling. To this end, a stepwise function can be established with makestepwise1d. If keyword differentialble = true, then the function makes use of the above interval and remains compatible with ModelingToolkit, for instance.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> f = makestepwise1d(x->x, x->x^2, 1.0; differentiable = true);\n\njulia> f(0:0.2:2.0)\n11-element Vector{Float64}:\n 0.0\n 0.2\n 0.4\n 0.6\n 0.8\n 1.0\n 1.44\n 1.9599999999999997\n 2.5600000000000005\n 3.24\n 4.0\n\njulia> using ModelingToolkit\n\njulia> @variables x\n1-element Vector{Num}:\n x\n\njulia> f(x); # Output is too long, try by yourself.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.makestepwise1d","category":"page"},{"location":"DryToolingCore/#DryToolingCore.makestepwise1d","page":"DryToolingCore","title":"DryToolingCore.makestepwise1d","text":"makestepwise1d(lo, hi, xc)\n\nCreates an univariate function that is composed of two parts, the first evaluated before a critical domain point xc, and the second above that value. This is often required, for instance, for the evaluation of NASA polynomials for thermodynamic properties. If differentiable, then the returned function is compatible with symbolic argument as required when using package ModelingToolkit, etc.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/#Rounding-numbers-and-automatic-axes","page":"DryToolingCore","title":"Rounding numbers and automatic axes","text":"","category":"section"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"danger: Danger\nThis section documents functions that are used in a very unstable context and might evolve in the next commits until an stable interface is established.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"Simple rounding is not enough. Getting values that are rounded close to a power of a given number and rounded to floor or ceil is often the case. This is standardized in DryTooling through closestpowerofx:","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> closestpowerofx(10)\n10\n\njulia> closestpowerofx(11)\n20\n\njulia> closestpowerofx(11, roundf = floor)\n10\n\njulia> closestpowerofx(11, x = 5, roundf = floor)\n10\n\njulia> closestpowerofx(12.0; x = 10)\n20\n\njulia> closestpowerofx(12.0; x = 10, roundf = floor)\n10\n\njulia> closestpowerofx(12.0; x = 10, roundf = round)\n10","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.closestpowerofx","category":"page"},{"location":"DryToolingCore/#DryToolingCore.closestpowerofx","page":"DryToolingCore","title":"DryToolingCore.closestpowerofx","text":"closestpowerofx(\n    v::Number;\n    x::Number = 10,\n    roundf::Function = ceil\n)::Int64\n\nCompute the integer power of x closest to v using roundf as rouding method. This might be useful for automatic setting more reasonable limits to plot axis or similar applications. Changing the rouding method through roundf is also possible.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"Below we illustrate the usage of axesunitscaler.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"NOTE: this function is not yet stable. In the future it will instead return labels using symbols like k, M, G, etc., for the units through a flag provided by the user.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> axesunitscaler(1)\n(\"\", 1)\n\njulia> axesunitscaler(1000)\n(\"[√ó1000]\", 1000)\n\njulia> axesunitscaler(1000000)\n(\"[√ó1000000]\", 1000000)","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.axesunitscaler","category":"page"},{"location":"DryToolingCore/#DryToolingCore.axesunitscaler","page":"DryToolingCore","title":"DryToolingCore.axesunitscaler","text":"axesunitscaler(x::Number)::Tuple{String, Int64}\n\nFind scaling factor for multiples of 1000 units. Together with closestpowerofx this can be used to produce better automatic plot axes limits. The returned values provide the string for modifying the axis label and the associated scaling factor.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/#Computation-of-changes-and-residuals","page":"DryToolingCore","title":"Computation of changes and residuals","text":"","category":"section"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"danger: Danger\nThis section documents functions that are used in a very unstable context and might evolve in the next commits until an stable interface is established.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.maxabsolutechange\nDryToolingCore.maxrelativechange","category":"page"},{"location":"DryToolingCore/#DryToolingCore.maxabsolutechange","page":"DryToolingCore","title":"DryToolingCore.maxabsolutechange","text":"Maximum absolute change in a solution array.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/#DryToolingCore.maxrelativechange","page":"DryToolingCore","title":"DryToolingCore.maxrelativechange","text":"Maximum relative change in a solution array.\n\n\n\n\n\n","category":"function"},{"location":"Learning/TransportPhenomena/#Transport-Phenomena","page":"Transport Phenomena","title":"Transport Phenomena","text":"","category":"section"},{"location":"api/#Reference-API","page":"Reference API","title":"Reference API","text":"","category":"section"},{"location":"api/","page":"Reference API","title":"Reference API","text":"In this page you find a list of all documented functions of DryTooling. Rather than being organized in a logical way as the main documentation, we chose (except for the root DryTooling that comes first) to list them in alphabetical order of folders in source directory.","category":"page"},{"location":"api/#DryToolingCore.jl","page":"Reference API","title":"DryToolingCore.jl","text":"","category":"section"},{"location":"api/","page":"Reference API","title":"Reference API","text":"Modules = [ DryToolingCore ]","category":"page"},{"location":"api/#DryToolingGranular.jl","page":"Reference API","title":"DryToolingGranular.jl","text":"","category":"section"},{"location":"api/","page":"Reference API","title":"Reference API","text":"Modules = [ DryToolingGranular ]","category":"page"},{"location":"DryToolingSimulation/#DryToolingSimulation","page":"Simulation","title":"DryToolingSimulation","text":"","category":"section"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"CurrentModule = DryToolingSimulation\nDocTestSetup  = quote\n    using DryToolingSimulation\nend","category":"page"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"danger: Danger\nThis module is fragile and breaking changes are still expected. It is not until all the main solvers are migrated that it will become stable. This is necessary for ensuring compatibility with all models.","category":"page"},{"location":"DryToolingSimulation/#Iterative-solver","page":"Simulation","title":"Iterative solver","text":"","category":"section"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"The core of the iterative time-stepping solver is step!. This function that is described below works according to the following solution logic:","category":"page"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"The fouter! update function is called once. This is generall where one implements the right-hand side update of the problem before stepping.\nAn initial update with finner! is done. Normally this is responsible by the update of matrix coefficients that are dependent on solution state.\nIf relaxation Œ± <= 0.0, then the problem is treated as linear.\nOtherwise a maximum of M iterations are repeated, where fsolve! is used to solve the problem (ofter an under-relaxation step) and is also expected to keep track of residuals.\nProblem coefficients are updated with finner! if not converged.","category":"page"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"DryToolingSimulation.step!","category":"page"},{"location":"DryToolingSimulation/#DryToolingSimulation.step!","page":"Simulation","title":"DryToolingSimulation.step!","text":"step!(\n    m::AbstractPhysicalModel,\n    t::Float64,\n    n::Int64;\n    fouter!::Function,\n    finner!::Function,\n    fsolve!::Function,\n    Œ±::Float64 = 0.1,\n    iters::Int64 = 20,\n    tol::Float64 = 1.0e-10\n)\n\nManage the integration of a model m from time t corresponding to step call n using model internal time step. All the updates of coefficients and solution are performed through user-supplied functions.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"The outer iteration for advancing between steps is carried out by advance!.","category":"page"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"DryToolingSimulation.advance!","category":"page"},{"location":"DryToolingSimulation/#DryToolingSimulation.advance!","page":"Simulation","title":"DryToolingSimulation.advance!","text":"advance!(\n    m::AbstractPhysicalModel;\n    Œ±::Float64 = 0.1,\n    Œµ::Float64 = 1.0e-10,\n    M::Int64 = 20,\n    t0::Float64 = 0.0\n)\n\nManage execution of step! over the integration time interval.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"Any model willing to implement its solution through the methods provided in this module is expected to explicity import and override the behaviour of the following methods for its own type:","category":"page"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"DryToolingSimulation.fouter!\nDryToolingSimulation.finner!\nDryToolingSimulation.fsolve!\nDryToolingSimulation.timepoints","category":"page"},{"location":"DryToolingSimulation/#DryToolingSimulation.fouter!","page":"Simulation","title":"DryToolingSimulation.fouter!","text":"fouter!(::AbstractPhysicalModel, ::Float64, ::Int64)\n\nOuter loop update for step!.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#DryToolingSimulation.finner!","page":"Simulation","title":"DryToolingSimulation.finner!","text":"finner!(::AbstractPhysicalModel, ::Float64, ::Int64)\n\nInner loop update for step!.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#DryToolingSimulation.fsolve!","page":"Simulation","title":"DryToolingSimulation.fsolve!","text":"fsolve!(::AbstractPhysicalModel, ::Float64, ::Int64, ::Float64)\n\nSolution update for step!.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#DryToolingSimulation.timepoints","page":"Simulation","title":"DryToolingSimulation.timepoints","text":"timepoints(::AbstractPhysicalModel)\n\nGet array of model time-points for use in step!.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#Linear-algebra","page":"Simulation","title":"Linear algebra","text":"","category":"section"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"DryToolingSimulation.TridiagonalProblem\nDryToolingSimulation.solve!(::DryToolingSimulation.TridiagonalProblem)\nDryToolingSimulation.change\nDryToolingSimulation.residual","category":"page"},{"location":"DryToolingSimulation/#DryToolingSimulation.TridiagonalProblem","page":"Simulation","title":"DryToolingSimulation.TridiagonalProblem","text":"Memory for a tridiagonal problem of rank N.\n\nAll tensors are filled with zeros upon creation. This is simply a utility for memory allocation, no other operations are made.\n\nA::LinearAlgebra.Tridiagonal{Float64, Vector{Float64}}: Main problem matrix.\nb::Vector{Float64}: Right-hand side vector.\nx::Vector{Float64}: Solution variable vector.\na::Vector{Float64}: Auxiliary vector, e.g. for iterative problems.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingSimulation/#DryToolingSimulation.solve!-Tuple{TridiagonalProblem}","page":"Simulation","title":"DryToolingSimulation.solve!","text":"solve!(p::TridiagonalProblem)::Nothing\n\nSolve problem x=A^-1b updating internal memory.\n\n\n\n\n\n","category":"method"},{"location":"DryToolingSimulation/#DryToolingSimulation.change","page":"Simulation","title":"DryToolingSimulation.change","text":"change(p::TridiagonalProblem)::Vector{Float64}\n\nChange in solution A^-1b-x of problem without update x.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#DryToolingSimulation.residual","page":"Simulation","title":"DryToolingSimulation.residual","text":"residual(p::TridiagonalProblem)::Vector{Float64}\n\nSolution residual b-Ax of problem without update of x.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#Residuals-tracking","page":"Simulation","title":"Residuals tracking","text":"","category":"section"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"DryToolingSimulation.TimeSteppingSimulationResiduals\nDryToolingSimulation.finaliterationdata\nDryToolingSimulation.addresidual!\nDryToolingSimulation.plotsimulationresiduals","category":"page"},{"location":"DryToolingSimulation/#DryToolingSimulation.TimeSteppingSimulationResiduals","page":"Simulation","title":"DryToolingSimulation.TimeSteppingSimulationResiduals","text":"Manage time-stepping solvers residuals storage during a simulation.\n\nThe memory is initialized with a given number of inner and outer iterations and resizing is not under the scope of this structure.\n\nN::Int64: Number of variables being tracked in problem.\ncounter::Base.RefValue{Int64}: Total iteration counter.\ninnersteps::Vector{Int64}: Number of inner steps per outer loop in solution.\nresiduals::Matrix{Float64}: Store residuals of each inner step, one variable per column.\n\nUsage\n\nFor starting a simulation, use the outer constructor for starting a simulation with pre-allocated memory with interface:\n\nTimeSteppingSimulationResiduals(N::Int64, inner::Int64, outer::Int64)\n\nOnce the simulation is finished, the first instance can be processed through creation of a new object using the next interface:\n\nTimeSteppingSimulationResiduals(r::TimeSteppingSimulationResiduals)\n\n\n\n\n\n","category":"type"},{"location":"DryToolingSimulation/#DryToolingSimulation.finaliterationdata","page":"Simulation","title":"DryToolingSimulation.finaliterationdata","text":"finaliterationdata(\n    r::TimeSteppingSimulationResiduals\n)::Tuple{Vector{Int64}, Matrix{Float64}}\n\nRetrieve data at iterations closing an outer loop of solution.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#DryToolingSimulation.addresidual!","page":"Simulation","title":"DryToolingSimulation.addresidual!","text":"addresidual!(\n    r::TimeSteppingSimulationResiduals,\n    Œµ::Vector{Float64}\n)::Nothing\n\nUtility to increment iteration counter and store residuals.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#DryToolingSimulation.plotsimulationresiduals","page":"Simulation","title":"DryToolingSimulation.plotsimulationresiduals","text":"plotsimulationresiduals(\n    r::TimeSteppingSimulationResiduals;\n    Œµ::Union{Float64, Nothing} = nothing,\n    showinner::Bool = false,\n    resolution::Tuple{Int64, Int64} = (720, 500)\n)::Tuple{Figure, Axis, Vector}\n\nPlot problem residuals over iterations or steps. It performs the basic figure setup, configuration of axis and details beign left to the user.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"The residuals tracking functionalities of module DryToolingSimulation are not often imported by the end-user (except for its plotting utility function). In this tutorial we illustrate the logic of using a residual tracker in a new solver.","category":"page"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"using DryToolingSimulation\n\nN = 2      # Number of variables.\nM = 5      # Maximum inner steps.\nsteps = 10 # Time-advancement steps.\n\n# Create a TimeSteppingSimulationResiduals object with the number of variables\n# to track, how many inner iterations per step are expected, and the\n# number of steps.\n#\n# IMPORTANT: If the total number of iterations is exceeded, it is up\n# to the user to allocate more memory, the tracker will not manage it!\nr = TimeSteppingSimulationResiduals(N, M, steps)\n\n# The following loop represents a *dummy solver*. The outer loop\n# provides the time-advancement while the inner loop handles the\n# nonlinear problem. In the inner loop we use a random number\n# generator to provide varying number of steps per outer step.\nfor kouter in 1:steps\n    for kinner in 1:rand(2:M)\n        # Keep track of inner iterations per step.\n        r.innersteps[kouter] = kinner\n\n        # Feed residuals to the solver.\n        addresidual!(r, rand(r.N))\n    end\nend\n\n# After running a simulation we create a new object using another\n# constructor that accepts a `TimeSteppingSimulationResiduals` object. This\n# handles the post-processing.\ns = TimeSteppingSimulationResiduals(r)\n\n# The new object is ready for visualization. Check the documentation\n# of the following function for more details. It provides a raw figure\n# and handles for modifying it for proper display.\nfig = plotsimulationresiduals(s; showinner = true)[1]","category":"page"},{"location":"DryToolingGranular/#DryToolingGranular","page":"Granular","title":"DryToolingGranular","text":"","category":"section"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"CurrentModule = DryToolingGranular\nDocTestSetup  = quote\n    using Statistics\n    using DryToolingGranular\nend","category":"page"},{"location":"DryToolingGranular/#General-porous-media","page":"Granular","title":"General porous media","text":"","category":"section"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"Modeling of geometrical characteristics of porous beds is required for including both their thermal effect or role over chemistry in chemical reactors. A classical approach used in several commercial and open source tools is that of Gunn [1]. In what follows we develop the ideas that lead to an analogous model which is implemented by this structure.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"To build the model we will assume a reactor of constant rectangular cross-section A_r=bw and volume V_R=bwh. Its cross-section perimeter is then P_R=2(b+w). Inside this reactor we randomly pack cubic particles beta of surface area A_beta=6l_beta^2 and volume V_beta=l_beta^3 at a porosity level phi. Thus the total volume of solids inside the reactor is V_S=(1-phi)V_R and the approximate number of particles N=fracV_SV_beta. Following a similar reasoning the total surface area of particles is A_S=NA_beta. Performing all the substitutions so far one finds the following expression","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"A_S=frac6(1-phi)bwhl_beta","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"Since the differential dA=Pdl holds for the surface of a body over its length l, one can divide the above expression by the reactor length to get the perimeter of particles in a cross-section. We can further divide by the cross-section area itself and find the perimeter density which is a more general result, and find the expression proposed by Gunn [1]. This result is summarized in the next equation where the subscript of particle size was dropped for generality.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"P = frac6(1-phi)l","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"An estimator of the number of channels per unit cross-section of reactor N can be related to the porosity through NpiR^2=phi. Because the above perimeter is shared between the fluid volume and solids, it holds that N2piR=P. Using these expressions one can solve for the porosity channels characteristic radius R as given below, which is also a result reported by Gunn [1].","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"R=fracphil3(1-phi)","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"This model is probided in PackedBedPorosityDescriptor.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"DryToolingGranular.PackedBedPorosityDescriptor","category":"page"},{"location":"DryToolingGranular/#DryToolingGranular.PackedBedPorosityDescriptor","page":"Granular","title":"DryToolingGranular.PackedBedPorosityDescriptor","text":"Provides description of porosity parameters with stochastic behavior.\n\nœï::Union{Float64, Vector{Float64}}: Porosity volume fraction in medium [-].\nl::Union{Float64, Vector{Float64}}: Characteristic particle size in medium [m].\nœÉœï::Union{Nothing, Float64}: Optional standard deviation of porosity volume fraction  [-].\nœÉl::Union{Nothing, Float64}: Optional standard deviation of characteristic particle size [m].\nP::Union{Float64, Vector{Float64}}: Perimeter in reactor cross-section [m].\nD::Union{Float64, Vector{Float64}}: Characteristic diameter of porosity channels [m].\nA::Float64: Reactor area used for scaling perimeter [m¬≤].\n\n\n\n\n\n","category":"type"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"PackedBedPorosityDescriptor can be used to describe the geometry of exchange section of a packed bed for a single set of arguments.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"julia> PackedBedPorosityDescriptor(; œï = 0.65, l = 0.10, area = 1.0)\nPackedBedPorosityDescriptor(P = 21.000000 m, D = 0.123810 m)","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"It can also be used to describe randomly varying reactors, what is a more realistic thing to do when using this structure to simulate real world systems.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"julia> PackedBedPorosityDescriptor(;\n            œï  = 0.65, l  = 0.10,\n            œÉœï = 0.03, œÉl = 0.01,\n            N = 2,\n            œïlims = (0.4, 0.8),\n            llims = (0.0, 0.3),\n            seed = 42,\n            area = 1.0\n        )\nPackedBedPorosityDescriptor(\n    P from  21.455749 m to  24.370742 m\n    D from   0.125589 m to   0.102353 m\n)","category":"page"},{"location":"DryToolingGranular/#Rotary-kiln-models","page":"Granular","title":"Rotary kiln models","text":"","category":"section"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"In a rotary kiln as proposed by Kramers and Croockewite (1952) [2]. Its goal is to be used as a process support tool or to integrate more complex models requiring integration of the bed profile. In its classical statement, the bed height profile h(z) can be evaluated from volume of flowing material conservation through the following equations. Coordinate z=0 represents the discharge position where initial condition must be applied. This is given by the dam height, if any, or particle size.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"beginaligned\ndfracdhdz = C‚ÇÅ leftfrachRleft(2 - frachRright)right^-frac32 - C‚ÇÇ6pt\nC‚ÇÅ             = frac34dfracŒ¶tanŒ≥œÄ R^3 œâ6pt\nC‚ÇÇ             = dfractanŒ≤cosŒ≥\nendaligned","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"The structure SymbolicLinearKramersModel implements the Kramers' ordinary differential equation for prediction of bed height profile in a rotary kiln. This equation is implemented under the formalism of ModelingToolkit.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"DryToolingGranular.SymbolicLinearKramersModel","category":"page"},{"location":"DryToolingGranular/#DryToolingGranular.SymbolicLinearKramersModel","page":"Granular","title":"DryToolingGranular.SymbolicLinearKramersModel","text":"Creates a reusable linear Kramers model for rotary kiln simulation.\n\nR::Symbolics.Num: Symbolic kiln internal radius\nŒ¶::Symbolics.Num: Symbolic kiln feed rate\nœâ::Symbolics.Num: Symbolic kiln rotation rate\nŒ≤::Symbolics.Num: Symbolic kiln slope\nŒ≥::Symbolics.Num: Symbolic solids repose angle\nz::Symbolics.Num: Symbolic kiln axial coordinates\nh::Symbolics.Num: Symbolic bed height profile\nsys::ModelingToolkit.ODESystem: Problem ordinary differential equation\n\n\n\n\n\n","category":"type"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"For integration of this model we implement RotaryKilnBedSolution. It provides the solved description of a rotary kiln bed geometry computed from the solution of bed height along the kiln length. The main goal of the quantities computed here is their use with heat and mass transfer models for the simulation of rotary kiln process. A simple post-processing utilitiy plotlinearkramersmodel is also provided.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"DryToolingGranular.RotaryKilnBedSolution\nDryToolingGranular.plotlinearkramersmodel","category":"page"},{"location":"DryToolingGranular/#DryToolingGranular.RotaryKilnBedSolution","page":"Granular","title":"DryToolingGranular.RotaryKilnBedSolution","text":"General geometric description of a bed from Kramers equation solution.\n\nz::Vector{Float64}: Solution coordinates [m]\nh::Vector{Float64}: Solution bed height [m]\nŒ∏::Vector{Float64}: View angle from kiln center [rad]\nl::Vector{Float64}: Bed-freeboard cord length [m]\nA::Vector{Float64}: Local bed cross section area [m¬≤]\nŒ∑::Vector{Float64}: Local loading based on height [-]\nŒ∑‚Çò::Float64: Mean loading of kiln [%]\nV::Float64: Bed integral volume [m¬≥]\nœÑ::Float64: Residence time of particles\nŒ≤::Float64: Kiln slope [rad]\n\nArguments\n\nInternal elements are initialized through the following constructor:\n\nRotaryKilnBedSolution(z, h, Œ≤, R, Œ¶)\n\nWhere parameters are given as:\n\nz: solution coordinates over length, [m].\nh: bed profile solution over length, [m].\nR: kiln internal radius, [m].\nŒ¶: kiln feed rate, [m¬≥/s].\n\nAn outer constructor is also provided for managing the integration of an instance of SymbolicLinearKramersModel. This is the recommended usage that is illustrated below.\n\nImportant: inputs must be provided in international system (SI) units as a better physical practice. The only exception is the rotation rate œâ provided in revolution multiples. If the discharge end is held by a dam, its height must be provided instead of the particle size, as it is used as the ODE initial condition.\n\nmodel: a symbolic kiln model.\nL: kiln length, [m].\nR: kiln internal radius, [m].\nŒ¶: kiln feed rate, [m¬≥/s].\nœâ: kiln rotation rate, [rev/s].\nŒ≤: kiln slope, [rad].\nŒ≥: solids repose angle, [rad].\nd: particle size or dam height, [m].\nsolver: Solver for DifferentialEquations. Defaults to Tsit5.\nrtol: Relative integration tolerance. Defaults to 1.0e-08.\natol: Absolute integration tolerance. Defaults to 1.0e-08.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingGranular/#DryToolingGranular.plotlinearkramersmodel","page":"Granular","title":"DryToolingGranular.plotlinearkramersmodel","text":"plotlinearkramersmodel(\n    model::RotaryKilnBedSolution;\n    normz::Bool = false,\n    normh::Bool = false\n)::Figure\n\nStandardized plotting of RotaryKilnBedSolution bed profile. It supports normalization of axes throught keywords normz for axial coordinate and normh for bed depth.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"Data in next example is an SI conversion of an example from Kramers and Croockewite (1952) [2].","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"julia> L = 13.715999999999998;  # Kiln length [m]\n\njulia> D = 1.8897599999999999;  # Kiln diameter [m]\n\njulia> Œ≤ = 2.3859440303888126;  # Kiln slope [¬∞]\n\njulia> Œ≥ = 45.0;                # Repose angle [¬∞]\n\njulia> d = 1.0;                 # Particle/dam size [mm]\n\njulia> Œ¶ = 10.363965852671996;  # Feed rate [m¬≥/h]\n\njulia> œâ = 3.0300000000000002;  # Rotation rate [rev/min]\n\njulia> bed = RotaryKilnBedSolution(;\n            model = SymbolicLinearKramersModel(),\n            L     = L,\n            R     = D / 2.0,\n            Œ¶     = Œ¶ / 3600.0,\n            œâ     = œâ / 60.0,\n            Œ≤     = deg2rad(Œ≤),\n            Œ≥     = deg2rad(Œ≥),\n            d     = d / 1000.0\n        );\n\njulia> bed\nRotaryKilnBedSolution(œÑ = 13.169938 min, Œ∑‚Çò = 5.913271 %)\n\njulia> bed.œÑ\n790.1963002204092","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"In the following dummy example we force a very thick analytical bed solution, filling the radius of the rotary drum. ","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"julia> R = 1.0e+00;\n\njulia> Œ¶ = 1.0e-02;\n\njulia> z = collect(0.0:0.1:10.0);\n\njulia> h = R * ones(size(z));\n\njulia> A‚Çê = œÄ * R^2 / 2;\n\njulia> V‚Çê = A‚Çê * z[end];\n\njulia> bed = RotaryKilnBedSolution(z, h, 0, R, Œ¶)\nRotaryKilnBedSolution(œÑ = 26.179939 min, Œ∑‚Çò = 50.000000 %)","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"Next we confirm the internal evaluations of the model match the expected analytical values.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"julia> mean(bed.Œ∏) ‚âà œÄ\ntrue\n\njulia> mean(bed.l) ‚âà 2R\ntrue\n\njulia> mean(bed.A) ‚âà A‚Çê\ntrue\n\njulia> mean(bed.Œ∑) ‚âà 0.5\ntrue\n\njulia> bed.Œ∑‚Çò ‚âà 50.0\ntrue\n\njulia> bed.V ‚âà V‚Çê\ntrue\n\njulia> bed.œÑ ‚âà V‚Çê / Œ¶\ntrue","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"Validation of Kramers' model is provided here.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"Finally a set of basic equations provided for process analysis.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"DryToolingGranular.sullivansŒ∑‚Çò\nDryToolingGranular.dimlessNŒ¶\nDryToolingGranular.dimlessN‚Çñ\nDryToolingGranular.perrayresidence\nDryToolingGranular.kramersnlapprox","category":"page"},{"location":"DryToolingGranular/#DryToolingGranular.sullivansŒ∑‚Çò","page":"Granular","title":"DryToolingGranular.sullivansŒ∑‚Çò","text":"Sullivans approximation to kiln filling.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingGranular/#DryToolingGranular.dimlessNŒ¶","page":"Granular","title":"DryToolingGranular.dimlessNŒ¶","text":"Kramers (1952) dimensionless group NŒ¶.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingGranular/#DryToolingGranular.dimlessN‚Çñ","page":"Granular","title":"DryToolingGranular.dimlessN‚Çñ","text":"Kramers (1952) dimensionless group N‚Çñ.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingGranular/#DryToolingGranular.perrayresidence","page":"Granular","title":"DryToolingGranular.perrayresidence","text":"Compute residence time from Peray's equation.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingGranular/#DryToolingGranular.kramersnlapprox","page":"Granular","title":"DryToolingGranular.kramersnlapprox","text":"Nonlinear formulation of Kramers model approximate solution.\n\n\n\n\n\n","category":"function"},{"location":"#DryTooling.jl","page":"Home","title":"DryTooling.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DryTooling.","category":"page"},{"location":"#Why?","page":"Home","title":"Why?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I am often faced with using the same approach for different engineering and scientific problems, but I don't like repeating the same task again and again. This is where DryTooling.jl comes in. By adopting some principles of DRY in Julia, to a larger extent than its definition, it packages together models and workflows that are not available or validated elsewhere - and in some cases adapts existing models. The tools will progressively cover a broad range of numerical applications and data treatment, this package is in its early days from the migration of my old Python scripts and packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also dry tooling is my favorite sport!","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The base case for using DryTooling is calling a pre-built model for solving a specific problem. Several sub-modules handle different Physics and find them in the side-bar. Most models are provided under structures that are already solved during construction or provide a solve! method. In an ideal world they should all be documented, but since this package is still in its early days, some experimental features are not yet documented.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For extending existing models and preferrably contributing to the package's growth, it is possible to use some functionalities provided in the bare DryTooling module, i.e. those made available when calling using DryTooling. They include physical constants, abstract types used all across the package, and some simple functions of general use.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Found it useful? See CITATION.bib for the relevant reference.","category":"page"},{"location":"Learning/#Learning-resources","page":"Learning resources","title":"Learning resources","text":"","category":"section"}]
}
