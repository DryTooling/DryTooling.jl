var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"D. J. Gunn. Transfer of heat or mass to particles in fixed and fluidised beds. International Journal of Heat and Mass Transfer 21, 467–476 (1978).\n\n\n\nH. Kramers and P. Croockewit. The passage of granular solids through inclined rotary kilns. Chemical Engineering Science 1, 259–265 (1952).\n\n\n\n","category":"page"},{"location":"DryToolingKinetics/#DryToolingKinetics","page":"Kinetics","title":"DryToolingKinetics","text":"","category":"section"},{"location":"DryToolingKinetics/","page":"Kinetics","title":"Kinetics","text":"CurrentModule = DryToolingKinetics\nDocTestSetup  = quote\n    using DryToolingKinetics\nend","category":"page"},{"location":"DryToolingCore/abstract/#Abstract-types","page":"Abstract types","title":"Abstract types","text":"","category":"section"},{"location":"DryToolingCore/abstract/#Problem-solving-and-physical-models","page":"Abstract types","title":"Problem solving and physical models","text":"","category":"section"},{"location":"DryToolingCore/abstract/","page":"Abstract types","title":"Abstract types","text":"DryToolingCore.AbstractMatrixProblem\nDryToolingCore.AbstractIterativeSolver\nDryToolingCore.AbstractSolutionStorage\nDryToolingCore.AbstractPhysicalModel","category":"page"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractMatrixProblem","page":"Abstract types","title":"DryToolingCore.AbstractMatrixProblem","text":"Base type for linear algebra problems.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractIterativeSolver","page":"Abstract types","title":"DryToolingCore.AbstractIterativeSolver","text":"Base type for (nonlinear) iterative solvers.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractSolutionStorage","page":"Abstract types","title":"DryToolingCore.AbstractSolutionStorage","text":"Base type for storing simulation solution.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractPhysicalModel","page":"Abstract types","title":"DryToolingCore.AbstractPhysicalModel","text":"Base type for physical models.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#Transport,-thermodynamics,-and-kinetics","page":"Abstract types","title":"Transport, thermodynamics, and kinetics","text":"","category":"section"},{"location":"DryToolingCore/abstract/","page":"Abstract types","title":"Abstract types","text":"DryToolingCore.AbstractTransportModel\nDryToolingCore.AbstractSolidTransport\nDryToolingCore.AbstractGasThermo\nDryToolingCore.AbstractSolidThermo\nDryToolingCore.AbstractSolidMaterial\nDryToolingCore.AbstractMixtureSubstance\nDryToolingCore.AbstractMixturePhase\nDryToolingCore.AbstractKineticsMechanism","category":"page"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractTransportModel","page":"Abstract types","title":"DryToolingCore.AbstractTransportModel","text":"Base type for transport models.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractSolidTransport","page":"Abstract types","title":"DryToolingCore.AbstractSolidTransport","text":"Base type for transport models.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractGasThermo","page":"Abstract types","title":"DryToolingCore.AbstractGasThermo","text":"Base type for thermodynamic models.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractSolidThermo","page":"Abstract types","title":"DryToolingCore.AbstractSolidThermo","text":"Base type for thermodynamic models.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractSolidMaterial","page":"Abstract types","title":"DryToolingCore.AbstractSolidMaterial","text":"Base type for solid materials.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractMixtureSubstance","page":"Abstract types","title":"DryToolingCore.AbstractMixtureSubstance","text":"Base type for simplified mixture substances.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractMixturePhase","page":"Abstract types","title":"DryToolingCore.AbstractMixturePhase","text":"Base type for simplified mixture phases.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractKineticsMechanism","page":"Abstract types","title":"DryToolingCore.AbstractKineticsMechanism","text":"Base type for coded kinetics mechanisms.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#Finite-volume-method-and-relatives","page":"Abstract types","title":"Finite volume method and relatives","text":"","category":"section"},{"location":"DryToolingCore/abstract/","page":"Abstract types","title":"Abstract types","text":"DryToolingCore.AbstractDiffusionModel1D\nDryToolingCore.AbstractGrid1D","category":"page"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractDiffusionModel1D","page":"Abstract types","title":"DryToolingCore.AbstractDiffusionModel1D","text":"Base type for diffusion (heat, species, ...) models.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingCore/abstract/#DryToolingCore.AbstractGrid1D","page":"Abstract types","title":"DryToolingCore.AbstractGrid1D","text":"Base type of one-dimensional grids.\n\n\n\n\n\n","category":"type"},{"location":"Learning/TransportPhenomena/002-advection-1d/#More-advection...","page":"More advection...","title":"More advection...","text":"","category":"section"},{"location":"Learning/TransportPhenomena/002-advection-1d/#Courant-Friedrichs-Lewy-criterium","page":"More advection...","title":"Courant-Friedrichs-Lewy criterium","text":"","category":"section"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"The previous examples and proposed exercises have shown that the explicit numerical scheme that was introduced does not lead to a correct problem solution no matter the choice of number of time steps and nodes. In fact, we have discussed the idea that these are actually mutually dependent and provided a tip regarding the origin of the Courant number alpha. In order to ensure the stability of this explicit scheme, we apply the Courant–Friedrichs–Lewy (CFL) condition which states that:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\alpha = c \\frac{\\tau}{\\delta} \\le \\alpha_{crit} $","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Here the value of alpha_crit changes with the integration method. Before proceeding with the numerical analysis, let's start again with some numerical experimentation. To do so we will conceive a few methods for automating multiple solutions of linear advection equation with different discretization levels. The idea is to have the possibility to solve a Courant number constrained problem as well as a free discretization. The first step is to conceive a method compute_cfl which will discretize space as provided by the user, then compute time step in a CFL-constrained way it the number to time steps is not provided, or simply discretize time with a user-defined number of steps.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"function compute_cfl(T, L, c, nₓ, nₜ)\n    δ = L / (nₓ - 1);\n    x = collect(0.0u\"m\":δ:L);\n    \n    if !isnothing(nₜ)\n        τ = T / (nₜ - 1)\n        α = c * τ / δ\n    else\n        τ = δ / c\n        nₜ = convert(Int, floor(T / τ)) + 1\n        α  = 1.0\n    end\n    \n    return α, nₜ, τ, x\nend","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Below we test the method with the inputs inherited from previous examples. The underscore in front of returned values is a reminder that these parameters are to be discarded in what follows.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"_α, _nₜ, _τ, _x = compute_cfl(T, L, c, nₓ, nₜ)\n_α, _nₜ, _τ","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"If the number of time steps is not provided with a nothing instead of an integer, the method performs the CFL-constrained discretization a wished.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"_α, _nₜ, _τ, _x = compute_cfl(T, L, c, nₓ, nothing);\n_α, _nₜ, _τ","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Now we put together everything we learned about the solution of advection equation in a single method linear_advection_explicit which will ingest our space and time domain, fluid velocity, wave parameters, and discretization, to then output the solution with respective space and time axes.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"function linear_advection_explicit(T, L, c, xᵤ, u₀, nₓ, nₜ)\n    # Compute time-stepping parameters as required.\n    α, nₜ, τ, x = compute_cfl(T, L, c, nₓ, nₜ);\n    \n    # Create time points iterator (no need to collect).\n    t = 0u\"s\":τ:(nₜ-1)*τ;\n    \n    # Create wave compatible with space discretization.\n    mask = ((xᵤ[1] .< x) .& (x .< xᵤ[2]));\n    u = u₀ * ones(Float64, (length(x), 1));\n    u[.~mask] .= 0.5 .* u₀;\n    \n    # Allocate memory for solution.\n    solution = 0u\"m/s\" * zeros(Float64, (nₜ, nₓ));\n    \n    # Time integration loop.\n    for (k, _) in enumerate(t)\n        solution[k, :] = copy(u);\n        u[2:end] = (1 - α) * u[2:end] + α * u[1:end-1];\n    end\n    \n    return x, collect(t), solution, α\nend","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Before going further we test it is working as expected.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"x, t, solution = linear_advection_explicit(T, L, c, xᵤ, u₀, nₓ, nₜ);\nkymograph_advection(solution)","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"To perform an automated numerical experiment we put it all together in scan_advection. This method will receive everything to setup the problem as provided above, but instead of a single space discretization, it takes a range of number of nodes. This way it will be able to show us the role of nodal length over the accuracy of the solution. It also takes an optional number of time steps, which will be useful for testing the CFL-bounded integration.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"function scan_advection(T, L, c, xᵤ, u₀, min_nₓ, max_nₓ, dnₓ;\n                        nₜ=nothing, boundy=true)\n    p = plot();\n    \n    for (k, nₓ) in enumerate(min_nₓ:dnₓ:max_nₓ)\n        x, t, solution, α = linear_advection_explicit(T, L, c, xᵤ, u₀, nₓ, nₜ);\n        uₖ = ustrip(solution[end, :]);\n        \n        sα = @sprintf(\"%.2f\", α);\n        st = @sprintf(\"%.2f\", ustrip(t[end]));\n        label = \"nₓ = $(nₓ) / α = $(sα) / T = $(st)\";\n        plot!(p, x, uₖ, label=label, linewidth=2);\n    end\n\n    # Get initial state from the fine-grid solution.\n    uᵢ = ustrip(solution[1, :]);\n    plot!(p, x, uᵢ, label=\"Initial state\", linewidth=2);\n    \n    xlabel!(p, \"Coordinate, \\$\\\\mathrm{m}\\$\");\n    ylabel!(p, \"Velocity, \\$\\\\mathrm{m.s^{-1}}\\$\");\n    \n    if boundy\n        ylims!(p, 0.5, 1.0);\n    end\n\n    return p;\nend","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"The following examples were integrated for a shorter physical time to allow faster and didactic computations when scanning over different number of nodes in space domain.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"T = 0.66u\"s\";","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Now we discretize the spacial axis with different number of nodes in the range 4070. As you may observe in the figure below, numerical diffusion decreases for larger n_x, as it was expected from previous discussion. The number of time points is held constant here and equal to 24. Solution seems to better preserve wave shape when alpha approaches unity.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"scan_advection(T, L, c, xᵤ, u₀, 40, 70, 15; nₜ=24)","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Next we increase the upper limit of the number of space nodes n_x to 85, while keeping n_t as before. Apparently the solution exploses. If we check the value of alpha, for 85 nodes it has reached 1.21.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"scan_advection(T, L, c, xᵤ, u₀, 40, 85, 15; nₜ=24, boundy=false)","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Following the observations made on the first trial, we can increase n_t to force alphale1. Apparently we identified empirically the critical value of CFL for this problem integration method. What happens if you further increase n_t, and why does it happen?","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"scan_advection(T, L, c, xᵤ, u₀, 40, 85, 15; nₜ=29)","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/#A-(not-so)-formal-stability-analysis","page":"More advection...","title":"A (not so) formal stability analysis","text":"","category":"section"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"One important question that arrises when solving PDE's numerically is whether the system is stable, i.e. if the numerical solution remains bounded as time-step goes to zero. That means that perturbations such as the rounding error do not increase in time. There are no general methods for perform such analysis and one gets restricted to linear problems. The standard method for this was proposed by John von Neumann, who proposes to use Fourier series to represent the rounding error. Notice that this implies periodic boundary conditions, otherwise these need to be artificially introducted to the problem in order to be tractable.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Suppose the numerical scheme used for integration can be represented by a nonlinear operator mathcalJ, allowing for the progression in time as:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"u^{n+1}=\\mathcal{J}[u^{n}] $","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"This operator will produce a sequence of values u(t_n)=u^0u^1u^2u^n Since the numerical scheme is only an approximation, each step introduces a small cummulative error such that this sequence is in fact u^0+varepsilon^0u^1+varepsilon^1u^2+varepsilon^2u^n+varepsilon^n, what can be represented by:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"u^{n+1}+\\varepsilon^{n+1}=\\mathcal{J}(u^{n}+\\varepsilon^{n}) $","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Assuming the Taylor series expansion of mathcalJ is possible, after linearization we can express the amplification of the error as the next expression, known as the error propagation law. Matrix G is called the amplification matrix. We promptly identify that this is an eigenvalue problem.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\varepsilon^{n+1}=\\frac{\\partial{}\\mathcal{J}(u^{n})}{\\partial{}u^{n}}\\varepsilon^{n}=G\\varepsilon^{n} $","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"The numerical stability of the system depends on the eigenvalues g_mu of G. In order that the error remains bounded, the following condition is required for stability:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\vert{}g_{\\mu}\\vert\\le{}1\\qquad\\forall\\mu $","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"In general the solution of a PDE will be represented by u(t_nx_p)equivu^n_p (notice the change of the subscript used for position here to avoid confusion with the imaginary unit i and the wave-number k that will be used later). The error propagation at one node p is coupled to every other node q by means of the Jacobian matrix element G_pq, what is expressed by:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\varepsilon^{n+1}{p}=\\sum{q}G{pq}\\varepsilon^{n}{q} \\qquad\\text{where}\\qquad G{pq}=\\frac{\\partial{}\\mathcal{J}(u^{n}{p})}{\\partial{}u^{n}_{q}} $","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"The error varepsilon^n_p can be expanded as a Fourier series of wavenumbes k over the problem domain. Since the cummulative error must decay or grow exponentially in time, we can assume that the Fourier coefficients hatvarepsilon^n(k) vary as exp(omegat_n), where the frequency omega is a constant.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\varepsilon^{n}{p}=\\sum{k}\\hat{\\varepsilon}^{n}(k)\\exp{(ikx{p})}=\\sum{k}\\exp{(\\omega{}t{n})}\\exp{(ikx{p})} $","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"It is important to notice that the functions exp(ikx_p) are eigenfunctions of G, so the last expression can be interpreted as an expansion of eigenfunctions og G. Furthermore, since the equation for the error is linear, it is enough to study the growth of an arbitrary element in the sum, such as \\varepsilon^{n}{p}=\\exp{(\\omega{}t{n})}\\exp{(ikx_{p})} $. From this we have:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\varepsilon^{n+1}{p}=g(k)\\varepsilon^{n}{p} $","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"As such, one can take the exp(ikx_p) as an eigenvector corresponding to eigenvalue g(k), which is known as the amplification factor. The von Neumann stability criterium is then:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\vert{}g(k)\\vert\\le{}1\\qquad\\forall{}k $","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/#Application-to-1-D-convection","page":"More advection...","title":"Application to 1-D convection","text":"","category":"section"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"To start with, at an arbitrary point p in the grid we inject the corresponding error propagation term hatvarepsilon^n(k)exp(ikpDeltax) at the correct time instant. Notice here that we made x_p=pDeltax for allowing proper manipulation in what follows. Using the upwind explicit scheme we are dealing with one produces:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\hat{\\varepsilon}^{n+1}(k)\\exp{(ikp\\Delta{}x)}= \\hat{\\varepsilon}^{n}(k)\\exp{(ikp\\Delta{}x)}- \\alpha\\left[     \\hat{\\varepsilon}^{n}(k)\\exp{(ikp\\Delta{}x)}-     \\hat{\\varepsilon}^{n}(k)\\exp{(ik(p-1)\\Delta{}x)} \\right] $","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"The error amplification factor g(k) can then be identified by simultaneously dividing the previous expression by hatvarepsilon^n(k)exp(ikpDeltax). Notice that this expression is independent of the position p and thus remains valid for the whole domain.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"g(k)=\\frac{\\hat{\\varepsilon}^{n+1}(k)}{\\hat{\\varepsilon}^{n}(k)}= 1-\\alpha+\\alpha\\exp{(-ik\\Delta{}x)} $","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"In order to respect von Neumann stability condition for all k we need 1-alphale0, what provides the value of alpha_crit=1 that we previously identified through our numerical experiments. Thus, we say the upwind explicit scheme for 1-D convection is conditionally stable, i.e the physical velocity c must not be bigger than the numerical spreading velocity fracDeltaxDeltat.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"By not providing the number of time steps in our scanning model forces CFL criterium to be respected for all number of nodes in space, as expected from the previous analysis. In this case, we cannot ensure that the time step required to respect CFL will produce an integer number of steps to reach exactly the time position we wish the calculation to terminate at. In another moment we will deal with this.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"scan_advection(T, L, c, xᵤ, u₀, 40, 85, 15)","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/#Courant-Friedrichs-Lewy-criterium-2","page":"More advection...","title":"Courant-Friedrichs-Lewy criterium","text":"","category":"section"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"The previous examples and proposed exercises have shown that the explicit numerical scheme that was introduced does not lead to a correct problem solution no matter the choice of number of time steps and nodes. In fact, we have discussed the idea that these are actually mutually dependent and provided a tip regarding the origin of the Courant number alpha. In order to ensure the stability of this explicit scheme, we apply the Courant–Friedrichs–Lewy (CFL) condition which states that:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\alpha = c \\frac{\\tau}{\\delta} \\le \\alpha_{crit}","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Here the value of alpha_crit changes with the integration method. Before proceeding with the numerical analysis, let's start again with some numerical experimentation. To do so we will conceive a few methods for automating multiple solutions of linear advection equation with different discretization levels. The idea is to have the possibility to solve a Courant number constrained problem as well as a free discretization. The first step is to conceive a method compute_cfl which will discretize space as provided by the user, then compute time step in a CFL-constrained way it the number to time steps is not provided, or simply discretize time with a user-defined number of steps.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Below we test the method with the inputs inherited from previous examples. The underscore in front of returned values is a reminder that these parameters are to be discarded in what follows.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"If the number of time steps is not provided with a nothing instead of an integer, the method performs the CFL-constrained discretization a wished.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Now we put together everything we learned about the solution of advection equation in a single method linear_advection_explicit which will ingest our space and time domain, fluid velocity, wave parameters, and discretization, to then output the solution with respective space and time axes.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Before going further we test it is working as expected.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"To perform an automated numerical experiment we put it all together in scan_advection. This method will receive everything to setup the problem as provided above, but instead of a single space discretization, it takes a range of number of nodes. This way it will be able to show us the role of nodal length over the accuracy of the solution. It also takes an optional number of time steps, which will be useful for testing the CFL-bounded integration.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"The following examples were integrated for a shorter physical time to allow faster and didactic computations when scanning over different number of nodes in space domain.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Now we discretize the spacial axis with different number of nodes in the range 4070. As you may observe in the figure below, numerical diffusion decreases for larger n_x, as it was expected from previous discussion. The number of time points is held constant here and equal to 24. Solution seems to better preserve wave shape when alpha approaches unity.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Next we increase the upper limit of the number of space nodes n_x to 85, while keeping n_t as before. Apparently the solution exploses. If we check the value of alpha, for 85 nodes it has reached 1.21.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Following the observations made on the first trial, we can increase n_t to force alphale1. Apparently we identified empirically the critical value of CFL for this problem integration method. What happens if you further increase n_t, and why does it happen?","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/#A-(not-so)-formal-stability-analysis-2","page":"More advection...","title":"A (not so) formal stability analysis","text":"","category":"section"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"One important question that arrises when solving PDE's numerically is whether the system is stable, i.e. if the numerical solution remains bounded as time-step goes to zero. That means that perturbations such as the rounding error do not increase in time. There are no general methods for perform such analysis and one gets restricted to linear problems. The standard method for this was proposed by John von Neumann, who proposes to use Fourier series to represent the rounding error. Notice that this implies periodic boundary conditions, otherwise these need to be artificially introducted to the problem in order to be tractable.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Suppose the numerical scheme used for integration can be represented by a nonlinear operator mathcalJ, allowing for the progression in time as:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"u^{n+1}=\\mathcal{J}[u^{n}]","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"This operator will produce a sequence of values u(t_n)=u^0u^1u^2u^n Since the numerical scheme is only an approximation, each step introduces a small cummulative error such that this sequence is in fact u^0+varepsilon^0u^1+varepsilon^1u^2+varepsilon^2u^n+varepsilon^n, what can be represented by:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"u^{n+1}+\\varepsilon^{n+1}=\\mathcal{J}(u^{n}+\\varepsilon^{n})","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"Assuming the Taylor series expansion of mathcalJ is possible, after linearization we can express the amplification of the error as the next expression, known as the error propagation law. Matrix G is called the amplification matrix. We promptly identify that this is an eigenvalue problem.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\varepsilon^{n+1}=\\frac{\\partial{}\\mathcal{J}(u^{n})}{\\partial{}u^{n}}\\varepsilon^{n}=G\\varepsilon^{n}","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"The numerical stability of the system depends on the eigenvalues g_mu of G. In order that the error remains bounded, the following condition is required for stability:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\vert{}g_{\\mu}\\vert\\le{}1\\qquad\\forall\\mu","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"In general the solution of a PDE will be represented by u(t_nx_p)equivu^n_p (notice the change of the subscript used for position here to avoid confusion with the imaginary unit i and the wave-number k that will be used later). The error propagation at one node p is coupled to every other node q by means of the Jacobian matrix element G_pq, what is expressed by:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\varepsilon^{n+1}_{p}=\\sum_{q}G_{pq}\\varepsilon^{n}_{q}\n\\qquad\\text{where}\\qquad\nG_{pq}=\\frac{\\partial{}\\mathcal{J}(u^{n}_{p})}{\\partial{}u^{n}_{q}}","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"The error varepsilon^n_p can be expanded as a Fourier series of wavenumbes k over the problem domain. Since the cummulative error must decay or grow exponentially in time, we can assume that the Fourier coefficients hatvarepsilon^n(k) vary as exp(omegat_n), where the frequency omega is a constant.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\varepsilon^{n}_{p}=\\sum_{k}\\hat{\\varepsilon}^{n}(k)\\exp{(ikx_{p})}=\\sum_{k}\\exp{(\\omega{}t_{n})}\\exp{(ikx_{p})}","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"It is important to notice that the functions exp(ikx_p) are eigenfunctions of G, so the last expression can be interpreted as an expansion of eigenfunctions og G. Furthermore, since the equation for the error is linear, it is enough to study the growth of an arbitrary element in the sum, such as \\varepsilon^{n}{p}=\\exp{(\\omega{}t{n})}\\exp{(ikx_{p})} $. From this we have:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\varepsilon^{n+1}_{p}=g(k)\\varepsilon^{n}_{p}","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"As such, one can take the exp(ikx_p) as an eigenvector corresponding to eigenvalue g(k), which is known as the amplification factor. The von Neumann stability criterium is then:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\vert{}g(k)\\vert\\le{}1\\qquad\\forall{}k","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/#Application-to-1-D-convection-2","page":"More advection...","title":"Application to 1-D convection","text":"","category":"section"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"To start with, at an arbitrary point p in the grid we inject the corresponding error propagation term hatvarepsilon^n(k)exp(ikpDeltax) at the correct time instant. Notice here that we made x_p=pDeltax for allowing proper manipulation in what follows. Using the upwind explicit scheme we are dealing with one produces:","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"\\hat{\\varepsilon}^{n+1}(k)\\exp{(ikp\\Delta{}x)}=\n\\hat{\\varepsilon}^{n}(k)\\exp{(ikp\\Delta{}x)}-\n\\alpha\\left[\n    \\hat{\\varepsilon}^{n}(k)\\exp{(ikp\\Delta{}x)}-\n    \\hat{\\varepsilon}^{n}(k)\\exp{(ik(p-1)\\Delta{}x)}\n\\right]","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"The error amplification factor g(k) can then be identified by simultaneously dividing the previous expression by hatvarepsilon^n(k)exp(ikpDeltax). Notice that this expression is independent of the position p and thus remains valid for the whole domain.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"g(k)=\\frac{\\hat{\\varepsilon}^{n+1}(k)}{\\hat{\\varepsilon}^{n}(k)}=\n1-\\alpha+\\alpha\\exp{(-ik\\Delta{}x)}","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"In order to respect von Neumann stability condition for all k we need 1-alphale0, what provides the value of alpha_crit=1 that we previously identified through our numerical experiments. Thus, we say the upwind explicit scheme for 1-D convection is conditionally stable, i.e the physical velocity c must not be bigger than the numerical spreading velocity fracDeltaxDeltat.","category":"page"},{"location":"Learning/TransportPhenomena/002-advection-1d/","page":"More advection...","title":"More advection...","text":"By not providing the number of time steps in our scanning model forces CFL criterium to be respected for all number of nodes in space, as expected from the previous analysis. In this case, we cannot ensure that the time step required to respect CFL will produce an integer number of steps to reach exactly the time position we wish the calculation to terminate at. In another moment we will deal with this.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Diffusion-in-1-D-with-finite-difference-method","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"using Plots;\n# using Printf;\n# using Unitful;","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Introduction-to-diffusion-(Part-A)","page":"Diffusion in 1-D with finite difference method","title":"Introduction to diffusion (Part A)","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Diffusion-equation-1-D-with-finite-differences","page":"Diffusion in 1-D with finite difference method","title":"Diffusion equation 1-D with finite differences","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Diffusion is a process that arises when a flow of a given quantity is induced by a gradient of its content, what is a direct response to second law of Thermodynamics. Under such circunstances, we often denote the flux vector vecJ of quantity u as given in the following equation, where nu is a transport coefficient. This empirical relationship has been shown to hold under several cases, constituting what is called Fourier's law in heat transfer and Fick's first law in mass transfer.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\vec{J}=-\\nu{}\\nabla{}u","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"In this notebook we introduce the 1-D case of diffusion equation, thus the gradient is replaced by the derivative of u over x axis. To compute the time evolution of u in a point of space in the absence of a source term, one simply aply the divergent operator (special case of Reynolds transport theorem without source) over the flux above which can be interpreted as","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"<center> <bold>[ Inlet ] - [ Outlet ] + [ Creation == 0 ] = [ Accumulation rate ]</bold> </center>","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Applying this to the case where the creation rate is null (no source term) is equivalent to take the divergent of the flux. In the case the transport coefficient depends on position or in the transported quantity itself, this leads to the following nonlinear form of the diffusion equation, which we will study later in this notebook series:","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\frac{\\partial u}{\\partial t}=\\frac{\\partial{}}{\\partial{}x}\\left[\\nu(x, u)\\frac{\\partial{}u}{\\partial{}x}\\right]","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"For the case of constant transport coefficient nu, we finally get the expression that we study here:","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\frac{\\partial u}{\\partial t}= \\nu \\frac{\\partial^2{}u}{\\partial{}x^2}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Second-derivative-computation","page":"Diffusion in 1-D with finite difference method","title":"Second derivative computation","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"A second derivative of a function requires more information than the first one, since it represents the rate of change of a derivative. As a first strategy to compute the right-hand side of diffusion equation, let's take the Taylor series expansion of function u around a given element u_i. We use this to produce both the next and previous elements in 1-D space, u_i+1 and u_i-1","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"u_{i+1} = u_i + \\Delta x \\frac{\\partial u}{\\partial x}\\bigg|_i + \\frac{\\Delta x^2}{2} \\frac{\\partial ^2 u}{\\partial x^2}\\bigg|_i + \\frac{\\Delta x^3}{3!} \\frac{\\partial ^3 u}{\\partial x^3}\\bigg|_i + O(\\Delta x^4)","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"u_{i-1} = u_i - \\Delta x \\frac{\\partial u}{\\partial x}\\bigg|_i + \\frac{\\Delta x^2}{2} \\frac{\\partial ^2 u}{\\partial x^2}\\bigg|_i - \\frac{\\Delta x^3}{3!} \\frac{\\partial ^3 u}{\\partial x^3}\\bigg|_i + O(\\Delta x^4)","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"As you may notice in the equations above, the sign of odd terms cancel. Adding up these expressions is a straighforward means of getting only even terms in the series, thus the second derivative.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"u_{i+1} + u_{i-1} = 2u_i+\\Delta x^2 \\frac{\\partial ^2 u}{\\partial x^2}\\bigg|_i + O(\\Delta x^4)","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"After manipulation for isolating the second derivative one produces the second order accurate scheme:","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\frac{\\partial ^2 u_{i}}{\\partial x^2}=\\frac{u_{i+1}-2u_{i}+u_{i-1}}{\\Delta x^2} + O(\\Delta x^2)","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Explicit-formulation","page":"Diffusion in 1-D with finite difference method","title":"Explicit formulation","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"In the previous notebooks we have established the convention of using a superscript to denote the discrete time index. Computing the right-hand side of the diffusion equation at instant n to predict n+1 produces the explicit formulation. For brevity we start using tau=Deltat and delta=Deltax.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\frac{u_{i}^{n+1}-u_{i}^{n}}{\\tau}=\\nu\\frac{u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n}}{\\delta^2}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Again, as we have done for the convection equation, u^n+1 can be promptly solved from u^n at all positions:","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"u_{i}^{n+1}=u_{i}^{n}+\\frac{\\nu\\tau}{\\delta^2}(u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n})=\n(1-2\\alpha)u_{i}^{n}+\\alpha(u_{i+1}^{n}+u_{i-1}^{n})\n\\qquad\\text{where}\\qquad{}\\alpha=\\frac{\\nu{}\\tau{}}{\\delta^2}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Stability-analysis","page":"Diffusion in 1-D with finite difference method","title":"Stability analysis","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"As we have seen in last notebook, the stability criterium for a formulation can be established through von Neumann analysis. To do so, we make use of the error scaling factors hatvarepsilon^n(k)exp(ikpDeltax) as a replacement of every u in the above equation. Remember that for compatibility with imaginary unity, subindices were replaced by p here, and the good value of p must be used for each term. After manipulation we retrieve the amplification factor g(k) that is independent of the position (try doing the full demonstration):","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"g(k)=(1-2\\alpha) + \\alpha[\\exp(ik\\delta)+\\exp(-ik\\delta)] $","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"The right-hand side can be simplified through Euler's formula exp(pmix)=cos(x)pmisin(x). This leads to elimination of the sinuses from the equation, which now can be simplified as:","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"g(k)=1+2\\alpha\\left[\\cos(ik\\delta)-1\\right] $","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Stability is assured when vertg(k)vertle1 for any k. It can be shown (it is left for the reader to demonstrate), that this is possible for alphalefrac12. From now on we consider the derived criterium for the coding activities.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Sample-case","page":"Diffusion in 1-D with finite difference method","title":"Sample case","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"As we did when studying convection for the first time, our sample case will be started witn a hump in the middle of the domain, as per the statement below. The most important difference that is emphasized from now on is that since we are aware of stability criterium, time-step will be chosen to respect it. The code is provided with a flag for override the bounding of time-step allowing to investigate the effect of unstable regions of alpha. In all cases, unity diffusion coefficient nu=1 will be employed for simplicity.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{cases} u=1 & x\\in[0.75;\\, 1.25]\\\nu=0 & \\text{elsewhere} \\end{cases} $","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"The next function provides the integration of the problem with the previously defined numerical scheme using NumPy array slicing to allow the computation of derivative in all internal domain elements. Notice that until the present we have not yet discussed boundary conditions and the next example is equivalent to a constant value over boundaries (Dirichlet condition, as we will see later in the series).","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"def problem_diffusion_linear(u, dx, t_end, alpha_max):\n    \"\"\" Explicit solution of 1-D diffusion problem.\n    \n    Parameters\n    ----------\n    u : np.ndarray\n        Array quantity over 1-D grid of step `dx`.\n    dx : float\n        Grid spacing in 1-D domain.\n    t_end : float\n        Final integration time.\n    alpha_max : float\n        Value of alpha for initial time-step calculation.\n        \n    Returns\n    -------\n    np.ndarray\n        Solution array with quantity `u` at `t_end`.\n    \"\"\"\n    # Constant diffusion coefficient.\n    nu = 1.0\n    \n    # Compute dx**2 only once.\n    dx2 = dx ** 2\n\n    # Maximum stable time-step.\n    dt = alpha_max * dx2 / nu\n    \n    # Initialize time.\n    t = 0.0\n\n    # Time loop until end.\n    while t < t_end:\n        # Bound time step for ending.\n        dt = min(dt, t_end - t)\n        \n        # Increase solution time.\n        t += dt \n\n        # Compute explicity solution\n        alpha = nu * dt / dx2\n        u[1:-1] += alpha * (u[2:] - 2.0 * u[1:-1] + u[:-2])\n        \n        if abs(t - t_end) <= 1.0e-08:\n            return u","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"For allowing multiple calculations with same initial condition but different grids, we provide a simple function for allocation and computation of initial conditions and space discretization. This function will be used as a parameter of our simulation study, so different cases can be investigated.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"def get_initial_conditions_sample1(nx):\n    \"\"\" Allocate x, u, and set initial state. \"\"\"\n    x, dx = np.linspace(0.0, 2.0, nx, retstep=True)\n    u = np.zeros(nx, dtype=np.float64)\n    u[((x >= 0.75) & (x <= 1.25))] = 1.0\n    return x, u, dx","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Finally we wrap the problem in a function to study the effect of alpha and integration time for a given fixed set of number of nodes in space. This function creates a plot of initial state and results for reference.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"def simulate_for_alpha(alpha, initialize, t_end=1.0e-03, bound_alpha=True):\n    \"\"\" Simulate problem for a given `alpha`.\n    \n    Parameters\n    ----------\n    alpha : float\n        Critical value of `alpha` to use in calculation.\n    t_end : float\n        Final integration time for studying effect of boundaries.\n    bound_alpha : bool\n        If `True`, ensure stability criterium.\n    \"\"\"\n    plt.close('all')\n    plt.style.use('bmh')\n    plt.figure(figsize=(8, 4), dpi=100)\n\n    if bound_alpha:\n        alpha = min(alpha, 0.5)\n    \n    x, u, _ = initialize(5000)\n    plt.plot(x, u, drawstyle='steps', label=F'Initial')\n\n    t0 = perf_counter()\n    for nx in [20, 200, 2000]:\n        x, u, dx = initialize(nx)\n        u = problem_diffusion_linear(u, dx, t_end, alpha)\n        plt.plot(x, u, drawstyle='steps', label=F'nx={nx}')\n\n    delay = perf_counter() - t0\n    title = F'All simulations took {delay:.2f} s'\n    \n    plt.title(title)\n    plt.xlabel('Position [m]')\n    plt.ylabel('Quantity [a.u.]')\n    plt.xlim(0.0, 2.0)\n    plt.legend()}\n    plt.tight_layout()","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"In the next cell we present the solution for the critical value of alpha that has been found in von Neumann stability analysis.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"simulate_for_alpha(0.5, get_initial_conditions_sample1)","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"As you observe in the plot above, with 2000 nodes in grid a pretty smooth solution starts to be produced with the given conditions. For 20 nodes, the problem is not even centered because of the placement of initial state in that case.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"The next cells are an invitation for you to experiment with different parameters in the simulation. Take care with t_end as it can be pretty long to compute the solution with 2000 nodes in the grid.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"# simulate_for_alpha(1.0, get_initial_conditions_sample1, bound_alpha=False)","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"# simulate_for_alpha(0.5, get_initial_conditions_sample1, t_end=1.0e-01)","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"What if we have multiple humps (see them as particles being dissolved) in the system? Well, check below! This is a pretty common application case of diffusion in solid state and stationary liquids that is worth understanding.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"def get_initial_conditions_sample2(nx):\n    \"\"\" Allocate x, u, and set initial state. \"\"\"\n    x, dx = np.linspace(0.0, 2.0, nx, retstep=True)\n    u = np.zeros(nx, dtype=np.float64)\n    u[((x >= 0.20) & (x <= 0.40))] = 2.0\n    u[((x >= 0.70) & (x <= 1.00))] = 1.0\n    u[((x >= 1.50) & (x <= 1.60))] = 3.0\n    return x, u, dx","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"simulate_for_alpha(0.5, get_initial_conditions_sample2, t_end=5.0e-03)","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"+++","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Introduction-to-diffusion-(Part-B)","page":"Diffusion in 1-D with finite difference method","title":"Introduction to diffusion (Part B)","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Introduction-to-implicit-formulations","page":"Diffusion in 1-D with finite difference method","title":"Introduction to implicit formulations","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Contrary to the explicit formulation, in the implicit case we compute the spacial derivatives in instant n+1. In this case simple algebraic solution is no longer possible, as we show in what follows. Replacing n by n+1 in the superscripts on the right-hand side of the explicit formulation produces the implicit scheme. In fact, any of the previous models could have been treated this way. The main advantage of implicit schemes is the stability, as it will be shown later.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\frac{u_{i}^{n+1}-u_{i}^{n}}{\\tau}=\\nu\\frac{u_{i+1}^{n+1}-2u_{i}^{n+1}+u_{i-1}^{n+1}}{\\delta^2}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"After manipulating the above expression to split the different instants at different sides of the equation we produce the next expression. Observe the linear coupling of different elements at n+1: we have a linear system of equations instead of single algebraic equations and the solution of the system is required for advancing the integration in time.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"-\\alpha{}u{i-1}^{n+1} + (1 + 2\\alpha) u{i}^{n+1} - \\alpha{}u{i+1}^{n+1}=u{i}^{n} \\qquad\\text{where}\\qquad{}\\alpha=\\frac{\\nu{}\\tau{}}{\\delta^2} $","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"This expression holds for all elements in the interior of 1-D space. Boundary elements deserve special treatment as we will see in what follows (e.g. at position i=0, does index i-1=-1 make sense? You are outside the domain!). In matrix form the above equation produces the following tridiagonal linear system (boundary terms not yet implemented):","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{bmatrix}~1+2\\alpha& -\\alpha& ~0& ~0& ~0& \\ldots &~0\\[2pt] -\\alpha&~1+2\\alpha&-\\alpha&~0&~0&\\ldots &~0\\[2pt] ~0&-\\alpha&~1+2\\alpha&-\\alpha&~0&\\ldots &~0\\[2pt] \\vdots &\\vdots &\\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\[2pt] ~0&\\ldots &~0&-\\alpha&~1+2\\alpha&-\\alpha&~0\\[2pt] ~0&\\ldots &\\ldots &~0&-\\alpha&~1+2\\alpha&-\\alpha\\[2pt] ~0&\\ldots &\\ldots &\\ldots &~0&-\\alpha&~1+2\\alpha\\end{bmatrix}\\cdotp\\begin{bmatrix}u^{n+1}{0}   \\[2pt]u^{n+1}{1}   \\[2pt] u^{n+1}{2}   \\[2pt] \\vdots        \\[2pt] u^{n+1}{N-3} \\[2pt] u^{n+1}{N-2} \\[2pt] u^{n+1}{N-1} \\[2pt] \\end{bmatrix} = \\begin{bmatrix} u^{n}{0}   \\[2pt] u^{n}{1}   \\[2pt] u^{n}{2}   \\[2pt] \\vdots      \\[2pt] u^{n}{N-3} \\[2pt] u^{n}{N-2} \\[2pt] u^{n}{N-1} \\[2pt]\\end{bmatrix} $","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"So finally we have that the solution of the implicit formulation using matrix boldface notation can be done as follows:","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\mathbf{M}\\cdotp\\mathbf{u}^{n+1}=\\mathbf{u}^{n}\\implies{}\n\\mathbf{u}^{n+1}=\\mathbf{M}^ {-1}\\mathbf{u}^{n}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Stability-analysis-2","page":"Diffusion in 1-D with finite difference method","title":"Stability analysis","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Following the same steps from Part A of this chapter, i.e. replacing each u^m_p=hatvarepsilon^m(k)exp(ikpDeltax) with proper m and p replacement, we find the error amplification factor g(k), which for the implicit scheme takes the form:","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"g(k)=\\frac{1}{1-2\\alpha\\left[cos(k\\Delta{}x)-1\\right]}=\n\\frac{1}{1+4\\alpha\\sin^{2}(k\\Delta{}x)}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"The value of sin^2(kDeltax)ge0impliesvertg(x)vertle1, what implies that the implicit scheme is unconditionally stable, meaning that any combination of time and space steps will lead to a finite error. Nonetheless, this does not mean the values are accurate, since the truncation error is the same as the explicit scheme, leading to a first-order accuracy in x.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Boundary-conditions","page":"Diffusion in 1-D with finite difference method","title":"Boundary conditions","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"We have delayed the derivation of boundary conditions to this point. This is because now we have already seen different equations and the difference of explicit and implicit schemes. Now we concentrate of how to ensure the PDE boundary conditions as required by a real-world problem. For an explicit scheme this can be as trivial as not solving the equation for the first and last element to keep them constant, what would constitue a Dirichlet boundary condition. For implicit schemes, the derivation is far more complex, and include modifications in the coefficient matrix mathbfM and to the right-hand side.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Dirichlet: this type of boundary condition is characterized by the time-constancy of the boundary node, using dot notation for time-derivative dotuvert_x=0=0foralltinRe. That means that the left hand side of diffusion equation is to be held constant at that position. In order to derive this condition, one may write the first equation of the system as follows, where index i=-1 is a ghost node, a purely numerical feature used to help the derivation of the boundary condition.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"-\\alpha{}u^{n+1}_{-1}+(1+2\\alpha)u^{n+1}_{0}-\\alpha{}u^{n+1}_{1}=u^{n}_{0}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Holding this ghost node constant and equal to the boundary value u_b, the first equation of the problem is then writen as (1+2alpha)u^n+1_0-alphau^n+1_1=u^n_0+alphau_b. As such, the matrix form of the problem is modified to mathbfu^n+1=mathbfM^ -1left(mathbfu^n+mathbfu_bright).","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Neumann: also known as the specified flux condition, is given by nuu^primevert_x=0=h, where we use a prime notation for derivatives in space. We seek now a ghost element ensuring the respect of the flux over u_0. One alternative is to take a centered derivative around this node to represent the boundary condition.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\nu\\frac{u_{1}-u_{-1}}{2\\delta}=h\\qquad\\implies\\qquad{}\nu_{-1}=u_{1}+\\frac{2\\delta{}h}{\\nu}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Using this expression in the generic form of the numerical scheme provides us with the first row of our matrix. Notice here that for Neumann boundary condition not only a term is added to the right-hand side of the problem, but also modified one matrix element associated to u_1.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"(1+2\\alpha)u^{n+1}_{0}-2\\alpha{}u^{n+1}_{1}=u^{n}_{0}+2\\alpha\\delta{}h\\nu^{-1}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Following we visualize the full final matrix form for this boundary condition.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{bmatrix} ~1+2\\alpha& -2\\alpha& ~0& ~0& ~0& \\ldots &~0\\[2pt]  -\\alpha&~1+2\\alpha&-\\alpha&~0&~0&\\ldots &~0\\[2pt] ~0&-\\alpha&~1+2\\alpha&-\\alpha&~0&\\ldots &~0\\[2pt]  \\vdots &\\vdots &\\vdots &\\vdots &\\vdots &\\ddots &\\vdots \\[2pt]  ~0&\\ldots &~0&-\\alpha&~1+2\\alpha&-\\alpha&~0\\[2pt] ~0&\\ldots &\\ldots &~0&-\\alpha&~1+2\\alpha&-\\alpha\\[2pt]  ~0&\\ldots &\\ldots &\\ldots &~0&-2\\alpha&~1+2\\alpha \\end{bmatrix}\\cdotp \\begin{bmatrix} u^{n+1}{0}   \\[2pt] u^{n+1}{1}   \\[2pt] u^{n+1}{2}   \\[2pt] \\vdots        \\[2pt] u^{n+1}{N-3} \\[2pt] u^{n+1}{N-2} \\[2pt]  u^{n+1}{N-1} \\[2pt] \\end{bmatrix} =  \\begin{bmatrix} u^{n}{0}   \\[2pt] u^{n}{1}   \\[2pt] u^{n}{2}   \\[2pt] \\vdots      \\[2pt] u^{n}{N-3} \\[2pt] u^{n}{N-2} \\[2pt]  u^{n}{N-1} \\[2pt] \\end{bmatrix} + \\begin{bmatrix} 2\\alpha\\delta{}h\\nu^{-1} \\[2pt] 0           \\[2pt] 0           \\[2pt] \\vdots      \\[2pt] 0           \\[2pt] 0           \\[2pt]  2\\alpha\\delta{}h\\nu^{-1}\\[2pt] \\end{bmatrix} $","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Fourier: this third-type represents a generalization of both previous ones. This is why it is the preferred method for implementing generic code dealing with a broaded range of problems. The general form of Fourier boundary condition is given by:","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"a{}u + b\\frac{\\partial{}u}{\\partial{}x}=g","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"u + \\nu\\frac{\\partial{}u}{\\partial{}x}=h","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Thomas-solver","page":"Diffusion in 1-D with finite difference method","title":"Thomas solver","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Sample-case-2","page":"Diffusion in 1-D with finite difference method","title":"Sample case","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{cases} u=2 & x\\in[0,5;\\, 1,0]\\\nu=1 & \\text{elsewhere} \\end{cases} $","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"+++","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Introduction-to-diffusion-(Part-C)","page":"Diffusion in 1-D with finite difference method","title":"Introduction to diffusion (Part C)","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Nonlinear-diffusion-in-1-D","page":"Diffusion in 1-D with finite difference method","title":"Nonlinear diffusion in 1-D","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\frac{\\partial u}{\\partial t}=  \\frac{\\partial{}}{\\partial{}x}\\left(\\nu(u)\\frac{\\partial{}u}{\\partial{}x}\\right)","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\frac{\\partial u}{\\partial t}= \\nu(u) \\frac{\\partial^{2}{}u}{\\partial{}x^{2}}+\n\\frac{\\partial{}\\nu(u)}{\\partial{}x}\\frac{\\partial{}u}{\\partial{}x}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/#Study-case","page":"Diffusion in 1-D with finite difference method","title":"Study case","text":"","category":"section"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\frac{\\partial u}{\\partial t}= u\\frac{\\partial^{2}{}u}{\\partial{}x^{2}}+\n\\left(\\frac{\\partial{}u}{\\partial{}x}\\right)^2","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"D^{\\gamma}_{C}=4.84\\times{}10^{-5}\\exp\\left(-\\frac{150000}{RT}\\right)\\exp\\left(\\frac{570000-320{}T}{RT}x_{C}\\right)\\frac{1}{1-5x_{C}}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"$","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"From old report","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\section{Introduction}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"This sample program has been conceived for didactic purposes of teaching Fick's second law in its linear form (constant diffusion coefficient). In is conceived as a dummy example for asking students to provide the required modifications to reach generality in non-linear form as exercise. Introduction to Finite Volume Method (FVM) is supposed to have already been done in such a way that this tutorial goes directly to the details of the equation discretization. Numerical analysis and stability conditions are not provided.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\section{Equation in Cartesian coordinates}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"For a constant density medium, the diffusion of a species is modeled in two steps: \\begin{inparaenum}[(i)] \\item the constitutive relationship of the flux under a composition (or chemical potential) gradient, and \\item the balance provided by a divergent operation.\\end{inparaenum} Assuming Fick's first law as the constitutive relationship one can derive the model partial differential equation as provided in \\eqref{eq:cartesian-form}, where C gives the concentration of the diffusing species and x and t take the usual spacial and time coordinates convention.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} \\frac{\\partial{}C}{\\partial{}t}=D\\frac{\\partial^{2}C}{\\partial{}x^{2}} \\label{eq:cartesian-form} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Before proceeding with the numerical formulation one must establish the convention for spacial discretization so that equations can be written in terms of the node indexing system. Figure~\\ref{fig:discretization-scheme} represents a finite volume one-dimensional space of equally sized nodes\\footnote{Although we could have worked out the problem for the case of any spacial grid, such as a geometric series expansion of node sizes, this would only impact on the coefficients that will be produced once we discretized the equation and would make the code more difficult to read (implementation would not be much more complex, but certainly more verbose and we would loose the focus on the mathematical formulation).}. In what follows we start by integrating the problem around node P by computing fluxes through edges w and e between P and its neighbors W and E.  Boundaries will be discussed later.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\caption{\\label{fig:discretization-scheme}Discretization around node P and ghost boundaries. Dashed nodes represent an indefinite number of nodes in the system up to the boundaries.}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"A first general step in obtaining a discrete form of the model PDE is to provide spacial and temporal integration over a node. Equation~\\eqref{eq:cartesian-form-integral} provide such integration over the domain of node P between the current time and a future instant t+deltat. In what follows we assume that time-step deltat is constant but nothing would change in the formulation with a varying time-step, except that problem coefficients would need to be recomputed after each step.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} \\int{w}^{e}\\int{t}^{t+\\delta{}t}\\frac{\\partial{}C{P}}{\\partial{}t}\\mathrm{d}t\\mathrm{d}x=\\int{w}^{e}\\int{t}^{t+\\delta{}t}D\\frac{\\partial^{2}C{P}}{\\partial{}x^{2}}\\mathrm{d}t\\mathrm{d}x \\label{eq:cartesian-form-integral} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Integration over time of \\eqref{eq:cartesian-form-integral} right-hand side is straightforward since it is the integral of a differential of time: we just compute the difference of local concentrations C_P between the instants. In \\eqref{eq:cartesian-form-first-step} we denote the instant by using parenthesized superscripts. Since the left-hand side of \\eqref{eq:cartesian-form-integral} does not depend on time, integration is simply the multiplication of the integrand by time-step deltat.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} \\int{w}^{e}\\left[C^{(t+\\delta{}t)}{P}-C^{(t)}{P}\\right]\\mathrm{d}x= \\int{w}^{e}D\\frac{\\partial^{2}C}{\\partial{}x^{2}}\\delta{}t\\mathrm{d}x \\label{eq:cartesian-form-first-step} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Spacial integration is then performed in \\eqref{eq:cartesian-form-second-step}. Left-hand side is trivial since it is independent of spacial coordinate. For right-hand side we perform the integration of a derivative what corresponds to decreasing its degree by one and computing difference between evaluations of remaining derivatives over the node boundaries w and e. Notice here the introduction of superscripts (m) on the right-hand side representing an arbitrary instant. Up to this step we have not select the kind of time-stepping we will apply and thus we leave it there for now.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} \\left[C^{(t+\\delta{}t)}{P}-C^{(t)}{P}\\right]\\frac{\\delta{}x}{\\delta{}t}= \\left(D\\frac{\\partial{}C}{\\partial{}x}\\right)^{(m)}{e}-\\left(D\\frac{\\partial{}C}{\\partial{}x}\\right)^{(m)}{w} \\label{eq:cartesian-form-second-step} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"For the evaluation of the resulting fluxes in the right-hand side of \\eqref{eq:cartesian-form-second-step} we adopt a first order\\footnote{Higher order schemes would not impact the general procedure of deriving the numerical model but would again be more verbose and require more complex solving routines for the linear system that will be derived.} upwind differencing scheme (UDS), in which a derivative at an interface is computed by taking the difference between concentrations in the neighbor nodes in the positive direction of the spacial coordinate\\footnote{If using other space discretization scheme, the upwind derivative would need to be pondered by the lengths of the neighbor nodes.}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Following the proposed scheme, derivative on edge e of node P is computed by taking the difference of concentrations between E and P, as given by \\eqref{eq:difference-east}. Notice here that E is the \\emph{next} node after P in increasing x coordinate.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} \\left(D\\frac{\\partial{}C}{\\partial{}x}\\right)^{(m)}{e}=D\\frac{C^{(m)}{E}-C^{(m)}_{P}}{\\delta{x}} \\label{eq:difference-east} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Similarly, for w we take the difference between P and W, as given by \\eqref{eq:difference-west}. Again notice the upwind ordering of the terms in the difference equation.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} \\left(D\\frac{\\partial{}C}{\\partial{}x}\\right)^{(m)}{w}=D\\frac{C^{(m)}{P}-C^{(m)}_{W}}{\\delta{x}} \\label{eq:difference-west} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Multiplying both sides of \\eqref{eq:cartesian-form-second-step} by sfracdeltatdeltax we see appear on the right-hand side the multiplier given by \\eqref{eq:cfl-number}, also known as Courant–Friedrichs–Lewy number, which can be used for studying the numerical stability of the system.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} \\beta=D\\frac{\\delta{t}}{\\delta{}x^{2}} \\label{eq:cfl-number} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Applying equations \\eqref{eq:cfl-number}, \\eqref{eq:difference-east}, and \\eqref{eq:difference-west} to \\eqref{eq:cartesian-form-second-step} we derive the general model given by \\eqref{eq:base-model}. This equation still needs the time-stepping scheme to be defined. Several options are possible, such as replacing (m) by the current or next time-step, leading to explicit and implicit problems, respectively. Another alternative would be to use an interpolated intermediate instant, what is known as the family of Crank-Nicolson schemes. Higher order time-stepping is also possible, with the exception of the first one, but again we skip this possibility to make the implementation as simple as possible.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} C^{(t+\\delta{}t)}{P}-C^{(t)}{P}= \\beta{}C^{(m)}{W}-2\\beta{}C^{(m)}{P}+\\beta{}C^{(m)}_{E} \\label{eq:base-model} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"The simplest solution is to apply the current instant as a replacement to (m) in \\eqref{eq:base-model}, what leads to \\eqref{eq:explicit-model} after rearranging the terms. Notice that the integration is straightforward in this case once the next solution is computed directly from the current state of the system for each node. Due to extreme simplicity and stability issues that arise from this approach, we leave it for the interested reader to implement and experiment with the scheme.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} C^{(t+\\delta{}t)}{P}= C^{(t)}{P}+\\beta{}\\left(C^{t}{W}-2C^{t}{P}+C^{t}_{E}\\right) \\label{eq:explicit-model} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Since the target of this paper is not the comparison of different time-stepping methods, we skip Crank-Nicolson schemes due to its verbose implementation when compared to the simpler implicit scheme. Real world problems would generally use a Crank-Nicolson or higher order schemes due to precision aspects of such methods. By replacing (m) by (t+deltat) in \\eqref{eq:base-model} and rearranging terms we produce \\eqref{eq:implicit-model}, which is a linear system of equations.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} -\\beta{}C^{(t+\\delta{}t)}{W} + \\left(1+2\\beta{}\\right) C^{(t+\\delta{}t)}{P} -\\beta{}C^{(t+\\delta{}t)}{E}=C^{(t)}{P} \\label{eq:implicit-model} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"The only missing element now are the boundary conditions (BC). In what follows we assume that our space in Figure~\\ref{fig:discretization-scheme} represents the thickness of a plate, which can be submitted to different conditions on each side. Common cases are \\begin{inparaenum}[(i)] \\item the constant BC (also known as Dirichlet BC), \\item the constant flux BC (known as Neumman BC), \\item and variable flux BC (known as Fourier or Robin BC).\\end{inparaenum} Here we will consider the later due to its generality. In its purely mathematical form, a Fourier BC writes:","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} au + \\frac{\\partial{}u}{\\partial{}x}=g \\label{eq:fourier-bc} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"For practical purposes, when modeling diffusion it can be rewritten as \\eqref{eq:fourier-bc-1}. In this equation we introduce the mass transfer coefficient h, which in related to a resistance of mass transfer between environment of concentration C_infty and the studied medium. Physically this is generally introduced due to reaction rates in environment or the establishment of a chemical boundary layer.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} \\frac{\\partial{}C}{\\partial{}x}=h\\left(C_{\\infty}-C\\right) \\label{eq:fourier-bc-1} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"This boundary condition has to be replaced in \\eqref{eq:cartesian-form-second-step} for both sides of the plate. This will provide us the modified terms for the first and last rows of the linear system modeled internally by \\eqref{eq:implicit-model}. Replacing W by ghost node B_w and thus computing the flow across bw instead of w one determines the first row of the linear system to solve. Notice here that we made use of C_infty^(t+deltat) which should be provided as an analytical function of time, allowing the computation of this additional term to right-hand side.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} \\left(1+\\beta-\\gamma{e}\\right)C^{(t+\\delta{}t)}{P}-\\beta{}C^{(t+\\delta{}t)}{E} = C^{(t)}{P}-\\gamma{e}C{\\infty,e}^{(t+\\delta{}t)} \\label{eq:cartesian-form-second-step-bw} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\noindent{}where we introduced the symbol gamma analogous to CFL number for the environment-medium transfer coefficient, where h has units of sfracDdeltax.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} \\gamma = h\\frac{\\delta{}t}{\\delta{}x} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Performing the analogous substitutions for the boundary B_e we can show that the last row of the linear problem is given by:","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\begin{equation} -\\beta{}C^{(t+\\delta{}t)}{W}\\left(1+\\beta-\\gamma{w}\\right)C^{(t+\\delta{}t)}{P} = C^{(t)}{P}-\\gamma{w}C{\\infty,w}^{(t+\\delta{}t)} \\label{eq:cartesian-form-second-step-be} \\end{equation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"This way the numerical formulation of the problem is complete, only an initial state being necessary to compute its time-evolution.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\section{Equation in cylindrical coordinates}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"To be done in next version.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"\\section{Implementation}","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"For the construction of the program to solve this model we can start by listing all the required physical constants and parameters. Starting by the space discretization we should provide the \\begin{inparaenum}[(i)] \\item length L of the medium and \\item the number of nodes N_nodes\\end{inparaenum}, the cell length deltax being computed as sfracL(N_nodes-1). Similarly we provide \\begin{inparaenum}[(i)] \\item the total integration time T and \\item the number of time-steps N_steps\\end{inparaenum}, the time-step deltat being computed as sfracT(N_steps-1).","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Storage of local composition of each node requires an array C of length N_nodes. The initialization of C can be done by an user defined function that sets the value of each node in C. Next, the transport coefficients D and h must be provided as constants, what allows for the computation of parameters beta and gamma, both held constant in this study. Boundary conditions on both sides are treated independently, thus two values of h, leading to gamma_w and gamma_e. Once we assumed the environment concentration C_infty can vary in time, two functions must be provided, say C_inftyw and C_inftye.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"The matrix describing the system of equations is tridiagonal. Storing it as three arrays for the diagonals is convenient for the solution with use of Thomas algorithm. Thus, the main diagonal is stored in array d of length N_nodes, the upper and lower diagonals of length N_nodes-1 are stored in u and l, respectively. An implementation of Thomas algorithm must be provided.","category":"page"},{"location":"Learning/TransportPhenomena/003-diffusion-1d/","page":"Diffusion in 1-D with finite difference method","title":"Diffusion in 1-D with finite difference method","text":"Once all these features are available, a method providing the management of time-stepping and output of results to a file must be conceived. The problem solver will be provided in a dynamically linked library programmed in C# and the application program will be conceived in Python so that ease of change of parameters and post-processing is achieved.","category":"page"},{"location":"toc/#Table-of-contents","page":"Table of Contents","title":"Table of contents","text":"","category":"section"},{"location":"toc/","page":"Table of Contents","title":"Table of Contents","text":"Depth = 4","category":"page"},{"location":"dev/#Developement","page":"Developement","title":"Developement","text":"","category":"section"},{"location":"dev/","page":"Developement","title":"Developement","text":"DryTooling is an unpublished rolling release package set composed of several sub-packages currently not following any versioning semantics. That means that new features are added and only the commits track differences. This is temporary and will be modified when all the old code base that is giving origing to the package is migrated here. Nonetheless, the package will probably not be published to Julia registries because of the way its governance works. DryTooling tries to be self-contained in several aspects because of the needs of perfect integration between functionalities of several of its foreseen end applications. That is currently incompatible with using some of the state-of-the-art packages from Julia ecosystem.","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"This page aims at providing a tutorial for managing DryTooling.","category":"page"},{"location":"dev/#Project-management","page":"Developement","title":"Project management","text":"","category":"section"},{"location":"dev/","page":"Developement","title":"Developement","text":"Join the project management here.","category":"page"},{"location":"dev/#Adding-new-packages","page":"Developement","title":"Adding new packages","text":"","category":"section"},{"location":"dev/","page":"Developement","title":"Developement","text":"To add a new package to the framework launch a terminal under the src/ directory of the parent repository and state a julia REPL. Then change to pkg> mode by pressing ] and run generate DryTooling<package-name>.jl, where you should replace the <package-name> by the actual package's name.","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"Packages must use cammel-case naming scheme and start with DryTooling.\nDo not forget to add a .jl to the end of the package name.","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"This will create a subdirectory with the given package name and its own src/ directory and Project.toml file.","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"Next you need to add the package to the documentation workflow. Update docs/make.jl following the pattern for existing sub-packages, i.e, add the package name without .jl extension to global DRYTOOLING and below, with other subpackages, add a using directive for the package. Keep packages in alphabetical order as displayed in file explorer for ease of verification.","category":"page"},{"location":"dev/#Generating-the-documentation","page":"Developement","title":"Generating the documentation","text":"","category":"section"},{"location":"dev/","page":"Developement","title":"Developement","text":"Documentation is generated by a GitHub Actions workflow at every commit to the main branch.","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"Because of the multiple package in a repository structure, this documentation follows intrinsically a rolling release logic. Because the packages are not registered, they also do not appear in the docs/Project.toml. So it is up to the maintainers to ensure that section [deps] of docs/Project.toml points to ALL dependencies of ALL subpackages. ","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"For generating the documentation locally, from a Julia session running from docs/ , this is automalically done by  make.jl and the following is run from the REPL:","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"(@v1.9) pkg> activate .\n  Activating project at `D:\\DryTooling.jl\\docs`\n\njulia> include(\"make.jl\")\n   Resolving package versions...\n   ...","category":"page"},{"location":"dev/","page":"Developement","title":"Developement","text":"Notice that this will backup docs/Project.toml and revert changes automatically. If the process fails, DO NOT commit changes to docs/Project.toml, otherwise GitHub Actions workflow will fail (because packages are not registered).","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/#Kramers'-model","page":"Kramers' model","title":"Kramers' model","text":"","category":"section"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"using CairoMakie\nusing CSV\nusing DataFrames\nusing Latexify\nusing Printf\nusing DryToolingGranular\n\n\"Partial data from Kramers (1952) Table 3\"\nconst DATA_TABLE3 = \"\"\"\\\nρ,γ,tan(β),n,ṁ,prod_dimless,η̄ᵣ,hold_real\n1480.0,36.0,0.0094,0.059,5.15e-03,18.3,0.111,8.10\n1480.0,36.0,0.0094,0.090,2.68e-03,6.25,0.054,5.00\n1480.0,36.0,0.0094,0.195,1.32e-02,14.2,0.088,7.75\n1480.0,36.0,0.0094,0.232,7.24e-03,6.55,0.043,3.85\n1480.0,36.0,0.0100,0.040,6.38e-03,29.7,0.169,13.3\n1480.0,36.0,0.0100,0.040,5.00e-03,23.2,0.144,11.2\n1480.0,36.0,0.0100,0.069,9.20e-03,24.8,0.150,10.6\n1480.0,36.0,0.0100,0.069,6.53e-03,17.6,0.113,8.50\n1480.0,36.0,0.0100,0.106,1.50e-02,27.8,0.162,12.2\n1480.0,36.0,0.0100,0.159,1.20e-02,14.0,0.092,7.49\n1480.0,36.0,0.0100,0.238,1.55e-02,12.1,0.083,7.48\n1480.0,36.0,0.0100,0.238,1.19e-02,9.22,0.068,6.13\n\"\"\"\n\n\"Compares approximate analytical to numerical solution.\"\nfunction solvekiln(; L, D, Φ, ω, β, γ, d, show = true)\n    model = RotaryKilnBedSolution(;\n        model = SymbolicLinearKramersModel(),\n        L     = L,\n        R     = D / 2.0,\n        Φ     = Φ / 3600.0,\n        ω     = ω / 60.0,\n        β     = deg2rad(β),\n        γ     = deg2rad(γ),\n        d     = d / 1000.0\n    )\n\n    optim = kramersnlapprox(;\n        z = model.z,\n        R = D / 2.0,\n        Φ = Φ / 3600.0,\n        ω = ω / 60.0,\n        β = deg2rad(β),\n        γ = deg2rad(γ),\n        d = d / 1000.0\n    )\n\n    f = nothing\n    ax = nothing\n\n    if show\n        f = Figure()\n        ax = Axis(f[1, 1])\n\n        lines!(ax, 100model.z/L, 100model.h, linewidth = 3, label = \"Numerical\")\n        lines!(ax, 100optim.z/L, 100optim.h, linewidth = 3, label = \"Analytical\")\n\n        a = @sprintf(\"%.1f\", model.ηₘ)\n        b = @sprintf(\"%.1f\", optim.ηₘ)\n        title = \"Loading: $(a)% (numerical) | $(b)% (analytical)\"\n\n        ax.title = title\n        ax.xlabel = \"Coordinate [%]\"\n        ax.ylabel = \"Bed height [cm]\"\n        ax.xticks = 0.0:20.0:100.0\n        xlims!(ax, extrema(ax.xticks.val))\n    end\n\n    return model, optim, f, ax\nend\n\n\"Reference case for alumina kiln testing.\"\nfunction aluminakiln(ṁ, ω; show = false)\n    # Density of bed [kg/m³]\n    ρ = 800.0\n    L = 34.0\n    D = 1.5\n    β = atan(0.025)\n\n    model, optim, f, ax = solvekiln(\n        L = L,\n        D = D,\n        Φ = (1000// 24) * ṁ / ρ,\n        ω = ω,\n        β = rad2deg(β),\n        γ = 33.0,\n        d = 0.050,\n        show = show\n    )\n\n    τₚ = perrayresidence(L, ω, D, β)\n\n    return model, optim, f, ax, τₚ\nend\n\n\"Run `aluminakiln` against some known conditions.\"\nfunction scanaluminakiln()\n    ṁlist = [33.6, 43.2]\n    ωlist = [0.85, 1.20]\n\n    df = DataFrame(\n        ṁ = Float64[],\n        ω = Float64[],\n        η̄ = Float64[],\n        τᵢ = Float64[],\n        τₚ = Float64[]\n    )\n\n    for ṁ ∈ ṁlist, ω ∈ ωlist\n        model, _, _, _, τ = aluminakiln(ṁ, ω, show = false)\n        η̄ = round(model.ηₘ, digits = 0)\n        τᵢ = round(model.τ / 60.0, digits = 0)\n        τₚ = round(τ, digits = 0)\n        push!(df, [ṁ ω η̄ τᵢ τₚ])\n    end\n\n    return df\nend\n\nlet\n    # @info(\"Solution of reference case\")\n\n    in1_to_m1(v) = 0.0254 * v\n    ft1_to_m1(v) = in1_to_m1(12.0) * v\n    ft3_to_m3(v) = ft1_to_m1(1.0)^3 * v\n\n    # Kiln length [m]\n    L = ft1_to_m1(45.0)\n\n    # Kiln diameter [m]\n    D = 2 * ft1_to_m1(3.1)\n\n    # Volume flow rate [m³/h]\n    Φ = ft3_to_m3(6.1) * 60\n\n    # Rotation rate (+0.0005) [rev/min]\n    ω = 0.0505 * 60.0\n\n    # Kiln slope (0.5in/ft) [°]\n    β = rad2deg(atan(0.5 / 12))\n\n    # Repose angle [°]\n    γ = 45.0\n\n    # Particle size [mm]\n    d = 0.050\n\n    # Conversions to match model inputs.\n    R = D / 2.0\n    Φ = Φ / 3600.0\n    ω = ω / 60.0\n    β = deg2rad(β)\n    γ = deg2rad(γ)\n    d = d / 1000.0\n\n    # Create problem container.\n    kramers = RotaryKilnBedSolution(;\n        model = SymbolicLinearKramersModel(),\n        L     = L,\n        R     = R,\n        Φ     = Φ,\n        ω     = ω,\n        β     = β,\n        γ     = γ,\n        d     = d\n    )\n\n    optim = kramersnlapprox(;\n        z = kramers.z,\n        R = R,\n        Φ = Φ,\n        ω = ω,\n        β = β,\n        γ = γ,\n        d = d\n    )\n\n    global kramers_NΦ = dimlessNΦ(R, β, ω, Φ, γ)\n    global kramers_Nₖ = dimlessNₖ(L, R, β, γ)\n    global kramers_η̄ₛ = sullivansηₘ(R, β, ω, Φ, γ)\n    global kramers_ref = kramers\n    global optim_ref = optim\n\n    global RESULTS_TABLE = DataFrame(\n        Quantity  = [\n            \"NΦ\",\n            \"Nₖ\",\n            \"η̄ᵣ\",\n            \"η̄ᵢ\",\n        ],\n        Reference = [\n            \"1.15\",\n            \"1.17\",\n            \"5.65\",\n            @sprintf(\"%.2f\", optim_ref.ηₘ)\n        ],\n        Computed  = [\n            @sprintf(\"%.2f\", kramers_NΦ),\n            @sprintf(\"%.2f\", kramers_Nₖ),\n            @sprintf(\"%.2f\", kramers_η̄ₛ),\n            @sprintf(\"%.2f\", kramers_ref.ηₘ)\n        ]\n    )\nend\n\nconst TABLE3 = let\n    # @info(\"Verification of *Table 3*\")\n\n    Dₖ = 0.197\n    Lₖ = 1.780\n    dₖ = 0.0012\n\n    table3 = DataFrame(CSV.File(IOBuffer(DATA_TABLE3)))\n    table3[!, \"η̄ᵢ\"] = zeros(length(table3[!, \"η̄ᵣ\"]))\n    table3[!, \"η̄ᵣ\"] *= 100\n\n    model = SymbolicLinearKramersModel()\n\n    for (i, row) in enumerate(eachrow(table3))\n        Φ = 3600.0 * row[\"ṁ\"] / row[\"ρ\"]\n        ω = row[\"n\"] * 60.0\n        β = rad2deg(atan(row[\"tan(β)\"]))\n        γ = row[\"γ\"]\n\n        kramers = RotaryKilnBedSolution(;\n            model = model,\n            L     = Lₖ,\n            R     = Dₖ / 2.0,\n            Φ     = Φ / 3600.0,\n            ω     = ω / 60.0,\n            β     = deg2rad(β),\n            γ     = deg2rad(γ),\n            d     = dₖ / 1000.0\n        )\n\n        table3[i, \"η̄ᵢ\"] = round(kramers.ηₘ, digits = 1)\n    end\n\n    exclude = [\"ρ\", \"γ\", \"prod_dimless\", \"hold_real\"]\n    select(table3, Not(exclude))\nend\n\nconst DIMLESSPLOT = let\n    @info(\"Dimensionless profiles solution\")\n\n    ρ = 1480.0\n    L = 20.0\n    D = 0.197\n    Φ = 5.15e-03 / ρ * 3600\n    ω = 0.059 * 60\n    β = rad2deg(atan(0.0094))\n    γ = 36.0\n\n    # Conversions to match model inputs.\n    R = D / 2.0\n    Φ = Φ / 3600.0\n    ω = ω / 60.0\n    β = deg2rad(β)\n    γ = deg2rad(γ)\n\n    # Things held constant in loop.\n    NΦ = dimlessNΦ(R, β, ω, Φ, γ)\n    Nₖ = dimlessNₖ(L, R, β, γ)\n    model = SymbolicLinearKramersModel()\n\n    f = Figure()\n    ax = Axis(f[1, 1])\n\n    for d in [0.05, 0.10, 0.15, 0.193, 0.25]\n        kramers = RotaryKilnBedSolution(;\n            model = model,\n            L     = L,\n            R     = R,\n            Φ     = Φ,\n            ω     = ω,\n            β     = β,\n            γ     = γ,\n            d     = d * R * NΦ\n        )\n\n        # Dimensionless axes.\n        z = kramers.z\n        h = kramers.h / (R * NΦ)\n        z = @. (L - z) / L * 1 / (NΦ * Nₖ)\n        z = @. z[1] - z\n\n        label = @sprintf(\"%.3f\", d)\n        lines!(ax, z, h; linewidth = 2, label = label)\n    end\n\n    ax.title = \"Dimensionless loading curves\"\n    ax.xlabel = \"Coordinate\"\n    ax.ylabel = \"Bed height\"\n    ax.xticks.val = 0.0:0.1:0.5\n    ax.yticks.val = 0.05:0.05:0.25\n    xlims!(ax, extrema(ax.xticks.val))\n    ylims!(ax, extrema(ax.yticks.val))\n    axislegend(ax; position = :rb)\n\n    f\nend","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/#Sample-reference-case","page":"Kramers' model","title":"Sample reference case","text":"","category":"section"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"Here we make use of the current implementation to check if it correctly approximates the last example provided in reference paper from Kramers (1952). To minimize rounding errors causes by unit conversions, we provide the required functions to convert from imperial to international system in the solution process.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"The next table summarizes the results. It is seen that the dimensionless numbers are well approximated. It must be emphasized that the reference estimates η̄ᵣ by a graphical method – it was 1952 – and the current value is considered a good enough approximation. Additionally, the equation was not integrated numerically as done here, but engineering relationships were used in the approximation. That said, the proper loading to be considered in our days is η̄ᵢ.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"mdtable(RESULTS_TABLE, latex=false) # hide","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"Note: the last value in column Reference above is not provided in Kramers' paper but computed from the approximate analytical solution provided by the authors. As we see here, it may get >20% error under some circumstances.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/#Verification-of-*Table-3*","page":"Kramers' model","title":"Verification of Table 3","text":"","category":"section"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"In the next cell we provide the kiln dimensions used by Kramers (1952) to experimentally validate the model. Some data from their Tab. 3 is then loaded and all rows are simulated with current model. Fractional hold-up seems to be well correlated at least to a few percent of the reference value.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"mdtable(TABLE3, latex=false) # hide","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/#Dimensionless-profiles","page":"Kramers' model","title":"Dimensionless profiles","text":"","category":"section"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"Next step in validation is to check profiles in dimensionless format, as done by Kramers in their Fig. 3. Notice that here we used the numerical integration curves instead of the analytical approximation of profiles, so reproduction and consequences of results are not exactly the same.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"DIMLESSPLOT # hide","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/#Comparison-with-analytical","page":"Kramers' model","title":"Comparison with analytical","text":"","category":"section"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"The final step in model validation is to compare the approximate analytical solution proposed by Kramers and the results of numerical integration. It is worth mentioning that numerical integration remains the recommended method because one does not need to verify the ranges of validity of analytical approximation for every use case.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"let                                    # hide\n    _, _, f, ax = solvekiln(           # hide\n        L = 10.0,                      # hide\n        D = 1.0,                       # hide\n        Φ = 1.0,                       # hide\n        ω = 1.0,                       # hide\n        β = 3.0,                       # hide\n        γ = 45.0,                      # hide\n        d = 0.001                      # hide\n    )                                  # hide\n                                       # hide\n    ax.yticks = 0.0:4.0:20.0           # hide\n    ylims!(ax, extrema(ax.yticks.val)) # hide\n    f                                  # hide\nend                                    # hide","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/#Industrial-cases","page":"Kramers' model","title":"Industrial cases","text":"","category":"section"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"The following illustrates a practical use case of the model. Next we scan a parameter space to confirm once again the model suitability as an alternative to analytical engineering estimations as per Peray's notebook.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"let                                                 # hide\n    ṁ = 33.6                                        # hide\n    ω = 0.85                                        # hide\n    _, _, f, ax, _ = aluminakiln(ṁ, ω, show = true) # hide\n    ax.yticks = 0.0:6.0:30.0                        # hide\n    ylims!(ax, extrema(ax.yticks.val))              # hide\n    f                                               # hide\nend                                                 # hide","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"The following table confirms the expected values as per Peray.","category":"page"},{"location":"DryToolingGranular/validation/kramers-model/","page":"Kramers' model","title":"Kramers' model","text":"mdtable(scanaluminakiln(), latex=false) # hide","category":"page"},{"location":"DryToolingCore/#DryToolingCore","page":"DryToolingCore","title":"DryToolingCore","text":"","category":"section"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"CurrentModule = DryToolingCore\nDocTestSetup  = quote\n    using DryToolingCore\nend","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"The core package of DryTooling ecosystem provides shared functionalities and types that are used in several other more specialized packages. This allows for standardization of interfaces, employed quantities, and avoid boilerplate code. Rather than documenting the exposed functionalities in implemented order, this page organizes everything to facilitate the understanding of the end-user. Here you find the constants by multi-purpose functionalities. All abstract types were grouped in a dedicated page.","category":"page"},{"location":"DryToolingCore/#Physical-constants","page":"DryToolingCore","title":"Physical constants","text":"","category":"section"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.GAS_CONSTANT\nDryToolingCore.ZERO_CELSIUS\nDryToolingCore.ONE_ATM\nDryToolingCore.STEFAN_BOLTZMANN","category":"page"},{"location":"DryToolingCore/#DryToolingCore.GAS_CONSTANT","page":"DryToolingCore","title":"DryToolingCore.GAS_CONSTANT","text":"Ideal gas constant [8.31446261815324 J mol^-1 K^-1].\n\n\n\n\n\n","category":"constant"},{"location":"DryToolingCore/#DryToolingCore.ZERO_CELSIUS","page":"DryToolingCore","title":"DryToolingCore.ZERO_CELSIUS","text":"Zero degrees Celsius in Kelvin [273.15 K].\n\n\n\n\n\n","category":"constant"},{"location":"DryToolingCore/#DryToolingCore.ONE_ATM","page":"DryToolingCore","title":"DryToolingCore.ONE_ATM","text":"Atmospheric pressure at sea level [101325.0 Pa].\n\n\n\n\n\n","category":"constant"},{"location":"DryToolingCore/#DryToolingCore.STEFAN_BOLTZMANN","page":"DryToolingCore","title":"DryToolingCore.STEFAN_BOLTZMANN","text":"Stefan-Boltzmann constant [5.670374419e-8 W m^-2 K^-4]\n\n\n\n\n\n","category":"constant"},{"location":"DryToolingCore/#Haskell-like-array-slicing","page":"DryToolingCore","title":"Haskell-like array slicing","text":"","category":"section"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"Those who know Haskell probably started learning it by manipulating lists with head and tail. Those functionalities are not available in Julia by default and array slicing - with an ugly syntax - is required. Since this is done often in the fields of application of DryTooling, both head and tail together with a body functions are available in its core. They are simple wrapers over the @view macro and work with both iterable types and arrays. The following snippet illustrates their usage.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> v = collect(1:4);\n\njulia> head(v) == [1; 2; 3]\ntrue\n\njulia> tail(v) == [2; 3; 4]\ntrue\n\njulia> body(v) == [2; 3]\ntrue","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"More examples are provided in the following documentation ahead of each of the functions.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> head(1:4)\n1:3\n\njulia> head([1, 2, 3, 4])\n3-element view(::Vector{Int64}, 1:3) with eltype Int64:\n 1\n 2\n 3\n","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.head","category":"page"},{"location":"DryToolingCore/#DryToolingCore.head","page":"DryToolingCore","title":"DryToolingCore.head","text":"head(z)\n\nAccess view of array head. See also tail and body.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> tail([1, 2, 3, 4])\n3-element view(::Vector{Int64}, 2:4) with eltype Int64:\n 2\n 3\n 4\njulia> tail(1:4)\n2:4","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.tail","category":"page"},{"location":"DryToolingCore/#DryToolingCore.tail","page":"DryToolingCore","title":"DryToolingCore.tail","text":"tail(z)\n\nAccess view of array tail. See also head and body.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> body([1, 2, 3, 4])\n2-element view(::Vector{Int64}, 2:3) with eltype Int64:\n 2\n 3\njulia> body(1:4)\n2:3","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.body","category":"page"},{"location":"DryToolingCore/#DryToolingCore.body","page":"DryToolingCore","title":"DryToolingCore.body","text":"body(z)\n\nAccess view of array body. See also  head and tail.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/#Handling-of-discontinuous-functions","page":"DryToolingCore","title":"Handling of discontinuous functions","text":"","category":"section"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"Discontinuous functions are all over in real world applications. Whether they handle discrete signals sent to controllers or represent a material property change in the solution domain of a heat transfer simulation, they are often represented by a single or a composition of Heaviside step functions. Again, because its implementation is pretty simple and optimization routines require a differentiable form of this function, DryTooling implements heaviside and interval as proposed in this StackOverflow answer.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> heaviside(-1) == 0\ntrue\n\njulia> heaviside(-1.0) == 0.0\ntrue\n\njulia> heaviside(0.0) == 0.5\ntrue\n\njulia> heaviside(1.0) == 1.0\ntrue\n\njulia> interval(10; a = 0, b = 10) == 0.5\ntrue","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"We see below that heaviside also works on ranges","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> heaviside(-2:2)\n5-element Vector{Float64}:\n 0.0\n 0.0\n 0.5\n 1.0\n 1.0","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.heaviside","category":"page"},{"location":"DryToolingCore/#DryToolingCore.heaviside","page":"DryToolingCore","title":"DryToolingCore.heaviside","text":"heaviside(t)\n\nProvides a Heaviside function compatible with automatic differentiation. This is a requirement for conceiving, e.g., model predictive controls with discontinuous functions under ModelingToolkit.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"By implementation inheritance that is also the case for interval:","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> interval(0:6; a = 2, b = 5)\n7-element Vector{Float64}:\n 0.0\n 0.0\n 0.5\n 1.0\n 1.0\n 0.5\n 0.0","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.interval","category":"page"},{"location":"DryToolingCore/#DryToolingCore.interval","page":"DryToolingCore","title":"DryToolingCore.interval","text":"interval(x; a=-Inf, b=Inf)\n\nReturns 1 if x  (a b), 1/2 for x = a  x = b, or 0.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"As it is the case for representation of specific heats using NASA7/NASA9 or Shomate polynomials, functions defined by parts with an specific change point are also required in physical modeling. To this end, a stepwise function can be established with makestepwise1d. If keyword differentialble = true, then the function makes use of the above interval and remains compatible with ModelingToolkit, for instance.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> f = makestepwise1d(x->x, x->x^2, 1.0; differentiable = true);\n\njulia> f(0:0.2:2.0)\n11-element Vector{Float64}:\n 0.0\n 0.2\n 0.4\n 0.6\n 0.8\n 1.0\n 1.44\n 1.9599999999999997\n 2.5600000000000005\n 3.24\n 4.0\n\njulia> using ModelingToolkit\n\njulia> @variables x\n1-element Vector{Num}:\n x\n\njulia> f(x); # Output is too long, try by yourself.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.makestepwise1d","category":"page"},{"location":"DryToolingCore/#DryToolingCore.makestepwise1d","page":"DryToolingCore","title":"DryToolingCore.makestepwise1d","text":"makestepwise1d(lo, hi, xc)\n\nCreates an univariate function that is composed of two parts, the first evaluated before a critical domain point xc, and the second above that value. This is often required, for instance, for the evaluation of NASA polynomials for thermodynamic properties. If differentiable, then the returned function is compatible with symbolic argument as required when using package ModelingToolkit, etc.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/#Rounding-numbers-and-automatic-axes","page":"DryToolingCore","title":"Rounding numbers and automatic axes","text":"","category":"section"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"danger: Danger\nThis section documents functions that are used in a very unstable context and might evolve in the next commits until an stable interface is established.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"Simple rounding is not enough. Getting values that are rounded close to a power of a given number and rounded to floor or ceil is often the case. This is standardized in DryTooling through closestpowerofx:","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> closestpowerofx(10)\n10\n\njulia> closestpowerofx(11)\n20\n\njulia> closestpowerofx(11, roundf = floor)\n10\n\njulia> closestpowerofx(11, x = 5, roundf = floor)\n10\n\njulia> closestpowerofx(12.0; x = 10)\n20\n\njulia> closestpowerofx(12.0; x = 10, roundf = floor)\n10\n\njulia> closestpowerofx(12.0; x = 10, roundf = round)\n10","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.closestpowerofx","category":"page"},{"location":"DryToolingCore/#DryToolingCore.closestpowerofx","page":"DryToolingCore","title":"DryToolingCore.closestpowerofx","text":"closestpowerofx(\n    v::Number;\n    x::Number = 10,\n    roundf::Function = ceil\n)::Int64\n\nCompute the integer power of x closest to v using roundf as rouding method. This might be useful for automatic setting more reasonable limits to plot axis or similar applications. Changing the rouding method through roundf is also possible.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"Below we illustrate the usage of axesunitscaler.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"NOTE: this function is not yet stable. In the future it will instead return labels using symbols like k, M, G, etc., for the units through a flag provided by the user.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"julia> axesunitscaler(1)\n(\"\", 1)\n\njulia> axesunitscaler(1000)\n(\"[×1000]\", 1000)\n\njulia> axesunitscaler(1000000)\n(\"[×1000000]\", 1000000)","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.axesunitscaler","category":"page"},{"location":"DryToolingCore/#DryToolingCore.axesunitscaler","page":"DryToolingCore","title":"DryToolingCore.axesunitscaler","text":"axesunitscaler(x::Number)::Tuple{String, Int64}\n\nFind scaling factor for multiples of 1000 units. Together with closestpowerofx this can be used to produce better automatic plot axes limits. The returned values provide the string for modifying the axis label and the associated scaling factor.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/#Computation-of-changes-and-residuals","page":"DryToolingCore","title":"Computation of changes and residuals","text":"","category":"section"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"danger: Danger\nThis section documents functions that are used in a very unstable context and might evolve in the next commits until an stable interface is established.","category":"page"},{"location":"DryToolingCore/","page":"DryToolingCore","title":"DryToolingCore","text":"DryToolingCore.maxabsolutechange\nDryToolingCore.maxrelativechange","category":"page"},{"location":"DryToolingCore/#DryToolingCore.maxabsolutechange","page":"DryToolingCore","title":"DryToolingCore.maxabsolutechange","text":"Maximum absolute change in a solution array.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingCore/#DryToolingCore.maxrelativechange","page":"DryToolingCore","title":"DryToolingCore.maxrelativechange","text":"Maximum relative change in a solution array.\n\n\n\n\n\n","category":"function"},{"location":"Learning/TransportPhenomena/#Transport-Phenomena","page":"Transport Phenomena","title":"Transport Phenomena","text":"","category":"section"},{"location":"Learning/TransportPhenomena/","page":"Transport Phenomena","title":"Transport Phenomena","text":"In this course we provide a Julia relecture to the famous The 12 steps to Navier-Stokes equations, by Lorena A. Barba and Gilbert F. Forsyth. It is not a bare translation, but a different approach to the problems with the addition of new elements. The final goal must be seen not only as reaching the implementation of Navier-Stokes equations, but learning the key ideas of finite differences before learning more advanced and general numerical methods. Students who are undergoing Calculus training should already meet the minimum requirements to follow this course.","category":"page"},{"location":"Learning/TransportPhenomena/","page":"Transport Phenomena","title":"Transport Phenomena","text":"Focus will be given not only on the numerical methods, but also how a computer implementation should look like. This last point is the most distinctive point from the work upon which it is based. A vast amount of learning resources is available for scientific computing, but rare sources really provide guidance for conceiving quality and maintainable code. Here we try to contribute for better coding practices through a think-before-coding approach.","category":"page"},{"location":"Learning/TransportPhenomena/#Contents","page":"Transport Phenomena","title":"Contents","text":"","category":"section"},{"location":"Learning/TransportPhenomena/","page":"Transport Phenomena","title":"Transport Phenomena","text":"Introduction to Advection in 1-D\nCourant-Friedrichs-Lewy Criterium\nStability Analysis of Advection Equation\nIntroduction to Diffusion in 1-D\nDiffusion-Reaction Equation in 1-D\nBurguers Equation in 1-D\nLaplace and Poisson equations\nNavier-Stokes Equation\nIntroduction to Finite Volume Method\nFundamentals of Parallel Computing","category":"page"},{"location":"api/#Reference-API","page":"Reference API","title":"Reference API","text":"","category":"section"},{"location":"api/","page":"Reference API","title":"Reference API","text":"In this page you find a list of all documented functions of DryTooling. Rather than being organized in a logical way as the main documentation, we chose (except for the root DryTooling that comes first) to list them in alphabetical order of folders in source directory.","category":"page"},{"location":"api/#DryToolingCore.jl","page":"Reference API","title":"DryToolingCore.jl","text":"","category":"section"},{"location":"api/","page":"Reference API","title":"Reference API","text":"Modules = [ DryToolingCore ]","category":"page"},{"location":"api/#DryToolingGranular.jl","page":"Reference API","title":"DryToolingGranular.jl","text":"","category":"section"},{"location":"api/","page":"Reference API","title":"Reference API","text":"Modules = [ DryToolingGranular ]","category":"page"},{"location":"DryToolingSimulation/#DryToolingSimulation","page":"Simulation","title":"DryToolingSimulation","text":"","category":"section"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"CurrentModule = DryToolingSimulation\nDocTestSetup  = quote\n    using DryToolingSimulation\nend","category":"page"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"danger: Danger\nThis module is fragile and breaking changes are still expected. It is not until all the main solvers are migrated that it will become stable. This is necessary for ensuring compatibility with all models.","category":"page"},{"location":"DryToolingSimulation/#Iterative-solver","page":"Simulation","title":"Iterative solver","text":"","category":"section"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"The core of the iterative time-stepping solver is step!. This function that is described below works according to the following solution logic:","category":"page"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"The fouter! update function is called once. This is generall where one implements the right-hand side update of the problem before stepping.\nAn initial update with finner! is done. Normally this is responsible by the update of matrix coefficients that are dependent on solution state.\nIf relaxation α <= 0.0, then the problem is treated as linear.\nOtherwise a maximum of M iterations are repeated, where fsolve! is used to solve the problem (ofter an under-relaxation step) and is also expected to keep track of residuals.\nProblem coefficients are updated with finner! if not converged.","category":"page"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"DryToolingSimulation.step!","category":"page"},{"location":"DryToolingSimulation/#DryToolingSimulation.step!","page":"Simulation","title":"DryToolingSimulation.step!","text":"step!(\n    m::AbstractPhysicalModel,\n    t::Float64,\n    n::Int64;\n    fouter!::Function,\n    finner!::Function,\n    fsolve!::Function,\n    α::Float64 = 0.1,\n    iters::Int64 = 20,\n    tol::Float64 = 1.0e-10\n)\n\nManage the integration of a model m from time t corresponding to step call n using model internal time step. All the updates of coefficients and solution are performed through user-supplied functions.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"The outer iteration for advancing between steps is carried out by advance!.","category":"page"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"DryToolingSimulation.advance!","category":"page"},{"location":"DryToolingSimulation/#DryToolingSimulation.advance!","page":"Simulation","title":"DryToolingSimulation.advance!","text":"advance!(\n    m::AbstractPhysicalModel;\n    α::Float64 = 0.1,\n    ε::Float64 = 1.0e-10,\n    M::Int64 = 20,\n    t0::Float64 = 0.0\n)\n\nManage execution of step! over the integration time interval.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"Any model willing to implement its solution through the methods provided in this module is expected to explicity import and override the behaviour of the following methods for its own type:","category":"page"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"DryToolingSimulation.fouter!\nDryToolingSimulation.finner!\nDryToolingSimulation.fsolve!\nDryToolingSimulation.timepoints","category":"page"},{"location":"DryToolingSimulation/#DryToolingSimulation.fouter!","page":"Simulation","title":"DryToolingSimulation.fouter!","text":"fouter!(::AbstractPhysicalModel, ::Float64, ::Int64)\n\nOuter loop update for step!.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#DryToolingSimulation.finner!","page":"Simulation","title":"DryToolingSimulation.finner!","text":"finner!(::AbstractPhysicalModel, ::Float64, ::Int64)\n\nInner loop update for step!.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#DryToolingSimulation.fsolve!","page":"Simulation","title":"DryToolingSimulation.fsolve!","text":"fsolve!(::AbstractPhysicalModel, ::Float64, ::Int64, ::Float64)\n\nSolution update for step!.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#DryToolingSimulation.timepoints","page":"Simulation","title":"DryToolingSimulation.timepoints","text":"timepoints(::AbstractPhysicalModel)\n\nGet array of model time-points for use in step!.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#Linear-algebra","page":"Simulation","title":"Linear algebra","text":"","category":"section"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"DryToolingSimulation.TridiagonalProblem\nDryToolingSimulation.solve!(::DryToolingSimulation.TridiagonalProblem)\nDryToolingSimulation.change\nDryToolingSimulation.residual","category":"page"},{"location":"DryToolingSimulation/#DryToolingSimulation.TridiagonalProblem","page":"Simulation","title":"DryToolingSimulation.TridiagonalProblem","text":"Memory for a tridiagonal problem of rank N.\n\nAll tensors are filled with zeros upon creation. This is simply a utility for memory allocation, no other operations are made.\n\nA::LinearAlgebra.Tridiagonal{Float64, Vector{Float64}}: Main problem matrix.\nb::Vector{Float64}: Right-hand side vector.\nx::Vector{Float64}: Solution variable vector.\na::Vector{Float64}: Auxiliary vector, e.g. for iterative problems.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingSimulation/#DryToolingSimulation.solve!-Tuple{TridiagonalProblem}","page":"Simulation","title":"DryToolingSimulation.solve!","text":"solve!(p::TridiagonalProblem)::Nothing\n\nSolve problem x=A^-1b updating internal memory.\n\n\n\n\n\n","category":"method"},{"location":"DryToolingSimulation/#DryToolingSimulation.change","page":"Simulation","title":"DryToolingSimulation.change","text":"change(p::TridiagonalProblem)::Vector{Float64}\n\nChange in solution A^-1b-x of problem without update x.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#DryToolingSimulation.residual","page":"Simulation","title":"DryToolingSimulation.residual","text":"residual(p::TridiagonalProblem)::Vector{Float64}\n\nSolution residual b-Ax of problem without update of x.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#Residuals-tracking","page":"Simulation","title":"Residuals tracking","text":"","category":"section"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"DryToolingSimulation.TimeSteppingSimulationResiduals\nDryToolingSimulation.finaliterationdata\nDryToolingSimulation.addresidual!\nDryToolingSimulation.plotsimulationresiduals","category":"page"},{"location":"DryToolingSimulation/#DryToolingSimulation.TimeSteppingSimulationResiduals","page":"Simulation","title":"DryToolingSimulation.TimeSteppingSimulationResiduals","text":"Manage time-stepping solvers residuals storage during a simulation.\n\nThe memory is initialized with a given number of inner and outer iterations and resizing is not under the scope of this structure.\n\nN::Int64: Number of variables being tracked in problem.\ncounter::Base.RefValue{Int64}: Total iteration counter.\ninnersteps::Vector{Int64}: Number of inner steps per outer loop in solution.\nresiduals::Matrix{Float64}: Store residuals of each inner step, one variable per column.\n\nUsage\n\nFor starting a simulation, use the outer constructor for starting a simulation with pre-allocated memory with interface:\n\nTimeSteppingSimulationResiduals(N::Int64, inner::Int64, outer::Int64)\n\nOnce the simulation is finished, the first instance can be processed through creation of a new object using the next interface:\n\nTimeSteppingSimulationResiduals(r::TimeSteppingSimulationResiduals)\n\n\n\n\n\n","category":"type"},{"location":"DryToolingSimulation/#DryToolingSimulation.finaliterationdata","page":"Simulation","title":"DryToolingSimulation.finaliterationdata","text":"finaliterationdata(\n    r::TimeSteppingSimulationResiduals\n)::Tuple{Vector{Int64}, Matrix{Float64}}\n\nRetrieve data at iterations closing an outer loop of solution.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#DryToolingSimulation.addresidual!","page":"Simulation","title":"DryToolingSimulation.addresidual!","text":"addresidual!(\n    r::TimeSteppingSimulationResiduals,\n    ε::Vector{Float64}\n)::Nothing\n\nUtility to increment iteration counter and store residuals.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/#DryToolingSimulation.plotsimulationresiduals","page":"Simulation","title":"DryToolingSimulation.plotsimulationresiduals","text":"plotsimulationresiduals(\n    r::TimeSteppingSimulationResiduals;\n    ε::Union{Float64, Nothing} = nothing,\n    showinner::Bool = false,\n    resolution::Tuple{Int64, Int64} = (720, 500)\n)::Tuple{Figure, Axis, Vector}\n\nPlot problem residuals over iterations or steps. It performs the basic figure setup, configuration of axis and details beign left to the user.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"The residuals tracking functionalities of module DryToolingSimulation are not often imported by the end-user (except for its plotting utility function). In this tutorial we illustrate the logic of using a residual tracker in a new solver.","category":"page"},{"location":"DryToolingSimulation/","page":"Simulation","title":"Simulation","text":"using DryToolingSimulation\n\nN = 2      # Number of variables.\nM = 5      # Maximum inner steps.\nsteps = 10 # Time-advancement steps.\n\n# Create a TimeSteppingSimulationResiduals object with the number of variables\n# to track, how many inner iterations per step are expected, and the\n# number of steps.\n#\n# IMPORTANT: If the total number of iterations is exceeded, it is up\n# to the user to allocate more memory, the tracker will not manage it!\nr = TimeSteppingSimulationResiduals(N, M, steps)\n\n# The following loop represents a *dummy solver*. The outer loop\n# provides the time-advancement while the inner loop handles the\n# nonlinear problem. In the inner loop we use a random number\n# generator to provide varying number of steps per outer step.\nfor kouter in 1:steps\n    for kinner in 1:rand(2:M)\n        # Keep track of inner iterations per step.\n        r.innersteps[kouter] = kinner\n\n        # Feed residuals to the solver.\n        addresidual!(r, rand(r.N))\n    end\nend\n\n# After running a simulation we create a new object using another\n# constructor that accepts a `TimeSteppingSimulationResiduals` object. This\n# handles the post-processing.\ns = TimeSteppingSimulationResiduals(r)\n\n# The new object is ready for visualization. Check the documentation\n# of the following function for more details. It provides a raw figure\n# and handles for modifying it for proper display.\nfig = plotsimulationresiduals(s; showinner = true)[1]","category":"page"},{"location":"DryToolingGranular/#DryToolingGranular","page":"Granular","title":"DryToolingGranular","text":"","category":"section"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"CurrentModule = DryToolingGranular\nDocTestSetup  = quote\n    using Statistics\n    using DryToolingGranular\nend","category":"page"},{"location":"DryToolingGranular/#General-porous-media","page":"Granular","title":"General porous media","text":"","category":"section"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"Modeling of geometrical characteristics of porous beds is required for including both their thermal effect or role over chemistry in chemical reactors. A classical approach used in several commercial and open source tools is that of Gunn [1]. In what follows we develop the ideas that lead to an analogous model which is implemented by this structure.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"To build the model we will assume a reactor of constant rectangular cross-section A_r=bw and volume V_R=bwh. Its cross-section perimeter is then P_R=2(b+w). Inside this reactor we randomly pack cubic particles beta of surface area A_beta=6l_beta^2 and volume V_beta=l_beta^3 at a porosity level phi. Thus the total volume of solids inside the reactor is V_S=(1-phi)V_R and the approximate number of particles N=fracV_SV_beta. Following a similar reasoning the total surface area of particles is A_S=NA_beta. Performing all the substitutions so far one finds the following expression","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"A_S=frac6(1-phi)bwhl_beta","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"Since the differential dA=Pdl holds for the surface of a body over its length l, one can divide the above expression by the reactor length to get the perimeter of particles in a cross-section. We can further divide by the cross-section area itself and find the perimeter density which is a more general result, and find the expression proposed by Gunn [1]. This result is summarized in the next equation where the subscript of particle size was dropped for generality.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"P = frac6(1-phi)l","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"An estimator of the number of channels per unit cross-section of reactor N can be related to the porosity through NpiR^2=phi. Because the above perimeter is shared between the fluid volume and solids, it holds that N2piR=P. Using these expressions one can solve for the porosity channels characteristic radius R as given below, which is also a result reported by Gunn [1].","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"R=fracphil3(1-phi)","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"This model is probided in PackedBedPorosityDescriptor.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"DryToolingGranular.PackedBedPorosityDescriptor","category":"page"},{"location":"DryToolingGranular/#DryToolingGranular.PackedBedPorosityDescriptor","page":"Granular","title":"DryToolingGranular.PackedBedPorosityDescriptor","text":"Provides description of porosity parameters with stochastic behavior.\n\nϕ::Union{Float64, Vector{Float64}}: Porosity volume fraction in medium [-].\nl::Union{Float64, Vector{Float64}}: Characteristic particle size in medium [m].\nσϕ::Union{Nothing, Float64}: Optional standard deviation of porosity volume fraction  [-].\nσl::Union{Nothing, Float64}: Optional standard deviation of characteristic particle size [m].\nP::Union{Float64, Vector{Float64}}: Perimeter in reactor cross-section [m].\nD::Union{Float64, Vector{Float64}}: Characteristic diameter of porosity channels [m].\nA::Float64: Reactor area used for scaling perimeter [m²].\n\n\n\n\n\n","category":"type"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"PackedBedPorosityDescriptor can be used to describe the geometry of exchange section of a packed bed for a single set of arguments.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"julia> PackedBedPorosityDescriptor(; ϕ = 0.65, l = 0.10, area = 1.0)\nPackedBedPorosityDescriptor(P = 21.000000 m, D = 0.123810 m)","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"It can also be used to describe randomly varying reactors, what is a more realistic thing to do when using this structure to simulate real world systems.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"julia> PackedBedPorosityDescriptor(;\n            ϕ  = 0.65, l  = 0.10,\n            σϕ = 0.03, σl = 0.01,\n            N = 2,\n            ϕlims = (0.4, 0.8),\n            llims = (0.0, 0.3),\n            seed = 42,\n            area = 1.0\n        )\nPackedBedPorosityDescriptor(\n    P from  21.455749 m to  24.370742 m\n    D from   0.125589 m to   0.102353 m\n)","category":"page"},{"location":"DryToolingGranular/#Rotary-kiln-models","page":"Granular","title":"Rotary kiln models","text":"","category":"section"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"In a rotary kiln as proposed by Kramers and Croockewite (1952) [2]. Its goal is to be used as a process support tool or to integrate more complex models requiring integration of the bed profile. In its classical statement, the bed height profile h(z) can be evaluated from volume of flowing material conservation through the following equations. Coordinate z=0 represents the discharge position where initial condition must be applied. This is given by the dam height, if any, or particle size.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"beginaligned\ndfracdhdz = C₁ leftfrachRleft(2 - frachRright)right^-frac32 - C₂6pt\nC₁             = frac34dfracΦtanγπ R^3 ω6pt\nC₂             = dfractanβcosγ\nendaligned","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"The structure SymbolicLinearKramersModel implements the Kramers' ordinary differential equation for prediction of bed height profile in a rotary kiln. This equation is implemented under the formalism of ModelingToolkit.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"DryToolingGranular.SymbolicLinearKramersModel","category":"page"},{"location":"DryToolingGranular/#DryToolingGranular.SymbolicLinearKramersModel","page":"Granular","title":"DryToolingGranular.SymbolicLinearKramersModel","text":"Creates a reusable linear Kramers model for rotary kiln simulation.\n\nR::Symbolics.Num: Symbolic kiln internal radius\nΦ::Symbolics.Num: Symbolic kiln feed rate\nω::Symbolics.Num: Symbolic kiln rotation rate\nβ::Symbolics.Num: Symbolic kiln slope\nγ::Symbolics.Num: Symbolic solids repose angle\nz::Symbolics.Num: Symbolic kiln axial coordinates\nh::Symbolics.Num: Symbolic bed height profile\nsys::ModelingToolkit.ODESystem: Problem ordinary differential equation\n\n\n\n\n\n","category":"type"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"For integration of this model we implement RotaryKilnBedSolution. It provides the solved description of a rotary kiln bed geometry computed from the solution of bed height along the kiln length. The main goal of the quantities computed here is their use with heat and mass transfer models for the simulation of rotary kiln process. A simple post-processing utilitiy plotlinearkramersmodel is also provided.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"DryToolingGranular.RotaryKilnBedSolution\nDryToolingGranular.plotlinearkramersmodel","category":"page"},{"location":"DryToolingGranular/#DryToolingGranular.RotaryKilnBedSolution","page":"Granular","title":"DryToolingGranular.RotaryKilnBedSolution","text":"General geometric description of a bed from Kramers equation solution.\n\nz::Vector{Float64}: Solution coordinates [m]\nh::Vector{Float64}: Solution bed height [m]\nθ::Vector{Float64}: View angle from kiln center [rad]\nl::Vector{Float64}: Bed-freeboard cord length [m]\nA::Vector{Float64}: Local bed cross section area [m²]\nη::Vector{Float64}: Local loading based on height [-]\nηₘ::Float64: Mean loading of kiln [%]\nV::Float64: Bed integral volume [m³]\nτ::Float64: Residence time of particles\nβ::Float64: Kiln slope [rad]\n\nArguments\n\nInternal elements are initialized through the following constructor:\n\nRotaryKilnBedSolution(z, h, β, R, Φ)\n\nWhere parameters are given as:\n\nz: solution coordinates over length, [m].\nh: bed profile solution over length, [m].\nR: kiln internal radius, [m].\nΦ: kiln feed rate, [m³/s].\n\nAn outer constructor is also provided for managing the integration of an instance of SymbolicLinearKramersModel. This is the recommended usage that is illustrated below.\n\nImportant: inputs must be provided in international system (SI) units as a better physical practice. The only exception is the rotation rate ω provided in revolution multiples. If the discharge end is held by a dam, its height must be provided instead of the particle size, as it is used as the ODE initial condition.\n\nmodel: a symbolic kiln model.\nL: kiln length, [m].\nR: kiln internal radius, [m].\nΦ: kiln feed rate, [m³/s].\nω: kiln rotation rate, [rev/s].\nβ: kiln slope, [rad].\nγ: solids repose angle, [rad].\nd: particle size or dam height, [m].\nsolver: Solver for DifferentialEquations. Defaults to Tsit5.\nrtol: Relative integration tolerance. Defaults to 1.0e-08.\natol: Absolute integration tolerance. Defaults to 1.0e-08.\n\n\n\n\n\n","category":"type"},{"location":"DryToolingGranular/#DryToolingGranular.plotlinearkramersmodel","page":"Granular","title":"DryToolingGranular.plotlinearkramersmodel","text":"plotlinearkramersmodel(\n    model::RotaryKilnBedSolution;\n    normz::Bool = false,\n    normh::Bool = false\n)::Figure\n\nStandardized plotting of RotaryKilnBedSolution bed profile. It supports normalization of axes throught keywords normz for axial coordinate and normh for bed depth.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"Data in next example is an SI conversion of an example from Kramers and Croockewite (1952) [2].","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"julia> L = 13.715999999999998;  # Kiln length [m]\n\njulia> D = 1.8897599999999999;  # Kiln diameter [m]\n\njulia> β = 2.3859440303888126;  # Kiln slope [°]\n\njulia> γ = 45.0;                # Repose angle [°]\n\njulia> d = 1.0;                 # Particle/dam size [mm]\n\njulia> Φ = 10.363965852671996;  # Feed rate [m³/h]\n\njulia> ω = 3.0300000000000002;  # Rotation rate [rev/min]\n\njulia> bed = RotaryKilnBedSolution(;\n            model = SymbolicLinearKramersModel(),\n            L     = L,\n            R     = D / 2.0,\n            Φ     = Φ / 3600.0,\n            ω     = ω / 60.0,\n            β     = deg2rad(β),\n            γ     = deg2rad(γ),\n            d     = d / 1000.0\n        );\n\njulia> bed\nRotaryKilnBedSolution(τ = 13.169938 min, ηₘ = 5.913271 %)\n\njulia> bed.τ\n790.1963002204092","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"In the following dummy example we force a very thick analytical bed solution, filling the radius of the rotary drum. ","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"julia> R = 1.0e+00;\n\njulia> Φ = 1.0e-02;\n\njulia> z = collect(0.0:0.1:10.0);\n\njulia> h = R * ones(size(z));\n\njulia> Aₐ = π * R^2 / 2;\n\njulia> Vₐ = Aₐ * z[end];\n\njulia> bed = RotaryKilnBedSolution(z, h, 0, R, Φ)\nRotaryKilnBedSolution(τ = 26.179939 min, ηₘ = 50.000000 %)","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"Next we confirm the internal evaluations of the model match the expected analytical values.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"julia> mean(bed.θ) ≈ π\ntrue\n\njulia> mean(bed.l) ≈ 2R\ntrue\n\njulia> mean(bed.A) ≈ Aₐ\ntrue\n\njulia> mean(bed.η) ≈ 0.5\ntrue\n\njulia> bed.ηₘ ≈ 50.0\ntrue\n\njulia> bed.V ≈ Vₐ\ntrue\n\njulia> bed.τ ≈ Vₐ / Φ\ntrue","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"Validation of Kramers' model is provided here.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"Finally a set of basic equations provided for process analysis.","category":"page"},{"location":"DryToolingGranular/","page":"Granular","title":"Granular","text":"DryToolingGranular.sullivansηₘ\nDryToolingGranular.dimlessNΦ\nDryToolingGranular.dimlessNₖ\nDryToolingGranular.perrayresidence\nDryToolingGranular.kramersnlapprox","category":"page"},{"location":"DryToolingGranular/#DryToolingGranular.sullivansηₘ","page":"Granular","title":"DryToolingGranular.sullivansηₘ","text":"Sullivans approximation to kiln filling.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingGranular/#DryToolingGranular.dimlessNΦ","page":"Granular","title":"DryToolingGranular.dimlessNΦ","text":"Kramers (1952) dimensionless group NΦ.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingGranular/#DryToolingGranular.dimlessNₖ","page":"Granular","title":"DryToolingGranular.dimlessNₖ","text":"Kramers (1952) dimensionless group Nₖ.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingGranular/#DryToolingGranular.perrayresidence","page":"Granular","title":"DryToolingGranular.perrayresidence","text":"Compute residence time from Peray's equation.\n\n\n\n\n\n","category":"function"},{"location":"DryToolingGranular/#DryToolingGranular.kramersnlapprox","page":"Granular","title":"DryToolingGranular.kramersnlapprox","text":"Nonlinear formulation of Kramers model approximate solution.\n\n\n\n\n\n","category":"function"},{"location":"Learning/TransportPhenomena/001-advection-1d/#Introduction-to-Advection-in-1-D","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"","category":"section"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Advection is one of the terms present in the Navier-Stokes equations; it describes the transport of a quantity induced by a vector field. The choice to start with this topic rather than diffusion or the Poisson equation is mainly justified by the simple computational implementation in the explicit form of this equation using an upwind scheme. In what follows we will first address the linear and subsequently nonlinear form of advection. To conclude the chapter, we will perform a numerical stability analysis of the problem.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"The general goals of this study can be summarized as:","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Learn advection both in PDE and numerical perspectives.\nImplement a set of tools to solve advection equation.\nProvide post-processing for standard visualization of results.\nLearn the basics of numerical stability analysis.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Once the goals have been set, we should already be able to guess the base set of tools required for their achievement. Below we specify the logic behind our choices.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Since Julia is a language conceived for scientific computing, all the tooling for the implementation of the equations in a vectorized form is already available, so we do not need any further packages for now. \nIn this study, to ensure the physical consistency of derived equations and their correct implementation, we will provide numerical values with units through u-strings provided by package Unitful.\nFor all the visualizations we will make use of CairoMakie.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"warning: Beware!\nUsing units could represent some overhead in large scale problems. It is important to keep the code compatible with purely numerical values when implementing packages.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"The following block import the required packages:","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"using Unitful\nusing CairoMakie","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/#Advection-fundamentals","page":"Introduction to Advection in 1-D","title":"Advection fundamentals","text":"","category":"section"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Advection in one dimension is the phenomenon describing the evolution of a quantity u transported across a field of constant velocity c. Also notice that the quantity u may be the velocity field itself in a more general framework we will deal with laterm leading to the nonlinear form of advection equation. Transport is expressed in time and space as u(xt+Deltat)=u(x-cDeltatt). That indicates simply that the state at x-cDeltat will be found at position x after a time interval Deltat, i.e. for a constante velocity field c the profile u is invariant. For a very short time interval Deltat with respect to system length L and velocity c, i.e Deltatllc^-1L, this expression can be expanded as a Taylor series and one can derive the following equation:","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"u(xt)+Deltatdfracdudt\nsimeq\nu(xt)-cDeltatdfracdudx\nimplies\ndfracpartialupartialt+cdfracpartialupartialx=0","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Under these conditions, the above equation has a trivial analytical solution that can be found e.g. by the method of characteristics, what is outside our scope here. Consider the initial condition u_0=u(x0) (the subscript indicates the initial instant). The transport produced by the field c can be expressed in terms of this initial condition as u(xt)=u_0(x-ct). This result is important for the study of numerical methods because it allows for validation of implemented programs.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Since our goal is the introduction to the computational aspects only, we skip a detailed numerical analyses showing that centered in space schemes are not suitable for the computation of space derivatives applied to advection equation since they exhibit an unconditionally unstable behavior. The origin of unstability of some of these is is quite understandable from a physical standpoint. Information is travelling along the velocity field, and any information in front of the traveling wave cannot have any knowledge on the prior shape of the wave. That is why so-called upwind schemes are suitable for numerical computation of advection. In such family of schemes, the information coming from the origin of the advecting flow is used to evaluate the upcoming wave position, i.e. for c0 the solution at x is computed from the solution at x-Deltax, thus the reason why it is called upwind, here Deltax is a finite variation over coordinate x. It can be shown through a Taylor series expansion truncated at first order that","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"dfracpartialupartialxapprox\ndfracu(x)-u(x-deltax)deltax+mathcalOdeltax","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"note: Upwind advection scheme\nThe above expression is quite intuitive. Let's see how would it be implemented as Julia code. Supose you have an array of solution u at each of the discrete space points x. Since points are spaced by Deltax, represented in code as Δx  , then taking the difference between  consecutive values of u is equivalent to the upwind scheme as follows:dudx = (u[2:end] - u[1:end-1]) / Δx;Remember that indices in Julia start at 1, not at 0 as in Python or C++.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Other higher order expansions are available in the literature, but they are not well-suited for an introductory course on numerical implementation of the solution of PDE's, so we stick with this low order approximation in what follows. An analogous expansion can be performed for the time derivative of the advection equation. Notice that for time the expansion is performed towards the future. This leads to the following space-time discretization to the problem","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"fracu(t+Deltat)-u(t)Deltat+cfracu(x)-u(x-Deltax)Deltax=0","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"This approximate representation of the advection PDE is difficult to read and distant from what it would look in a computer, where it can be represented through indexed arrays or matrices. It is common in the FDM to use subscripts for denoting space indices, and superscript for time-steps. This way we translate t+Deltat as n+1, where n is the time-step number, and x-Deltax becomes i-1, where i is the index of the FDM space coordinate node. Also it is useful to maker shorthands tau=Deltat and delta=Deltax. The equation becomes","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"fracu_i^n+1-u_i^ntau+cfracu_i^n-u_i-1^ndelta=0","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Our goal of approaching the equation to the computer implementation format has been reached. So far we are only considering fixed time-steps tau and internodal distances delta, and constant advection velocity c. Since problem initial state is a priori knowledge for PDE integration, at n=0 and foralli we dispose of the state u_i^n=u_i^0, so the only unknown in the above equation is u_i^n+1, for which it can be solved","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"u_i^n+1=(1-alpha)u_i^n+alphau_i-1^n","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Such approximation that makes use of current state to predict a future one is called an explicit time-stepping scheme and has been implied without explanation in the above discretization approach. With this expression we have the complete mathematical tooling to solve the simplest advection equation. Notice that for c0 the direction of the upwind space derivative would change and the solution becomes u_i^n+1=(1+alpha)u_i^n-alphau_i+1^n.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Now suppose we want to solve advection of a given wave over a 1-D space domain. The discrete solution derived above provides most information we need to gather before starting to develop a computer solution, but it says nothing about the sizes of discrete steps tau and delta. For now we rely only on the mathematical background we have on Taylor series expansion to think about it, and we postpone the methods of computing suitable steps for later.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"With this formulation we are ready to start sketching a numerical solver.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/#Program-structure","page":"Introduction to Advection in 1-D","title":"Program structure","text":"","category":"section"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"In what follows we focus on the computer implementation of the problem.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"So let's again sketch some goals for our program:","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"It must handle both linear and nonlinear 1-D advection equations.\nIt must provide a reusable time-stepping function for integration.\nIt must provide standardized post-processing utilities.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Because we are seeking generality to solve a whole class of problems, i.e. any type of 1-D advection problem it is interesting considering the use of abstract types. These are used to structure a hierarchy of problems. Abstract types in Julia do not really have arguments, as it is possible in other languages. They simply provide a name and associated methods. Notice that because of this, when inheriting from abstract types, it is important to make sure the new structures are compatible with the base methods, that they provide the required arguments. So we start with the definition of an abstract type for all of the advection equations we might implement here:","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"abstract type AbstractAdvection end","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"note: Real world cases\nPreviously, by hierarchy we meant models that can be a subset of larger scope models. In a library implementation you might find something as:abstract type AbstractModel end\n\nabstract type AbstractPhysicalModel <: AbstractModel end\nabstract type AbstractODEModel <: AbstractPhysicalModel end\nabstract type AbstractPDEModel <: AbstractPhysicalModel end\nabstract type AbstractKinetics <: AbstractODEModel end\nabstract type AbstractAdvection <: AbstractPDEModel end\nabstract type AbstractAdvection1D <: AbstractAdvection end\nabstract type AbstractAdvection2D <: AbstractAdvection end\n\nstruct LinearAdvection1D <: AbstractAdvection1D end\nstruct NonlinearAdvection1D <: AbstractAdvection1D end","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"The solution loop is straightforward: we store the current state and solve over the same array the next time solution, what constitutes a simple explicit Euler time-stepping scheme. Since Julia supports vectorized operations we use the slice syntax to evaluate (1-alpha)u_i^n+alphau_i-1^n and attribute it elementwise to u_i^n+1. Notice that element u[1] is never updated here, think for a moment what are the implications of this.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"function integrate!(p::AbstractAdvection)::Nothing\n    for (k, t) in enumerate(p.t[1:end-1])\n        # Uncomment below to check correct stepping:\n        # @info \"Advancing from ``t to ``(p.t[k+1])\"\n        p.M[k, :] = copy(ustrip(p.u))\n        step!(p)\n    end\n\n    p.M[end, :] = copy(ustrip(p.u))\n    return nothing\nend","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Note: method ustrip from Uniful was used to remove units from arrays before plotting because their rendering is not converted to LaTeX in axes.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"function plotstate(p::AbstractAdvection)::Figure\n    x = ustrip(p.x)\n    u₀ = p.M[1, 1:end]\n    u₁ = p.M[end, 1:end]\n\n    fig = Figure(resolution = (700, 500))\n    ax = Axis(fig[1, 1])\n    l1 = lines!(ax, x, u₀; linewidth = 3)\n    l2 = lines!(ax, x, u₁; linewidth = 3)\n    ax.title = \"Initial and final states of problem\"\n    ax.xlabel = \"Coordinate [m]\"\n    ax.ylabel = \"Velocity [m/s]\"\n    xlims!(ax, extrema(x))\n    axislegend(ax, [l1, l2], [\"Initial\", \"Final\"], \"States\",\n               position = :lt, orientation = :vertical)\n    return fig\nend","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"It is also interesting to provide a function to visualize space solution over time. This is the job of a kymograph, which is provided below.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Because they will be reused several times in this chapter, we wrap the kymograph and comparison plotting in the functions given below. It is generally a good idea to follow some DRY directives, but care must be take not to create new methods for simple one-liners, which could become hard to maintain later.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"function kymograph(p::AbstractAdvection; xticks, yticks, zticks)::Figure\n    colormap = :gnuplot2\n    colorrange = extrema(zticks)\n\n    x = ustrip(p.x)\n    y = ustrip(p.t)\n    z = transpose(p.M)\n\n    fig = Figure(resolution = (700, 600))\n    ax = Axis(fig[2, 1], xlabel = \"Coordinate [m]\", ylabel = \"Time [s]\")\n    hm = heatmap!(ax, x, y, z; colormap, interpolate = true, colorrange)\n    cb = Colorbar(fig[1, 1], hm, vertical = false, label = \"Velocity [m/s]\")\n\n    ax.xticks = xticks\n    ax.yticks = yticks\n    xlims!(ax, extrema(ax.xticks.val))\n    ylims!(ax, extrema(ax.yticks.val))\n\n    cb.ticks = zticks\n    cb.limits = extrema(zticks)\n    return fig\nend","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/#Linear-advection","page":"Introduction to Advection in 1-D","title":"Linear advection","text":"","category":"section"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Knowing the nodal distance delta, there are many ways of allocating the initial state for u, the most computationally efficient being allocating an array with the right number of nodes, them using multiples of delta to attribute the value at each cell. We will not proceed this way here. Instead we provide ranges representing both space and time nodes. Notice that Julia does not expand these ranges, you need to collect them manully or use them in interation loops.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Because we need to know the nodal positions to compute initial state, we already collect the vector. The first 5 elements are displayed. By x[1:5] we remember that Julia indexing system starts at 1 and the slicing 1:5 includes the last index, what would not be true in Python, for instance.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"For allocating arrays of same shapes, Julia provides the method similar. Since we are using units with our values, that method cannot be used here with array for x to allocate the density array u, otherwise the result would carray space dimensions. Instead we create a ones array of appropriate numerical type and dimensions and provide it with units carried by u_0. Notice that this initializes the whole array with the value found in the square wave.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"With all this elements we prepare the solution. We start by computing the constant alpha known as Courant number. Observe that this is a dimensionless number since it results from the product of a velocity by the inverse of a numerical velocity. Depending on the choice of derivative approximations there may be a upper limit for which the numerical integration will be stable. We are not entering in these details yet, for now you can read more about this here to get a taste of the numerical analysis to come.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"In the present case we might want to store the solution of all time steps for performing an animation or display a kymograph, what will be the case here. For small to medium sized problems, it is more effecient to allocate the memory for solution storage ahead of time, especially when working with fixed time steps. For larger problems or variable time step size, it is sometimes necessary to allocate memory for part of the solution and from times to times dump current chunk to the disk, or handle a buffer with limited memory.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Since this is a very simple 1-D problem, we chose to have a matrix will one row per time step, so its dimensions are n_ttimesn_x, as follows.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"struct LinearAdvection1D <: AbstractAdvection\n    t::Vector{Unitful.Time}\n    x::Vector{Unitful.Length}\n    u::Vector{Unitful.Velocity}\n    c::Unitful.Velocity\n    δ::Unitful.Length\n    τ::Unitful.Time\n    M::Matrix{Float64}\n\n    function LinearAdvection1D(L, T, c, nₓ, nₜ; init, integ = true)\n        δ = L / (nₓ - 1)\n        τ = T / (nₜ - 1)\n        t = collect(0.0u\"s\":τ:T)\n        x = collect(0.0u\"m\":δ:L)\n        u = 0u\"m/s\" * zeros(Float64, nₓ)\n        M = zeros(Float64, (nₜ, nₓ))\n\n        init(x, u)\n\n        obj = new(t, x, u, c, δ, τ, M)\n        integ && integrate!(obj)\n        return obj\n    end\nend","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"function step!(p::LinearAdvection1D)::Nothing\n    α = p.c * (p.τ / p.δ)\n    p.u[2:end] = (1 - α) * p.u[2:end] + α * p.u[1:end-1]\n    return nothing\nend","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/#Problem-statement","page":"Introduction to Advection in 1-D","title":"Problem statement","text":"","category":"section"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Consider a hypothetical domain of L=25mathrmm along along x axis over which we have initially a wave of an unsoluble substance moving at to u=1mathrmmcdotps^-1 located in interval xin0510mathrmm, being half this value elsewhere. At the starting time, a fluid flow with velocity c=1mathrmmcdotps^-1 is forced through the domain, which is already immersed in the fluid.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Determine the mass density u(xt) of the substance for the next T=10mathrms interval.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"This problem statement provides all the basic building blocks to implement the solution, which we translate into Julia code as:","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"# Domain length.\nL = 2.5u\"m\"\n\n# Time domain.\nT = 1.0u\"s\"\n\n# Fluid velocity.\nc = 1.0u\"m/s\"\n\n# Wave velocity.\nu₀ = 1.0u\"m/s\"\n\n# Initialization function.\ninit(x, u) = let\n    hump = (0.5u\"m\" .< x) .& (x .< 1.0u\"m\")\n    u[:]    .= u₀ / 2.0\n    u[hump] .= u₀\nend\nnothing # hide","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"To modify the regions ouside the peak we create a boolean mask. In Julia, to evaluate a binary operation elementwise, a dot is placed in front of the operator. So here xᵤ[1] .< x means true where elements of x are less than the first element of xᵤ, for instance. Since the mask we created represent the square wave region, we negate the resulting array to set zero elsewhere in the density array u. Also observe the .= notation to attribute results. This vectorized operations supported by Julia avoid the excessive use of loops and result in easier to maintain code.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"To remain within the region where the error introduced by the discretization scheme remains small, we need to think what would be a good number of steps and nodes to split our system. Thinking physically, we would not want the density u to be transported by more than one node distance delta in a time step tau, otherwise we would be skipping information transfer. Thus, there is some logic constraining deltalectau to be respected here. We also have infinite gradients in the specified square wave of mass density, so space step should not be too small otherwise it would lead to a overflow error..., well, there are many other aspects to be considered, but we did not introduce them yet. So let's just assume that as a rule of thumb both space and time discretization must be reasonably smaller than the integration domains.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Below we assume this reasonably small criterium is 1/500 the size of the system and compute the required nodal distance and time step. Notice the - 1 in the denominator, because the number of intervals between k nodes is k-1. The computed values are displayed with their respective units.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"nₓ = 101\nnₜ = 101\np1 = LinearAdvection1D(L, T, c, nₓ, nₜ; init)\nnothing # hide","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Below we display a comparison between initial and final states of the advected wave.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"plotstate(p1) # hide","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"kymograph(p1; xticks = 0.0:0.5:ustrip(L), # hide\n              yticks = 0.0:0.2:ustrip(T), # hide\n              zticks = 0.5:0.1:1.0)  # hide","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"The analytical solution to this problem states that the shape of the density profile should not evolve in time, just its position. In the kymograph above that would mean that the only valid values in the heat map would be those originally in the initial state array. This is not actually what we observe. We get just qualitative agreement between the expected and actual position of our moving hump u, which apparently diffused over the domain. And this exaclty what happened, from a numerical standpoint. When we approximated the spacial derivative, we were actually truncating a Taylor series expansion of u at the first term, as in:","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"u(x) = u(x-Deltax) + frac(Deltax)^11fracmathrmdumathrmdx +\n                        frac(Deltax)^22fracmathrmd^2umathrmdx^2 +\n                        mathcalO((Deltax)^3)","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"so that the derivative we approximated was in fact:","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"fracu(x) - u(x-Deltax)Deltax = \n    fracmathrmdumathrmdx +\n    frac(Deltax)2fracmathrmd^2umathrmdx^2 +\n    mathcalO((Deltax)^2) =\n    fracmathrmdumathrmdx +\n    mathcalO((Deltax)^1)","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Our numerical approximation to the first derivative implicitly contains a diffusion term in the truncation error! The same is valid for the time derivative. We could use higher order schemes but always there will be some numerical diffusion in upwind schemes for convection. From the expression above we see that this diffusion term is proportional to Deltax, so increasing the number of points in space could be a solution, but this can become prohibitive in real-world 3-D problems.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/#Exercises","page":"Introduction to Advection in 1-D","title":"Exercises","text":"","category":"section"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Solve the problem with an increasingly larger number of space nodes and plot the MSE of the difference between the numerical and analytical solutions. What kind of behavior do you observe? Is there any limiting value for the number of nodes under constant time discretization? Discuss your findings.\nIncrease the integration interval to T=3mathrms and adapt problem solution to handle periodic boundary conditions. Does the meaning of space coordinates remain the same all over the array? Do not forget to use an adequate number of time steps for keeping solution stable.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/#Nonlinear-advection","page":"Introduction to Advection in 1-D","title":"Nonlinear advection","text":"","category":"section"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"In order to introduce more complex phenomena, we modify the advection equation so that there is no external field transporting the wave but itself. In this case the previous c is replaced by u and the equation writes","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"fracpartialupartialt + u fracpartialupartialx = 0","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Applying the same approach and symbol convention used before, we can find that","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"u_i^n+1=(1-alpha_i)u_i^n+alpha_iu_i-1^nqquadtextwhereqquadalpha_i=fractaudeltau_i^n","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"As an example we solve the transport of the same wave integrated in linear advection example with a self-advective transport instead. Other than a small rearrangement in the equation there are no changes in the time-stepping.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"struct NonlinearAdvection1D <: AbstractAdvection\n    t::Vector{Unitful.Time}\n    x::Vector{Unitful.Length}\n    u::Vector{Unitful.Velocity}\n    δ::Unitful.Length\n    τ::Unitful.Time\n    M::Matrix{Float64}\n\n    function NonlinearAdvection1D(L, T, nₓ, nₜ; init, integ = true)\n        p = LinearAdvection1D(L, T, 1.0u\"m/s\", nₓ, nₜ; init, integ = false)\n        obj = new(p.t, p.x, p.u, p.δ, p.τ, p.M)\n        integ && integrate!(obj)\n        return obj\n    end\nend","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"function step!(p::NonlinearAdvection1D)::Nothing\n    α = p.u[2:end] .* (p.τ / p.δ)\n    p.u[2:end] = @. (1 - α) * p.u[2:end] + α * p.u[1:end-1]\n    return nothing\nend","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"nₓ = 101\nnₜ = 101\np2 = NonlinearAdvection1D(L, T, nₓ, nₜ; init)\nnothing # hide","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"Analysing the ucdotpu^prime term in the nonlinear advection equation we see that it has units of acceleration. Because now the transport coefficient is the local velocity itself, different locations accelerate at different rates, leading to the shock wave phenomenon. Below we compare the initial and final waves.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"plotstate(p2) # hide","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"kymograph(p2; xticks = 0.0:0.5:ustrip(L), # hide\n              yticks = 0.0:0.2:ustrip(T), # hide\n              zticks = 0.5:0.1:1.0) # hide","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/#Exercises-2","page":"Introduction to Advection in 1-D","title":"Exercises","text":"","category":"section"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"It is possible use the product derivative rule to replace ucdotpu^prime=½(u^2)^prime in advection equation, what is known as its conservative form. How would you implement this in Julia and what are the implications of this on solution in terms of space and time discretization? Provide some numerical examples.","category":"page"},{"location":"Learning/TransportPhenomena/001-advection-1d/","page":"Introduction to Advection in 1-D","title":"Introduction to Advection in 1-D","text":"For playing with the code, please find a Pluto notebook here.","category":"page"},{"location":"#DryTooling.jl","page":"Home","title":"DryTooling.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DryTooling.","category":"page"},{"location":"#Why?","page":"Home","title":"Why?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I am often faced with using the same approach for different engineering and scientific problems, but I don't like repeating the same task again and again. This is where DryTooling.jl comes in. By adopting some principles of DRY in Julia, to a larger extent than its definition, it packages together models and workflows that are not available or validated elsewhere - and in some cases adapts existing models. The tools will progressively cover a broad range of numerical applications and data treatment, this package is in its early days from the migration of my old Python scripts and packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also dry tooling is my favorite sport!","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The base case for using DryTooling is calling a pre-built model for solving a specific problem. Several sub-modules handle different Physics and find them in the side-bar. Most models are provided under structures that are already solved during construction or provide a solve! method. In an ideal world they should all be documented, but since this package is still in its early days, some experimental features are not yet documented.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For extending existing models and preferrably contributing to the package's growth, it is possible to use some functionalities provided in the bare DryTooling module, i.e. those made available when calling using DryTooling. They include physical constants, abstract types used all across the package, and some simple functions of general use.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Found it useful? See CITATION.bib for the relevant reference.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":" \nQuestions and proposals Zulip Chat\nFound and error or bug Create and issue","category":"page"},{"location":"Learning/#Learning-resources","page":"Learning","title":"Learning resources","text":"","category":"section"}]
}
