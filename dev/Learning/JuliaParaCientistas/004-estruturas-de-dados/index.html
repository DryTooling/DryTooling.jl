<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parte 4 - Estruturas de dados II · DryTooling.jl</title><meta name="title" content="Parte 4 - Estruturas de dados II · DryTooling.jl"/><meta property="og:title" content="Parte 4 - Estruturas de dados II · DryTooling.jl"/><meta property="twitter:title" content="Parte 4 - Estruturas de dados II · DryTooling.jl"/><meta name="description" content="Documentation for DryTooling.jl."/><meta property="og:description" content="Documentation for DryTooling.jl."/><meta property="twitter:description" content="Documentation for DryTooling.jl."/><meta property="og:url" content="https://DryTooling.github.io/DryTooling.jl/Learning/JuliaParaCientistas/004-estruturas-de-dados/"/><meta property="twitter:url" content="https://DryTooling.github.io/DryTooling.jl/Learning/JuliaParaCientistas/004-estruturas-de-dados/"/><link rel="canonical" href="https://DryTooling.github.io/DryTooling.jl/Learning/JuliaParaCientistas/004-estruturas-de-dados/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">DryTooling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Core</span><ul><li><a class="tocitem" href="../../../DryToolingCore/">DryToolingCore</a></li><li><a class="tocitem" href="../../../DryToolingCore/abstract/">Abstract types</a></li></ul></li><li><a class="tocitem" href="../../../DryToolingGranular/">Granular</a></li><li><a class="tocitem" href="../../../DryToolingKinetics/">Kinetics</a></li><li><a class="tocitem" href="../../../DryToolingSimulation/">Simulation</a></li><li><a class="tocitem" href="../../../references/">References</a></li><li><span class="tocitem">Validation Studies</span><ul><li><a class="tocitem" href="../../../DryToolingGranular/validation/kramers-model/">Kramers&#39; model</a></li></ul></li><li><a class="tocitem" href="../../../api/">Reference API</a></li><li><a class="tocitem" href="../../../toc/">Table of Contents</a></li><li><a class="tocitem" href="../../../dev/">Developement</a></li><li><span class="tocitem">Learning</span><ul><li><a class="tocitem" href="../../">Learning</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox" checked/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Julia para Cientistas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Julia para Cientistas</a></li><li><a class="tocitem" href="../001-primeiros-passos/">Parte 1 - Primeiros passos</a></li><li><a class="tocitem" href="../002-manipulacao-textual/">Parte 2 - Manipulação textual</a></li><li><a class="tocitem" href="../003-estruturas-de-dados/">Parte 3 - Estruturas de dados I</a></li><li class="is-active"><a class="tocitem" href>Parte 4 - Estruturas de dados II</a><ul class="internal"><li><a class="tocitem" href="#*Arrays*"><span><em>Arrays</em></span></a></li><li><a class="tocitem" href="#*Ranges*"><span><em>Ranges</em></span></a></li><li><a class="tocitem" href="#Atribuição-de-tipos"><span>Atribuição de tipos</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Transport Phenomena</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../TransportPhenomena/">Transport Phenomena</a></li><li><a class="tocitem" href="../../TransportPhenomena/001-advection-1d/">Introduction to Advection in 1-D</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Learning</a></li><li><a class="is-disabled">Julia para Cientistas</a></li><li class="is-active"><a href>Parte 4 - Estruturas de dados II</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parte 4 - Estruturas de dados II</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DryTooling/DryTooling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/DryTooling/DryTooling.jl/blob/main/docs/src/Learning/JuliaParaCientistas/004-estruturas-de-dados.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Parte-4-Estruturas-de-dados-II"><a class="docs-heading-anchor" href="#Parte-4-Estruturas-de-dados-II">Parte 4 - Estruturas de dados II</a><a id="Parte-4-Estruturas-de-dados-II-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-4-Estruturas-de-dados-II" title="Permalink"></a></h1><p>Neste notebook estudamos a sequência de estruturas de dados básicas iniciada no precedente. O foco aqui são tipos úteis em cálculo numérico e álgebra linear, embora suas aplicação vaiam muito além.</p><h2 id="*Arrays*"><a class="docs-heading-anchor" href="#*Arrays*"><em>Arrays</em></a><a id="*Arrays*-1"></a><a class="docs-heading-anchor-permalink" href="#*Arrays*" title="Permalink"></a></h2><p>A estrutura <code>Array</code> se diferencia de <code>Tuple</code> pelo fato de ser mutável e de <code>Dict</code> pela noção de ordem. Dadas essas características não é surpreendente que seja esse o tipo de base sobre o qual Julia constrói vetores e matrizes, embora um <code>Array</code> seja mais genérico que esses conceitos matemáticos. Podemos, por exemplo, construir um <code>Array</code> contendo sub-<code>Array</code>&#39;s de tamanho variável, o que não constituiria uma matriz. Ou então misturar tipos de dados nos elementos de um <code>Array</code>, como mostramos ser possível com <code>Tuple</code>.</p><p>Em termos de sintaxe, usamos nesse caso colchetes <code>[]</code> para limitar a sequência.</p><p>Considere por exemplo a seguinte lista de países...</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; countries = [&quot;France&quot;, &quot;Brazil&quot;, &quot;Germany&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{String}:
 &quot;France&quot;
 &quot;Brazil&quot;
 &quot;Germany&quot;</code></pre><p>...ou então de números,...</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; numbers = [1, 2, 3.1]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Float64}:
 1.0
 2.0
 3.1</code></pre><p>..., ou simplesmente informações pessoais.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; personal_info = [&quot;Walter&quot;, 34, &quot;Lyon&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Any}:
   &quot;Walter&quot;
 34
   &quot;Lyon&quot;</code></pre><p>O acesso a elementos se faz através de índices, como em <code>Tuple</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; personal_info[2]</code><code class="nohighlight hljs ansi" style="display:block;">34</code></pre><p>Como essa estrutura é mutável ela suporta – <a href="https://docs.julialang.org/en/v1/base/arrays/">entre muitos outros</a> – o método <code>push!()</code> para se adicionar um elemento após o último.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; push!(personal_info, &quot;Engineer&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Any}:
   &quot;Walter&quot;
 34
   &quot;Lyon&quot;
   &quot;Engineer&quot;</code></pre><p>De maneira similar ao que vimos para <code>Dict</code>, uma implementação de <code>pop!()</code> é disponível para o tipo <code>Array</code>, realizando a operação inversa de <code>push!()</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pop!(personal_info)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;Engineer&quot;</code></pre><p>O exemplo de uma <em>não-matriz</em> citado na introdução é apresentado a seguir.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; not_a_matrix = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]</code><code class="nohighlight hljs ansi" style="display:block;">3-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [4, 5]
 [6, 7, 8, 9]</code></pre><p>Usando <code>typeof()</code> descobrimos que se trata de um <code>Vector</code> de <code>Vector</code> e que na verdade Julia usa <code>Vector</code> com um <em>alias</em> para um <code>Array{T, 1}</code>, aonde <code>T</code> denota o tipo de dado.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(not_a_matrix)</code><code class="nohighlight hljs ansi" style="display:block;">Vector{Vector{Int64}}<span class="sgr90"> (alias for Array{Array{Int64, 1}, 1})</span></code></pre><p>A função <a href="https://docs.julialang.org/en/v1/stdlib/Random/#Base.rand"><code>rand()</code></a> pode ser usada para criar uma matriz de números aleatórios – e outras estruturas de ordem superior – como se segue. Observe o tipo <code>Matrix{Float64}</code> indicado.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_matrix = rand(3, 3)</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
 0.149517  0.801339   0.607865
 0.196719  0.395212   0.877675
 0.57763   0.0866805  0.884346</code></pre><p>Repetindo a verificação de tipo como fizemos para of <em>vetor de vetores</em> anteriormente, descobrimos que uma <code>Matrix</code> em Julia não é interpretada da mesma maneira, mas como um <code>Array</code> com duas dimensões. Isso é a forma que a linguagem emprega para assegurar as dimensões constantes segundo cada direção da matriz.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a_matrix)</code><code class="nohighlight hljs ansi" style="display:block;">Matrix{Float64}<span class="sgr90"> (alias for Array{Float64, 2})</span></code></pre><p>Vamos agora atribuir nossa <code>a_matrix</code> à uma outra variável e então modificar a matrix original.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; maybe_another_matrix = a_matrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
 0.149517  0.801339   0.607865
 0.196719  0.395212   0.877675
 0.57763   0.0866805  0.884346</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_matrix[1, 1] = 999</code><code class="nohighlight hljs ansi" style="display:block;">999</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; a_matrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
 999.0       0.801339   0.607865
   0.196719  0.395212   0.877675
   0.57763   0.0866805  0.884346</code></pre><p>Tal como para a <code>Tuple</code> com objetos mutáveis, atribuir um novo nome à uma matriz não cria uma nova matriz, apenas referencia o seu endereço de memória: observamos abaixo que a tentativa de cópia <code>maybe_another_matriz</code> também é modificada em razão da operação sobre <code>a_matrix</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; maybe_another_matrix</code><code class="nohighlight hljs ansi" style="display:block;">3×3 Matrix{Float64}:
 999.0       0.801339   0.607865
   0.196719  0.395212   0.877675
   0.57763   0.0866805  0.884346</code></pre><p>Quando uma cópia da matriz é necessária devemos utilizar <code>copy()</code>. Nas próximas células criamos uma matriz e então uma cópia, a qual é modificada, e verificamos não haver impacto na matriz original, validando a cópia em um novo endereço de memória.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; another_matrix = rand(2, 2)</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 0.643598  0.356127
 0.287893  0.593799</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; again_a_matrix = copy(another_matrix)</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 0.643598  0.356127
 0.287893  0.593799</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; again_a_matrix[1, 2] = 0</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; again_a_matrix</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 0.643598  0.0
 0.287893  0.593799</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; another_matrix</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 0.643598  0.356127
 0.287893  0.593799</code></pre><h2 id="*Ranges*"><a class="docs-heading-anchor" href="#*Ranges*"><em>Ranges</em></a><a id="*Ranges*-1"></a><a class="docs-heading-anchor-permalink" href="#*Ranges*" title="Permalink"></a></h2><p>Julia implementa uma variedade de tipos de <em>ranges</em>, iteradores para enumerações ou números espaçados segundo uma regra definida. Os tipos existentes encontram-se documentados em <a href="https://docs.julialang.org/en/v1/base/collections/">collections</a>. O leitor pode interessar-se também pela função mais genérica <a href="https://docs.julialang.org/en/v1/base/math/#Base.range">range</a> da biblioteca padrão.</p><p>Vamos começar com a declaração de um <code>UnitRange</code> de números 1 à 10 que pode ser construido com a sintaxe simplificada abaixo.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; range_of_numbers = 1:10</code><code class="nohighlight hljs ansi" style="display:block;">1:10</code></pre><p>Confirmamos que trata-se de um <code>UnitRange</code> especializado para o tipo inteiro da arquitetura do computador, 64-bits, tal como o tipo dos elementos usados na construção.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(range_of_numbers)</code><code class="nohighlight hljs ansi" style="display:block;">UnitRange{Int64}</code></pre><p>Essa sintaxe mostrada acima é simplesmente um <em>syntatic sugar</em> para a chamada do construtor padrão deste tipo, como averiguamos na próxima célula.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; UnitRange(1, 10)</code><code class="nohighlight hljs ansi" style="display:block;">1:10</code></pre><p>Uma particularidade da sequência criada é que ela não é expandida na memória, mas tão somente a regra de construção para iteração é definida. Verificamos na próxima célula que esta sequência não possui os elementos que esperaríamos.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; range_of_numbers</code><code class="nohighlight hljs ansi" style="display:block;">1:10</code></pre><p>Isso é fundamental para se permitir laços de tamanhos enormes, frequentes em computação científica; pode-se, por exemplo, criar uma sequência inteira entre 1 e o máximo valor possível para o tipo <code>Int64</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; 1:typemax(Int64)</code><code class="nohighlight hljs ansi" style="display:block;">1:9223372036854775807</code></pre><p>Para se expandir a sequência devemos <em>coletar</em> seus valores com <code>collect</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; arr = collect(range_of_numbers)</code><code class="nohighlight hljs ansi" style="display:block;">10-element Vector{Int64}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10</code></pre><p>O resultado dessa operação é um <code>Vector</code> especializado no tipo usado para a sequência.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(arr)</code><code class="nohighlight hljs ansi" style="display:block;">Vector{Int64}<span class="sgr90"> (alias for Array{Int64, 1})</span></code></pre><p>A inserção de um elemento adicional na sintaxe do tipo <code>start:step:end</code> permite a criação de sequências com um passo determinado. Abaixo usamos um passo de tipo <code>Float64</code> que por razões de precedência numérica vai gerar uma sequência de tipo equivalente, como verificamos no que se segue.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; float_range = 0:0.6:10</code><code class="nohighlight hljs ansi" style="display:block;">0.0:0.6:9.6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(float_range)</code><code class="nohighlight hljs ansi" style="display:block;">StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}</code></pre><p>Acima utilizamos um passo de <code>0.6</code> para ilustrar uma particularidade do tipo <code>StepRangeLen</code> que não inclui o último elemento da sequência caso esse não seja um múltiplo inteiro do passo utilizado, de maneira a assegurar que todos os elementos sejam igualmente espaçados.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; collect(float_range)</code><code class="nohighlight hljs ansi" style="display:block;">17-element Vector{Float64}:
 0.0
 0.6
 1.2
 1.8
 2.4
 3.0
 3.6
 4.2
 4.8
 5.4
 6.0
 6.6
 7.2
 7.8
 8.4
 9.0
 9.6</code></pre><p>Finalmente, Julia provê <code>LinRange</code>, que será bastante útil para aqueles interessados em métodos numéricos de tipo diferenças finitas ou volumes finitos. Criamos um <code>LinRange</code> fornecendo os limites do intervalo e o número de elementos igualmente espaçados a retornar.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; LinRange(1.0, 10.0, 10)</code><code class="nohighlight hljs ansi" style="display:block;">10-element LinRange{Float64, Int64}:
 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0</code></pre><h2 id="Atribuição-de-tipos"><a class="docs-heading-anchor" href="#Atribuição-de-tipos">Atribuição de tipos</a><a id="Atribuição-de-tipos-1"></a><a class="docs-heading-anchor-permalink" href="#Atribuição-de-tipos" title="Permalink"></a></h2><p>Até o momento criamos objetos em Julia sem <em>anotar</em> os tipos de dados requeridos. O compilador de Julia realiza inferência de tipos de maneira bastante avançada para determinar como especializar funções para as entradas dadas. Prover explicitamente tipos, principalmente em interfaces de funções, como veremos no futuro, é altamente recomendável e evita dores de cabeça quanto a validação de um programa quando este ganha em complexidade. Ademais, para computação numérica e aprendizado de máquina, a especificação de tipos tem implicação direta sobre a precisão e performance dos cálculos. É comum, por exemplo, treinar-se redes neurais com dados truncados à <code>Float32</code>, tipo que apresenta performance optimizada nas GPU&#39;s específicas deste ramo, enquanto um cálculo DEM (Discrete Element Method) de colisão de partículas necessida dados <code>Float64</code> (e uma carta gráfica de alto nível adaptada) para prover resultados realistas.</p><p>Em Julia especificamos tipos com a sintaxe <code>a::TipoDeA</code>. Isso é valido para variáveis quaisquer, elementos de estruturas de dados, interfaces de funções, etc. Por exemplo, declaremos a seguinte variável:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a::Float32 = 1</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">Float32</code></pre><p>Anotamos o tipo <code>Float32</code> para a variável <code>a</code>. No entanto o argumento à direita do sinal de atribuição é um inteiro <code>1</code>. Se deixássemos a <em>descoberta</em> de tipos ao compilador, neste caso obteríamos:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = 1</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">Float32</code></pre><p>Esse resultado pode ser indesejável e incompatível com a interface de alguma função aonde desejamos empregar o valor de <code>a</code>.</p><p>Vejamos agora alguns exemplos do impacto no tempo de execução de se prover valores ao lado <em>direito da igualdade</em> adaptados aos tipos esperados na especificação de dados. Vamos usar os <em>ranges</em> que aprendemos logo acima e <code>collect</code> para criar um <code>Vector{Int64}</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A <em>macro</em> <code>@benchmark</code> vai executar o código algumas vezes e retornar estatísticas de execução. Não se preocupe com ela por agora, vamos voltar na temática de <em>benchmarking</em> muito em breve.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using BenchmarkTools, Statistics</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark a::Vector{Int64} = collect(1:10)</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 10000 samples with 996 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">24.706 ns</span></span> … <span class="sgr35"> 16.476 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span> 0.00% … 83.19%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">80.774 ns               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span> 0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">76.699 ns</span></span> ± <span class="sgr32">479.878 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>21.22% ±  3.40%

  █▆                                          <span class="sgr32"> </span>  <span class="sgr34">▂</span>▃▂           
  ██▃▂▂▂▂▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▁▂▁▁▁▁▂▁▁▁▂▁▂▁▁▁▁▁▁▂▁<span class="sgr32">▂</span>▃▆<span class="sgr34">█</span>██▇▅▃▃▂▂▂▂▂▂ ▃
  24.7 ns<span class="sgr90">         Histogram: frequency by time</span>           96 ns <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">144 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">1</span>.</code></pre><p>Vemos que o tempo de execução é da ordem de 30 ns. Abaixo repetimos essa avaliação para algumas ordens de grandeza de tamanho de <em>arrays</em>. Vemos que o tempo de execução para a criação dos objetos escala com o logaritmo na base 10 do número de elementos.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; scalability = [
           mean((@benchmark a::Vector{Int64} = collect(1:10^1)).times)
           mean((@benchmark a::Vector{Int64} = collect(1:10^2)).times)
           mean((@benchmark a::Vector{Int64} = collect(1:10^3)).times)
           mean((@benchmark a::Vector{Int64} = collect(1:10^4)).times)
       ]</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
   76.17186260080645
  374.61105247724976
  775.8575335
 9249.674157142857</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; log10.(scalability)</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Float64}:
 1.8817945753565732
 2.573580586597869
 2.8897819814449077
 3.9661264339014815</code></pre><p>Tentemos agora criar um vetor de <code>Float64</code> usando o mesmo método.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark a::Vector{Float64} = collect(1:10)</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 10000 samples with 981 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1"> 61.042 ns</span></span> … <span class="sgr35"> 16.722 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span> 0.00% … 98.94%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">173.935 ns               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span> 0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">165.082 ns</span></span> ± <span class="sgr32">674.473 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>19.90% ±  4.84%

  █▄▂▁▁                             <span class="sgr32"> </span> ▆<span class="sgr34">█</span>▇▄▂▂                    ▂
  █████▆▆▄▅▆▆▅▅▆███▇▆▆▃▃▃▄▁▄▃▃▁▃▄▁▁▄<span class="sgr32">▃</span>██<span class="sgr34">█</span>██████▇▇▇▅▄▄▁▃▄▁▁▆▆▇█▇█ █
  61 ns<span class="sgr90">         Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>        247 ns <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">288 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">2</span>.</code></pre><p>O tempo de execução mais que dobrou e a memória estimada foi multiplicada por dois! Isso ocorre porque ao lado direito da expressão fornecemos números inteiros e o compilador é <em>obrigado</em> a incluir uma etapa de conversão de tipos, o que adiciona operações e alocações de memória.</p><p>Se na criação do <em>range</em> utilizarmos o tipo esperado de dados voltamos a linha de base da alocação do vetor de inteiros, da ordem de 30 ns e 144 bytes.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @benchmark b::Vector{Float64} = collect(1.0:10.0)</code><code class="nohighlight hljs ansi" style="display:block;">BenchmarkTools.Trial: 10000 samples with 996 evaluations.
 Range <span class="sgr90">(</span><span class="sgr36"><span class="sgr1">min</span></span> … <span class="sgr35">max</span><span class="sgr90">):  </span><span class="sgr36"><span class="sgr1">24.604 ns</span></span> … <span class="sgr35"> 14.416 μs</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>min … max<span class="sgr90">): </span> 0.00% … 94.95%
 Time  <span class="sgr90">(</span><span class="sgr34"><span class="sgr1">median</span></span><span class="sgr90">):     </span><span class="sgr34"><span class="sgr1">80.502 ns               </span></span><span class="sgr90">┊</span> GC <span class="sgr90">(</span>median<span class="sgr90">):    </span> 0.00%
 Time  <span class="sgr90">(</span><span class="sgr32"><span class="sgr1">mean</span></span> ± <span class="sgr32">σ</span><span class="sgr90">):   </span><span class="sgr32"><span class="sgr1">76.165 ns</span></span> ± <span class="sgr32">471.752 ns</span>  <span class="sgr90">┊</span> GC <span class="sgr90">(</span>mean ± σ<span class="sgr90">):  </span>21.30% ±  3.43%

  ▇█▄▁                                        <span class="sgr32"> </span>▂▅<span class="sgr34">▇</span>▇▇▆▅▃▁    ▁  ▂
  █████▇█▆▄▄▅▄▅▅▅▃▅▆▆▄▅▃▁▁▃▁▁▁▄▁▁▃▁▁▁▃▁▁▁▄▁▃▁▁<span class="sgr32">▁</span>██<span class="sgr34">█</span>███████▇████ █
  24.6 ns<span class="sgr90">       Histogram: <span class="sgr1">log(</span>frequency<span class="sgr1">)</span> by time</span>      95.3 ns <span class="sgr1">&lt;</span>

 Memory estimate<span class="sgr90">: </span><span class="sgr33">144 bytes</span>, allocs estimate<span class="sgr90">: </span><span class="sgr33">1</span>.</code></pre><p>Repetimos o <em>benchmark</em> para comparar a criação de vetores de dupla-precisão inicializados por inteiros e números de dupla precisão. Incluímos no novo <em>benchmark</em> um vetor com um único elemento para entendermos um pouco mais do processo.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; with_conversion = let
           scalability = [
               mean((@benchmark a::Vector{Float64} = collect(1:10^0)).times)
               mean((@benchmark a::Vector{Float64} = collect(1:10^1)).times)
               mean((@benchmark a::Vector{Float64} = collect(1:10^2)).times)
               mean((@benchmark a::Vector{Float64} = collect(1:10^3)).times)
               mean((@benchmark a::Vector{Float64} = collect(1:10^4)).times)
           ]
           scalability
       end</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
    81.99645396341464
   166.31434091836735
   792.7350076184945
  1842.5068
 21895.3016</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; without_conversion = let
           scalability = [
               mean((@benchmark a::Vector{Float64} = collect(1.0:10.0^0)).times)
               mean((@benchmark a::Vector{Float64} = collect(1.0:10.0^1)).times)
               mean((@benchmark a::Vector{Float64} = collect(1.0:10.0^2)).times)
               mean((@benchmark a::Vector{Float64} = collect(1.0:10.0^3)).times)
               mean((@benchmark a::Vector{Float64} = collect(1.0:10.0^4)).times)
           ]
           scalability
       end</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
    37.194382228915664
    74.51678130653266
   517.9808881381381
  2131.9956799999995
 20175.715</code></pre><p>O vetor <code>with_conversion</code> contém os tempos de execução para a criação de vetores de 1, 10, 100, 1000 e 10000 elementos com conversão de valores de inteiros para dupla-precisão. Observe que os dois primeiros elementos levaram um tempo (aqui em nano-segundos) quase idênticos: existe uma constante de tempo da criação do vetor propriamente dito, a criação dos 10 primeiros elementos é quase negligível nesse caso.</p><p>Abaixo calculamos a diferença de tempo entre os dois processos e nos deparamos com mais uma surpresa: para 100 elementos, o tempo de alocação COM conversão é MENOR que o tempo SEM conversão. Ainda é muito cedo e fora de contexto para entrarmos no código LLVM gerado por Julia para entendermos a razão dessa <em>anomalia</em>. O importante a reter aqui é que para vetores de tamanhos importantes (&gt; 1000 elementos) um tempo adicional de execução é adicionado por elemento e isso deve ser levado em conta quando escrevendo código científico.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; time_diff = (without_conversion - with_conversion)</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
   -44.80207173449897
   -91.79755961183469
  -274.7541194803564
   289.4888799999994
 -1719.5865999999987</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; time_diff_per_element = time_diff ./ [10^k for k = 0:4]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 -44.80207173449897
  -9.179755961183469
  -2.747541194803564
   0.28948887999999945
  -0.17195865999999987</code></pre><p>Espero que a decisão de incluir essas divagações um pouco cedo no aprendizado não sejam deletérias para a motivação do estudante, mas que criem curiosidade quanto aos tópicos mais avançados que veremos mais tarde.</p><p>Ainda falta muito para se concluir a introdução à atribuição de tipos, mas esse primeiro contato era necessário para que as próximos tópicos avancem de maneira mais fluida.</p><p>Isso é tudo para esta sessão de estudo! Até a próxima!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../003-estruturas-de-dados/">« Parte 3 - Estruturas de dados I</a><a class="docs-footer-nextpage" href="../../TransportPhenomena/">Transport Phenomena »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Monday 20 November 2023 07:02">Monday 20 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
