<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parte 3 - Estruturas de dados I · DryTooling.jl</title><meta name="title" content="Parte 3 - Estruturas de dados I · DryTooling.jl"/><meta property="og:title" content="Parte 3 - Estruturas de dados I · DryTooling.jl"/><meta property="twitter:title" content="Parte 3 - Estruturas de dados I · DryTooling.jl"/><meta name="description" content="Documentation for DryTooling.jl."/><meta property="og:description" content="Documentation for DryTooling.jl."/><meta property="twitter:description" content="Documentation for DryTooling.jl."/><meta property="og:url" content="https://DryTooling.github.io/DryTooling.jl/Learning/JuliaParaCientistas/003-estruturas-de-dados/"/><meta property="twitter:url" content="https://DryTooling.github.io/DryTooling.jl/Learning/JuliaParaCientistas/003-estruturas-de-dados/"/><link rel="canonical" href="https://DryTooling.github.io/DryTooling.jl/Learning/JuliaParaCientistas/003-estruturas-de-dados/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">DryTooling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Core</span><ul><li><a class="tocitem" href="../../../DryToolingCore/">DryToolingCore</a></li><li><a class="tocitem" href="../../../DryToolingCore/abstract/">Abstract types</a></li></ul></li><li><a class="tocitem" href="../../../DryToolingGranular/">Granular</a></li><li><a class="tocitem" href="../../../DryToolingKinetics/">Kinetics</a></li><li><a class="tocitem" href="../../../DryToolingSimulation/">Simulation</a></li><li><a class="tocitem" href="../../../references/">References</a></li><li><span class="tocitem">Validation Studies</span><ul><li><a class="tocitem" href="../../../DryToolingGranular/validation/kramers-model/">Kramers&#39; model</a></li></ul></li><li><a class="tocitem" href="../../../api/">Reference API</a></li><li><a class="tocitem" href="../../../toc/">Table of Contents</a></li><li><a class="tocitem" href="../../../dev/">Developement</a></li><li><span class="tocitem">Learning</span><ul><li><a class="tocitem" href="../../">Learning</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox" checked/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Julia para Cientistas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Julia para Cientistas</a></li><li><a class="tocitem" href="../001-primeiros-passos/">Parte 1 - Primeiros passos</a></li><li><a class="tocitem" href="../002-manipulacao-textual/">Parte 2 - Manipulação textual</a></li><li class="is-active"><a class="tocitem" href>Parte 3 - Estruturas de dados I</a><ul class="internal"><li><a class="tocitem" href="#*Tuples*"><span><em>Tuples</em></span></a></li><li><a class="tocitem" href="#*Named-tuples*"><span><em>Named tuples</em></span></a></li><li><a class="tocitem" href="#Dicionários"><span>Dicionários</span></a></li></ul></li><li><a class="tocitem" href="../004-estruturas-de-dados/">Parte 4 - Estruturas de dados II</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Transport Phenomena</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../TransportPhenomena/">Transport Phenomena</a></li><li><a class="tocitem" href="../../TransportPhenomena/001-advection-1d/">Introduction to Advection in 1-D</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Learning</a></li><li><a class="is-disabled">Julia para Cientistas</a></li><li class="is-active"><a href>Parte 3 - Estruturas de dados I</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parte 3 - Estruturas de dados I</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DryTooling/DryTooling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/DryTooling/DryTooling.jl/blob/main/docs/src/Learning/JuliaParaCientistas/003-estruturas-de-dados.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Parte-3-Estruturas-de-dados-I"><a class="docs-heading-anchor" href="#Parte-3-Estruturas-de-dados-I">Parte 3 - Estruturas de dados I</a><a id="Parte-3-Estruturas-de-dados-I-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-3-Estruturas-de-dados-I" title="Permalink"></a></h1><p>Nesta seção vamos estudar alguns tipos de estruturas de dados. Essas formas <em>compostas</em> são construídas sobre elementos que já vimos mas podem também ir além destes. Abordaremos apenas as características básicas de cada uma das estruturas apresentadas e os casos de aplicação se tornarão evidentes. Os diversos métodos comuns à essas coleções é descrito <a href="https://docs.julialang.org/en/v1/base/collections/">nesta página</a>.</p><h2 id="*Tuples*"><a class="docs-heading-anchor" href="#*Tuples*"><em>Tuples</em></a><a id="*Tuples*-1"></a><a class="docs-heading-anchor-permalink" href="#*Tuples*" title="Permalink"></a></h2><p>Uma <em>tuple</em> é constituída de uma sequência de elementos, que podem ser de tipos diferentes, declarada entre parêntesis. A característica de base de uma <em>tuple</em> é sua imutabilidade: uma vez declarada, seus elementos não podem ser alterados.</p><div class="admonition is-info"><header class="admonition-header">Já vimos isso antes</header><div class="admonition-body"><p>Voltando a seção aonde realizamos a conversão explícita de tipos acima, você pode verificar que na realidade já utilizamos uma tuple de números indicando as intensidades RGB de uma cor.</p></div></div><p>Declaremos uma sequência fixa de linguagens de programação dadas por seus nomes como <code>Strings</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; languages = (&quot;Julia&quot;, &quot;Python&quot;, &quot;Octave&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(&quot;Julia&quot;, &quot;Python&quot;, &quot;Octave&quot;)</code></pre><p>Inspecionando o tipo desta variável aprendemos mais uma característica importante inerente a definição de <code>Tuple</code> feita acima quanto ao seu caráter imutável: o tipo de uma <code>Tuple</code> inclui individualmente o tipo de cada um de seus elementos. Dito de outra maneira, uma sequência composta de um número definido de objetos de dados tipos caracteriza por ela mesmo um novo tipo de dados.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(languages)</code><code class="nohighlight hljs ansi" style="display:block;">Tuple{String, String, String}</code></pre><p>Os elementos de uma <code>Tuple</code> podem ser acessados por seus índices.</p><div class="admonition is-warning"><header class="admonition-header">Indices em Julia</header><div class="admonition-body"><p>É o momento de mencionar que em Julia a indexação inicia com <code>1</code>.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @show languages[1]</code><code class="nohighlight hljs ansi" style="display:block;">languages[1] = &quot;Julia&quot;
&quot;Julia&quot;</code></pre><p>Vamos tentar modificar o segundo elemento da <code>Tuple</code>.</p><div class="admonition is-success"><header class="admonition-header">Sintaxe de controle de erros</header><div class="admonition-body"><p>Ainda é cedo para entrar nos detalhes, mas aproveite o bloco abaixo para ter um primeiro contato com a gestão de erros em Julia.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; try
           languages[2] = &quot;C++&quot;
       catch err
           println(&quot;Erro: $(err)&quot;)
       end</code><code class="nohighlight hljs ansi" style="display:block;">Erro: MethodError(setindex!, ((&quot;Julia&quot;, &quot;Python&quot;, &quot;Octave&quot;), &quot;C++&quot;, 2), 0x00000000000084c1)</code></pre><p>Existem certas subtilidades que você precisa saber sobre a imutabilidade. Observe o exemplo abaixo, aonde declaramos duas variáveis que são utilizadas para construir uma <code>Tuple</code> e então modificamos uma das variáveis: a <code>Tuple</code> continua com os valores originais do momento da sua construção.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; let
           a = 1
           b = 2
       
           test_tuple = (a, b)
       
           a = 5
           test_tuple
       end</code><code class="nohighlight hljs ansi" style="display:block;">(1, 2)</code></pre><div class="admonition is-danger"><header class="admonition-header">Isso nem sempre é verdade!</header><div class="admonition-body"><p>Se o elemento compondo a <code>Tuple</code> for de um tipo mutável, como é o caso de <code>Array</code>&#39;s, como veremos no que se segue, os elementos desta variável podem ser modificados e impactam a <code>Tuple</code> diretamente. Isso se dá porque neste caso a <code>Tuple</code> conserva a referência ao objeto em questão, e não uma cópia dos valores, como é o caso para tipos de base.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; let
           a = 1
           b = [1, 2]
       
           test_tuple = (a, b)
       
           b[1] = 999
           test_tuple
       end</code><code class="nohighlight hljs ansi" style="display:block;">(1, [999, 2])</code></pre><h2 id="*Named-tuples*"><a class="docs-heading-anchor" href="#*Named-tuples*"><em>Named tuples</em></a><a id="*Named-tuples*-1"></a><a class="docs-heading-anchor-permalink" href="#*Named-tuples*" title="Permalink"></a></h2><p>Esta extensão à <code>Tuples</code> adiciona a possibilidade de acesso aos componentes por um <em>nome</em> no lugar de um simples índice – que continua funcional como veremos abaixo. Esse tipo de estrutura é bastante útil quando necessitamos criar abstrações de coisas bastante simples para as quais a criação de um novo tipo não se justifica. Discutiremos mais tarde quando vamos estudar a criação de <em>novos tipos</em>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; named_languages = (julia = &quot;Julia&quot;, python = &quot;Python&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">(julia = &quot;Julia&quot;, python = &quot;Python&quot;)</code></pre><p>Observe o fato de que agora os nomes utilizados no índex fazem parte do tipo.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(named_languages)</code><code class="nohighlight hljs ansi" style="display:block;">NamedTuple{(:julia, :python), Tuple{String, String}}</code></pre><p>Abaixo verificamos que além do acesso por nomes, <code>NamedTuples</code> também respeitam a ordem de declaração dos elementos: <code>:julia</code> é o primeiro índice. A sintaxe de acesso aos elementos neste caso é com a notação típica utilizando um ponto, comum a diversas linguages de programação.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; named_languages[1] == named_languages.julia</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><h2 id="Dicionários"><a class="docs-heading-anchor" href="#Dicionários">Dicionários</a><a id="Dicionários-1"></a><a class="docs-heading-anchor-permalink" href="#Dicionários" title="Permalink"></a></h2><p>Objetos do tipo <code>Dict</code> possuem a similaridade com <code>NamedTuples</code> em que seus elementos podem ser acessados por nome. No entanto a sintaxe é diferente e os valores desta estrutura são mutáveis.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; organs = Dict(&quot;brain&quot; =&gt; &quot;🧠&quot;, &quot;heart&quot; =&gt; &quot;❤&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{String, String} with 2 entries:
  &quot;brain&quot; =&gt; &quot;🧠&quot;
  &quot;heart&quot; =&gt; &quot;❤&quot;</code></pre><p>O acesso a elementos se faz com colchetes contendo o índex como se segue:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; organs[&quot;brain&quot;]</code><code class="nohighlight hljs ansi" style="display:block;">&quot;🧠&quot;</code></pre><p>E como dissemos, os elementos são mutáveis: vamos atribuir um burrito ao cérebro.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; organs[&quot;brain&quot;] = &quot;🌯&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;🌯&quot;</code></pre><p>Não só os elementos, mas o dicionário como um todo, pode ser alterado. Para adicionar novos elementos simplesmente <em>acessamos</em> a palavra-chave e atribuímos um valor:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; organs[&quot;eyes&quot;] = &quot;👀&quot;</code><code class="nohighlight hljs ansi" style="display:block;">&quot;👀&quot;</code></pre><p>Internamente para evitar nova alocação de memória a cada tentativa de se adicionar um novo elemento, um dicionário realiza a alocação de <code>slots</code> que são renovados cada vez que sua capacidade é ultrapassada. Observe que a lista retornada abaixo é composta majoritariamente de <code>0x00</code>, que é o endereço de memória nulo, enquanto 3 elementos indicam um valor não-nulo, correspondendo aos elementos já adicionados ao dicionário. Disto vemos que adicionalmente um dicionário não preserva necessariamente uma sequência ordenada. Esses detalhes ultrapassam o presente escopo mas vão abrindo as portas para assuntos mais complexos.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; organs.slots</code><code class="nohighlight hljs ansi" style="display:block;">16-element Vector{UInt8}:
 0x00
 0x00
 0x00
 0x00
 0x00
 0x00
 0xf9
 0x00
 0x00
 0x00
 0x00
 0xe4
 0x00
 0xeb
 0x00
 0x00</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; organs</code><code class="nohighlight hljs ansi" style="display:block;">Dict{String, String} with 3 entries:
  &quot;brain&quot; =&gt; &quot;🌯&quot;
  &quot;heart&quot; =&gt; &quot;❤&quot;
  &quot;eyes&quot;  =&gt; &quot;👀&quot;</code></pre><p>Para remover elementos utilizamos a função <code>pop!</code>. Por convenção em Julia, funções que terminam por um ponto de exclamação modificam os argumentos que são passados. No caso de <code>pop!</code> o dicionário é modificado e o valor de retorno é aquele do elemento removido.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; pop!(organs, &quot;brain&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">&quot;🌯&quot;</code></pre><p>A tentativa de remover um elemento inexistente obviamente conduz à um erro:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; try
           pop!(organs, &quot;leg&quot;)
       catch err
           println(&quot;Erro: $(err)&quot;)
       end</code><code class="nohighlight hljs ansi" style="display:block;">Erro: KeyError(&quot;leg&quot;)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; organs</code><code class="nohighlight hljs ansi" style="display:block;">Dict{String, String} with 2 entries:
  &quot;heart&quot; =&gt; &quot;❤&quot;
  &quot;eyes&quot;  =&gt; &quot;👀&quot;</code></pre><p>Para evitar essa possibilidade podemos usar a função <code>haskey()</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; haskey(organs, &quot;liver&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>Uma última coisa a notar é que <em>praticamente</em> qualquer tipo básico pode ser empregado como a chave de um dicionário em Julia. Veja o exemplo à seguir:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; music = Dict(:violin =&gt; &quot;🎻&quot;, 1 =&gt; 2)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Any, Any} with 2 entries:
  :violin =&gt; &quot;🎻&quot;
  1       =&gt; 2</code></pre><p>Como as chaves são de tipos diferentes (um <code>Symbol</code> e um <code>Int64</code>), assim como os valores (uma <code>String</code> e um <code>Int64</code>), a função <code>typeof()</code> nos retorna tipos <code>Any</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(music)</code><code class="nohighlight hljs ansi" style="display:block;">Dict{Any, Any}</code></pre><p>Ainda nos restam alguns detalhes e tipos de dados, mas o tutorial começa a ficar longo... e não queremos te perder por aqui!</p><p>Isso é tudo para esta sessão de estudo! Até a próxima!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../002-manipulacao-textual/">« Parte 2 - Manipulação textual</a><a class="docs-footer-nextpage" href="../004-estruturas-de-dados/">Parte 4 - Estruturas de dados II »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Monday 20 November 2023 07:02">Monday 20 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
