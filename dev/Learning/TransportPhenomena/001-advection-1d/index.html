<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to Advection in 1-D · DryTooling.jl</title><meta name="title" content="Introduction to Advection in 1-D · DryTooling.jl"/><meta property="og:title" content="Introduction to Advection in 1-D · DryTooling.jl"/><meta property="twitter:title" content="Introduction to Advection in 1-D · DryTooling.jl"/><meta name="description" content="Documentation for DryTooling.jl."/><meta property="og:description" content="Documentation for DryTooling.jl."/><meta property="twitter:description" content="Documentation for DryTooling.jl."/><meta property="og:url" content="https://DryTooling.github.io/DryTooling.jl/Learning/TransportPhenomena/001-advection-1d/"/><meta property="twitter:url" content="https://DryTooling.github.io/DryTooling.jl/Learning/TransportPhenomena/001-advection-1d/"/><link rel="canonical" href="https://DryTooling.github.io/DryTooling.jl/Learning/TransportPhenomena/001-advection-1d/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">DryTooling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Core</span><ul><li><a class="tocitem" href="../../../DryToolingCore/">DryToolingCore</a></li><li><a class="tocitem" href="../../../DryToolingCore/abstract/">Abstract types</a></li></ul></li><li><a class="tocitem" href="../../../DryToolingGranular/">Granular</a></li><li><a class="tocitem" href="../../../DryToolingKinetics/">Kinetics</a></li><li><a class="tocitem" href="../../../DryToolingSimulation/">Simulation</a></li><li><a class="tocitem" href="../../../references/">References</a></li><li><span class="tocitem">Validation Studies</span><ul><li><a class="tocitem" href="../../../DryToolingGranular/validation/kramers-model/">Kramers&#39; model</a></li></ul></li><li><a class="tocitem" href="../../../api/">Reference API</a></li><li><a class="tocitem" href="../../../toc/">Table of Contents</a></li><li><a class="tocitem" href="../../../dev/">Developement</a></li><li><span class="tocitem">Learning</span><ul><li><a class="tocitem" href="../../">Learning</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Julia para Cientistas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../JuliaParaCientistas/">Julia para Cientistas</a></li><li><a class="tocitem" href="../../JuliaParaCientistas/001-primeiros-passos/">Parte 1 - Primeiros passos</a></li><li><a class="tocitem" href="../../JuliaParaCientistas/002-manipulacao-textual/">Parte 2 - Manipulação textual</a></li><li><a class="tocitem" href="../../JuliaParaCientistas/003-estruturas-de-dados/">Parte 3 - Estruturas de dados I</a></li><li><a class="tocitem" href="../../JuliaParaCientistas/004-estruturas-de-dados/">Parte 4 - Estruturas de dados II</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox" checked/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Transport Phenomena</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Transport Phenomena</a></li><li class="is-active"><a class="tocitem" href>Introduction to Advection in 1-D</a><ul class="internal"><li><a class="tocitem" href="#Required-tools"><span>Required tools</span></a></li><li><a class="tocitem" href="#Advection-fundamentals"><span>Advection fundamentals</span></a></li><li><a class="tocitem" href="#Program-structure"><span>Program structure</span></a></li><li><a class="tocitem" href="#Linear-advection"><span>Linear advection</span></a></li><li><a class="tocitem" href="#Problem-statement"><span>Problem statement</span></a></li><li><a class="tocitem" href="#Solve-linear-advection"><span>Solve linear advection</span></a></li><li><a class="tocitem" href="#Nonlinear-advection"><span>Nonlinear advection</span></a></li><li><a class="tocitem" href="#Solve-nonlinear-advection"><span>Solve nonlinear advection</span></a></li></ul></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Learning</a></li><li><a class="is-disabled">Transport Phenomena</a></li><li class="is-active"><a href>Introduction to Advection in 1-D</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction to Advection in 1-D</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DryTooling/DryTooling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/DryTooling/DryTooling.jl/blob/main/docs/src/Learning/TransportPhenomena/001-advection-1d.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction-to-Advection-in-1-D"><a class="docs-heading-anchor" href="#Introduction-to-Advection-in-1-D">Introduction to Advection in 1-D</a><a id="Introduction-to-Advection-in-1-D-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-Advection-in-1-D" title="Permalink"></a></h1><p>Advection is one of the terms present in the Navier-Stokes equations; it describes the transport of a quantity induced by a vector field. The choice to start with this topic rather than diffusion or the Poisson equation is mainly justified by the simple computational implementation in the explicit form of this equation using an <em>upwind</em> scheme. In what follows we will first address the linear and subsequently nonlinear form of advection. To conclude the chapter, we will perform a numerical stability analysis of the problem.</p><p>The general goals of this study can be summarized as:</p><ol><li>Learn advection both in PDE and numerical perspectives.</li><li>Implement a set of tools to solve advection equation.</li><li>Provide post-processing for standard visualization of results.</li><li>Learn the basics of numerical stability analysis.</li></ol><h2 id="Required-tools"><a class="docs-heading-anchor" href="#Required-tools">Required tools</a><a id="Required-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Required-tools" title="Permalink"></a></h2><p>Once the goals have been set, we should already be able to guess the base set of tools required for their achievement. Below we specify the logic behind our choices.</p><ol><li><p>Since Julia is a language conceived for scientific computing, all the tooling for the implementation of the equations in a vectorized form is already available, so we do not need any further packages for now. </p></li><li><p>In this study, to ensure the physical consistency of derived equations and their correct implementation, we will provide numerical values with units through <em>u-strings</em> provided by package <a href="https://painterqubits.github.io/Unitful.jl/stable/"><code>Unitful</code></a>.</p></li><li><p>For all the visualizations we will make use of <a href="https://docs.makie.org/stable/"><code>CairoMakie</code></a>.</p></li></ol><div class="admonition is-warning"><header class="admonition-header">Beware!</header><div class="admonition-body"><p>Using units could represent some overhead in large scale problems. It is important to keep the code compatible with purely numerical values when implementing packages.</p></div></div><p>The following block import the required packages:</p><pre><code class="language-julia hljs">using Unitful
using CairoMakie</code></pre><h2 id="Advection-fundamentals"><a class="docs-heading-anchor" href="#Advection-fundamentals">Advection fundamentals</a><a id="Advection-fundamentals-1"></a><a class="docs-heading-anchor-permalink" href="#Advection-fundamentals" title="Permalink"></a></h2><p>Advection in one dimension is the phenomenon describing the evolution of a quantity <span>$u$</span> transported across a field of constant velocity <span>$c$</span>. Also notice that the quantity <span>$u$</span> may be the velocity field itself in a more general framework we will deal with laterm leading to the nonlinear form of advection equation. Transport is expressed in time and space as <span>$u(x,t+\Delta{}t)=u(x-c\Delta{}t,t)$</span>. That indicates simply that the state at <span>${x}-{c}\Delta{t}$</span> will be found at position <span>$x$</span> after a time interval <span>$\Delta{}t$</span>, <em>i.e.</em> for a constante velocity field <span>$c$</span> the profile <span>$u$</span> is invariant. For a very short time interval <span>$\Delta{}t$</span> with respect to system length <span>$L$</span> and velocity <span>$c$</span>, <em>i.e</em> <span>$\Delta{}t\ll{}c^{-1}L$</span>, this expression can be expanded as a Taylor series and one can derive the following equation:</p><p class="math-container">\[u(x,t)+\Delta{}t\dfrac{du}{dt}
\simeq{}
u(x,t)-c\Delta{}t\dfrac{du}{dx}
\implies{}
\dfrac{\partial{}u}{\partial{}t}+c\dfrac{\partial{}u}{\partial{}x}=0\]</p><p>Under these conditions, the above equation has a trivial analytical solution that can be found <em>e.g.</em> by the method of characteristics, what is outside our scope here. Consider the initial condition <span>$u_{0}:=u(x,0)$</span> (the subscript indicates the initial instant). The transport produced by the field <span>${c}$</span> can be expressed in terms of this initial condition as <span>$u(x,t)=u_{0}(x-ct)$</span>. This result is important for the study of numerical methods because it allows for validation of implemented programs.</p><p>Since our goal is the introduction to the computational aspects only, we skip a detailed numerical analyses showing that centered in space schemes are not suitable for the computation of space derivatives applied to advection equation since they exhibit an <em>unconditionally unstable</em> behavior. The origin of unstability of some of these is is quite understandable from a physical standpoint. <em>Information</em> is travelling along the velocity field, and any <em>information</em> in front of the traveling wave cannot have any <em>knowledge</em> on the prior shape of the wave. That is why so-called <em>upwind</em> schemes are suitable for numerical computation of advection. In such family of schemes, the <em>information</em> coming from the origin of the advecting flow is used to evaluate the upcoming wave position, <em>i.e.</em> for <span>$c&gt;0$</span> the solution at <span>$x$</span> is computed from the solution at <span>$x-\Delta{}x$</span>, thus the reason why it is called upwind, here <span>$\Delta{}x$</span> is a <em>finite</em> variation over coordinate <span>$x$</span>. It can be shown through a Taylor series expansion truncated at first order that</p><p class="math-container">\[\dfrac{\partial{}u}{\partial{}x}\approx
\dfrac{u(x)-u(x-\delta{}x)}{\delta{}x}+\mathcal{O}{\delta{}x}\]</p><div class="admonition is-info"><header class="admonition-header">Upwind advection scheme</header><div class="admonition-body"><p>The above expression is quite intuitive. Let&#39;s see how would it be implemented as Julia code. Supose you have an array of solution <code>u</code> at each of the discrete space points <code>x</code>. Since points are spaced by <span>$\Delta{}x$</span>, represented in code as <code>Δx</code>  , then taking the difference between  consecutive values of <code>u</code> is equivalent to the upwind scheme as follows:</p><pre><code class="language-julia hljs">dudx = (u[2:end] - u[1:end-1]) / Δx;</code></pre><p>Remember that indices in Julia start at 1, not at 0 as in Python or C++.</p></div></div><p>Other higher order expansions are available in the literature, but they are not well-suited for an introductory course on numerical implementation of the solution of PDE&#39;s, so we stick with this low order approximation in what follows. An analogous expansion can be performed for the time derivative of the advection equation. Notice that for time the expansion is performed towards the <em>future</em>. This leads to the following space-time discretization to the problem</p><p class="math-container">\[\frac{u(t+\Delta{}t)-u(t)}{\Delta{}t}+c\frac{u(x)-u(x-\Delta{}x)}{\Delta{}x}=0\]</p><p>This approximate representation of the advection PDE is difficult to read and distant from what it would look in a computer, where it can be represented through indexed arrays or matrices. It is common in the FDM to use subscripts for denoting space indices, and superscript for time-steps. This way we translate <span>$t+\Delta{}t$</span> as <span>$n+1$</span>, where <span>$n$</span> is the time-step number, and <span>$x-\Delta{}x$</span> becomes <span>$i-1$</span>, where <span>$i$</span> is the index of the FDM space coordinate node. Also it is useful to maker shorthands <span>$\tau=\Delta{}t$</span> and <span>$\delta=\Delta{}x$</span>. The equation becomes</p><p class="math-container">\[\frac{u_{i}^{n+1}-u_{i}^n}{\tau}+c\frac{u_{i}^n-u_{i-1}^n}{\delta}=0\]</p><p>Our goal of approaching the equation to the computer implementation format has been reached. So far we are only considering fixed time-steps <span>$\tau$</span> and internodal distances <span>$\delta$</span>, and constant advection velocity <span>$c$</span>. Since problem initial state is <em>a priori</em> knowledge for PDE integration, at <span>$n=0$</span> and <span>$\forall{}i$</span> we dispose of the state <span>$u_{i}^{n}=u_{i}^{0}$</span>, so the only unknown in the above equation is <span>$u_{i}^{n+1}$</span>, for which it can be solved</p><p class="math-container">\[u_{i}^{n+1}=(1-\alpha)u_{i}^{n}+\alpha{}u_{i-1}^n\]</p><p>Such approximation that makes use of current state to predict a future one is called an <em>explicit</em> time-stepping scheme and has been implied without explanation in the above discretization approach. With this expression we have the complete mathematical tooling to solve the simplest advection equation. Notice that for <span>$c&lt;0$</span> the direction of the upwind space derivative would change and the solution becomes <span>$u_{i}^{n+1}=(1+\alpha)u_{i}^{n}-\alpha{}u_{i+1}^n$</span>.</p><p>Now suppose we want to solve advection of a given wave over a 1-D space domain. The discrete solution derived above provides most information we need to gather before starting to develop a computer solution, but it says nothing about the sizes of discrete steps <span>$\tau$</span> and <span>$\delta$</span>. For now we rely only on the mathematical background we have on Taylor series expansion to think about it, and we postpone the methods of computing suitable steps for later.</p><p>With this formulation we are ready to start sketching a numerical solver.</p><h2 id="Program-structure"><a class="docs-heading-anchor" href="#Program-structure">Program structure</a><a id="Program-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Program-structure" title="Permalink"></a></h2><p>In what follows we focus on the computer implementation of the problem.</p><p>So let&#39;s again sketch some goals for our program:</p><ol><li>It must handle both linear and nonlinear 1-D advection equations.</li><li>It must provide a reusable time-stepping function for integration.</li><li>It must provide standardized post-processing utilities.</li></ol><p>Because we are seeking generality to solve a whole class of problems, <em>i.e.</em> any type of 1-D advection problem it is interesting considering the use of abstract types. These are used to structure a hierarchy of problems. Abstract types in Julia do not really have arguments, as it is possible in other languages. They simply provide a name and associated methods. Notice that because of this, when inheriting from abstract types, it is important to make sure the new structures are compatible with the base methods, that they provide the required arguments. So we start with the definition of an abstract type for all of the advection equations we might implement here:</p><pre><code class="language-julia hljs">abstract type AbstractAdvection end</code></pre><p>!!! info  &quot;Real world cases&quot;</p><pre><code class="nohighlight hljs">Previously, by hierarchy we meant models that can be a subset of larger
scope models. In a library implementation you might find something as:

```julia
abstract type AbstractModel end

abstract type AbstractPhysicalModel &lt;: AbstractModel end
abstract type AbstractODEModel &lt;: AbstractPhysicalModel end
abstract type AbstractPDEModel &lt;: AbstractPhysicalModel end
abstract type AbstractKinetics &lt;: AbstractODEModel end
abstract type AbstractAdvection &lt;: AbstractPDEModel end
abstract type AbstractAdvection1D &lt;: AbstractAdvection end
abstract type AbstractAdvection2D &lt;: AbstractAdvection end

struct LinearAdvection1D &lt;: AbstractAdvection1D end
struct NonlinearAdvection1D &lt;: AbstractAdvection1D end
```</code></pre><p>The solution loop is straightforward: we store the current state and solve over the same array the next time solution, what constitutes a simple explicit <em>Euler</em> time-stepping scheme. Since Julia supports vectorized operations we use the slice syntax to evaluate <span>$(1-\alpha)u_{i}^{n}+\alpha{}u_{i-1}^n$</span> and attribute it elementwise to <span>$u_{i}^{n+1}$</span>. Notice that element <code>u[1]</code> is never updated here, think for a moment what are the implications of this.</p><pre><code class="language-julia hljs">function integrate!(p::AbstractAdvection)::Nothing
    for (k, t) in enumerate(p.t[1:end-1])
        # Uncomment below to check correct stepping:
        # @info &quot;Advancing from ``t to ``(p.t[k+1])&quot;
        p.M[k, :] = copy(ustrip(p.u))
        step!(p)
    end

    p.M[end, :] = copy(ustrip(p.u))
    return nothing
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">integrate! (generic function with 1 method)</code></pre><p><strong>Note:</strong> method <code>ustrip</code> from <code>Uniful</code> was used to remove units from arrays before plotting because their rendering is not converted to <span>$\LaTeX$</span> in axes.</p><pre><code class="language-julia hljs">function plotstate(p::AbstractAdvection)::Figure
    x = ustrip(p.x)
    u₀ = p.M[1, 1:end]
    u₁ = p.M[end, 1:end]

    fig = Figure(resolution = (700, 500))
    ax = Axis(fig[1, 1])
    l1 = lines!(ax, x, u₀; linewidth = 3)
    l2 = lines!(ax, x, u₁; linewidth = 3)
    ax.title = &quot;Initial and final states of problem&quot;
    ax.xlabel = &quot;Coordinate [m]&quot;
    ax.ylabel = &quot;Velocity [m/s]&quot;
    xlims!(ax, extrema(x))
    axislegend(ax, [l1, l2], [&quot;Initial&quot;, &quot;Final&quot;], &quot;States&quot;,
               position = :lt, orientation = :vertical)
    return fig
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">plotstate (generic function with 1 method)</code></pre><p>It is also interesting to provide a function to visualize space solution over time. This is the job of a <a href="https://en.wikipedia.org/wiki/Kymograph">kymograph</a>, which is provided below.</p><p>Because they will be reused several times in this chapter, we wrap the kymograph and comparison plotting in the functions given below. It is generally a good idea to follow some <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY directives</a>, but care must be take not to create new methods for simple one-liners, which could become hard to maintain later.</p><pre><code class="language-julia hljs">function kymograph(p::AbstractAdvection; xticks, yticks, zticks)::Figure
    colormap = :gnuplot2
    colorrange = extrema(zticks)

    x = ustrip(p.x)
    y = ustrip(p.t)
    z = transpose(p.M)

    fig = Figure(resolution = (700, 600))
    ax = Axis(fig[2, 1], xlabel = &quot;Coordinate [m]&quot;, ylabel = &quot;Time [s]&quot;)
    hm = heatmap!(ax, x, y, z; colormap, interpolate = true, colorrange)
    cb = Colorbar(fig[1, 1], hm, vertical = false, label = &quot;Velocity [m/s]&quot;)

    ax.xticks = xticks
    ax.yticks = yticks
    xlims!(ax, extrema(ax.xticks.val))
    ylims!(ax, extrema(ax.yticks.val))

    cb.ticks = zticks
    cb.limits = extrema(zticks)
    return fig
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">kymograph (generic function with 1 method)</code></pre><h2 id="Linear-advection"><a class="docs-heading-anchor" href="#Linear-advection">Linear advection</a><a id="Linear-advection-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-advection" title="Permalink"></a></h2><p>Knowing the nodal distance <span>$\delta$</span>, there are many ways of allocating the initial state for <span>$u$</span>, the most computationally efficient being allocating an array with the right number of nodes, them using multiples of <span>$\delta$</span> to attribute the value at each cell. We will not proceed this way here. Instead we provide <code>ranges</code> representing both space and time nodes. Notice that Julia does not expand these ranges, you need to <code>collect</code> them manully or use them in interation loops.</p><p>Because we need to <em>know</em> the nodal positions to compute initial state, we already collect the vector. The first 5 elements are displayed. By <code>x[1:5]</code> we remember that Julia indexing system starts at <code>1</code> and the slicing <code>1:5</code> includes the last index, what would not be true in Python, for instance.</p><p>For allocating arrays of same shapes, Julia provides the method <code>similar</code>. Since we are using units with our values, that method cannot be used here with array for <span>$x$</span> to allocate the density array <span>$u$</span>, otherwise the result would carray space dimensions. Instead we create a <code>ones</code> array of appropriate numerical type and dimensions and provide it with units carried by <span>$u_{0}$</span>. Notice that this initializes the whole array with the value found in the square wave.</p><p>With all this elements we prepare the solution. We start by computing the constant <span>$\alpha$</span> known as <em>Courant number</em>. Observe that this is a dimensionless number since it results from the product of a velocity by the inverse of a <em>numerical velocity</em>. Depending on the choice of derivative approximations there may be a upper limit for which the numerical integration will be <em>stable</em>. We are not entering in these details yet, for now you can read more about this <a href="https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition">here</a> to get a taste of the numerical analysis to come.</p><p>In the present case we might want to store the solution of all time steps for performing an animation or display a kymograph, what will be the case here. For small to medium sized problems, it is more effecient to allocate the memory for solution storage ahead of time, especially when working with fixed time steps. For larger problems or variable time step size, it is sometimes necessary to allocate memory for part of the solution and from times to times dump current chunk to the disk, or handle a buffer with limited memory.</p><p>Since this is a very simple 1-D problem, we chose to have a matrix will one row per time step, so its dimensions are <span>$n_t\times{}n_x$</span>, as follows.</p><pre><code class="language-julia hljs">struct LinearAdvection1D &lt;: AbstractAdvection
    t::Vector{Unitful.Time}
    x::Vector{Unitful.Length}
    u::Vector{Unitful.Velocity}
    c::Unitful.Velocity
    δ::Unitful.Length
    τ::Unitful.Time
    M::Matrix{Float64}

    function LinearAdvection1D(L, T, c, nₓ, nₜ; init, integ = true)
        δ = L / (nₓ - 1)
        τ = T / (nₜ - 1)
        t = collect(0.0u&quot;s&quot;:τ:T)
        x = collect(0.0u&quot;m&quot;:δ:L)
        u = 0u&quot;m/s&quot; * zeros(Float64, nₓ)
        M = zeros(Float64, (nₜ, nₓ))

        init(x, u)

        obj = new(t, x, u, c, δ, τ, M)
        integ &amp;&amp; integrate!(obj)
        return obj
    end
end</code></pre><pre><code class="language-julia hljs">function step!(p::LinearAdvection1D)::Nothing
    α = p.c * (p.τ / p.δ)
    p.u[2:end] = (1 - α) * p.u[2:end] + α * p.u[1:end-1]
    return nothing
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">step! (generic function with 1 method)</code></pre><h2 id="Problem-statement"><a class="docs-heading-anchor" href="#Problem-statement">Problem statement</a><a id="Problem-statement-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-statement" title="Permalink"></a></h2><p>Consider a hypothetical domain of <span>$L=2.5\:\mathrm{m}$</span> along along <span>$x$</span> axis over which we have initially a wave of an <em>unsoluble substance</em> moving at to <span>$u=1\:\mathrm{m\cdotp{}s^{-1}}$</span> located in interval <span>$x\in[0.5;1.0]\:\mathrm{m}$</span>, being half this value elsewhere. At the starting time, a fluid flow with velocity <span>$c=1\:\mathrm{m\cdotp{}s^{-1}}$</span> is forced through the domain, which is already immersed in the <em>fluid</em>.</p><hr/><p>Determine the mass density <span>$u(x,t)$</span> of the substance for the next <span>$T=1.0\:\mathrm{s}$</span> interval.</p><hr/><p>This problem statement provides all the basic building blocks to implement the solution, which we translate into Julia code as:</p><pre><code class="language-julia hljs"># Domain length.
L = 2.5u&quot;m&quot;

# Time domain.
T = 1.0u&quot;s&quot;

# Fluid velocity.
c = 1.0u&quot;m/s&quot;

# Wave velocity.
u₀ = 1.0u&quot;m/s&quot;

# Initialization function.
init(x, u) = let
    hump = (0.5u&quot;m&quot; .&lt; x) .&amp; (x .&lt; 1.0u&quot;m&quot;)
    u[:]    .= u₀ / 2.0
    u[hump] .= u₀
end</code></pre><p>To modify the regions ouside the peak we create a boolean mask. In Julia, to evaluate a binary operation elementwise, a dot is placed in front of the operator. So here <code>xᵤ[1] .&lt; x</code> means true where elements of <code>x</code> are less than the first element of <code>xᵤ</code>, for instance. Since the mask we created represent the square wave region, we negate the resulting array to set zero elsewhere in the density array <code>u</code>. Also observe the <code>.=</code> notation to attribute results. This vectorized operations supported by Julia avoid the excessive use of loops and result in easier to maintain code.</p><h2 id="Solve-linear-advection"><a class="docs-heading-anchor" href="#Solve-linear-advection">Solve linear advection</a><a id="Solve-linear-advection-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-linear-advection" title="Permalink"></a></h2><p>To remain within the region where the error introduced by the discretization scheme remains <em>small</em>, we need to <em>think</em> what would be a good number of steps and nodes to split our system. Thinking physically, we would not want the density <span>$u$</span> to be transported by more than one node distance <span>$\delta$</span> in a time step <span>$\tau$</span>, otherwise we would be <em>skipping</em> information transfer. Thus, there is some logic constraining <span>$\delta\le{}c\tau$</span> to be respected here. We also have infinite gradients in the specified square wave of mass density, so space step should not be too small otherwise it would lead to a overflow error..., well, there are many other aspects to be considered, but we did not introduce them yet. So let&#39;s just assume that as a rule of thumb <em>both space and time discretization must be reasonably smaller than the integration domains</em>.</p><p>Below we assume this <em>reasonably small</em> criterium is 1/500 the size of the system and compute the required nodal distance and time step. Notice the <code>- 1</code> in the denominator, because the number of intervals between <span>$k$</span> nodes is <span>$k-1$</span>. The computed values are displayed with their respective units.</p><pre><code class="language-julia hljs">nₓ = 101
nₜ = 101
p1 = LinearAdvection1D(L, T, c, nₓ, nₜ; init)</code></pre><p>Below we display a comparison between initial and final states of the advected wave.</p><img src="80b83f24.png" alt="Example block output"/><img src="6541c45f.png" alt="Example block output"/><p>The analytical solution to this problem states that the shape of the density profile should not evolve in time, just its position. In the kymograph above that would mean that the only valid values in the heat map would be those originally in the initial state array. This is not actually what we observe. We get just qualitative agreement between the expected and actual position of our moving hump <span>$u$</span>, which apparently <em>diffused</em> over the domain. And this exaclty what happened, from a numerical standpoint. When we approximated the spacial derivative, we were actually truncating a Taylor series expansion of <span>$u$</span> at the first term, as in:</p><p class="math-container">\[u(x) = u(x-\Delta{}x) + \frac{(\Delta{}x)^{1}}{1!}\frac{\mathrm{d}u}{\mathrm{d}x} +
                        \frac{(\Delta{}x)^{2}}{2!}\frac{\mathrm{d}^{2}u}{\mathrm{d}x^{2}} +
                        \mathcal{O}((\Delta{}x)^{3})\]</p><p>so that the derivative we approximated was in fact:</p><p class="math-container">\[\frac{u(x) - u(x-\Delta{}x)}{\Delta{}x} = 
    \frac{\mathrm{d}u}{\mathrm{d}x} +
    \frac{(\Delta{}x)}{2!}\frac{\mathrm{d}^{2}u}{\mathrm{d}x^{2}} +
    \mathcal{O}((\Delta{}x)^{2}) =
    \frac{\mathrm{d}u}{\mathrm{d}x} +
    \mathcal{O}((\Delta{}x)^1)\]</p><p>Our numerical approximation to the first derivative implicitly contains a <em>diffusion</em> term in the truncation error! The same is valid for the time derivative. We could use higher order schemes but always there will be some numerical diffusion in upwind schemes for convection. From the expression above we see that this diffusion term is proportional to <span>$\Delta{}x$</span>, so increasing the number of points in space could be a solution, but this can become prohibitive in real-world 3-D problems.</p><h3 id="Exercises"><a class="docs-heading-anchor" href="#Exercises">Exercises</a><a id="Exercises-1"></a><a class="docs-heading-anchor-permalink" href="#Exercises" title="Permalink"></a></h3><ol><li><p>Solve the problem with an increasingly larger number of space nodes and plot the MSE of the difference between the numerical and analytical solutions. What kind of behavior do you observe? Is there any limiting value for the number of nodes under constant time discretization? Discuss your findings.</p></li><li><p>Increase the integration interval to <span>$T=3\:\mathrm{s}$</span> and adapt problem solution to handle periodic boundary conditions. Does the meaning of space coordinates remain the same all over the array? Do not forget to use an adequate number of time steps for keeping solution stable.</p></li></ol><h2 id="Nonlinear-advection"><a class="docs-heading-anchor" href="#Nonlinear-advection">Nonlinear advection</a><a id="Nonlinear-advection-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-advection" title="Permalink"></a></h2><p>In order to introduce more complex phenomena, we modify the advection equation so that there is no external field transporting the wave but itself. In this case the previous <span>$c$</span> is replaced by <span>$u$</span> and the equation writes</p><p class="math-container">\[\frac{\partial{}u}{\partial{}t} + u \frac{\partial{}u}{\partial{}x} = 0\]</p><p>Applying the same approach and symbol convention used before, we can find that</p><p class="math-container">\[u_{i}^{n+1}=(1-\alpha_{i})u_{i}^{n}+\alpha_{i}u_{i-1}^n\qquad\text{where}\qquad\alpha_{i}=\frac{\tau}{\delta}u_{i}^{n}\]</p><p>As an example we solve the transport of the same wave integrated in linear advection example with a self-advective transport instead. Other than a small rearrangement in the equation there are no changes in the time-stepping.</p><pre><code class="language-julia hljs">struct NonlinearAdvection1D &lt;: AbstractAdvection
    t::Vector{Unitful.Time}
    x::Vector{Unitful.Length}
    u::Vector{Unitful.Velocity}
    δ::Unitful.Length
    τ::Unitful.Time
    M::Matrix{Float64}

    function NonlinearAdvection1D(L, T, nₓ, nₜ; init, integ = true)
        p = LinearAdvection1D(L, T, 1.0u&quot;m/s&quot;, nₓ, nₜ; init, integ = false)
        obj = new(p.t, p.x, p.u, p.δ, p.τ, p.M)
        integ &amp;&amp; integrate!(obj)
        return obj
    end
end</code></pre><pre><code class="language-julia hljs">function step!(p::NonlinearAdvection1D)::Nothing
    α = p.u[2:end] .* (p.τ / p.δ)
    p.u[2:end] = @. (1 - α) * p.u[2:end] + α * p.u[1:end-1]
    return nothing
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">step! (generic function with 2 methods)</code></pre><h2 id="Solve-nonlinear-advection"><a class="docs-heading-anchor" href="#Solve-nonlinear-advection">Solve nonlinear advection</a><a id="Solve-nonlinear-advection-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-nonlinear-advection" title="Permalink"></a></h2><pre><code class="language-julia hljs">nₓ = 101
nₜ = 101
p2 = NonlinearAdvection1D(L, T, nₓ, nₜ; init)</code></pre><p>Analysing the <span>$u\cdotp{}u^\prime$</span> term in the nonlinear advection equation we see that it has units of acceleration. Because now the transport coefficient is the local velocity itself, different locations accelerate at different rates, leading to the <em>shock wave</em> phenomenon. Below we compare the initial and final waves.</p><img src="6e056979.png" alt="Example block output"/><img src="3aa49e87.png" alt="Example block output"/><h3 id="Exercises-2"><a class="docs-heading-anchor" href="#Exercises-2">Exercises</a><a class="docs-heading-anchor-permalink" href="#Exercises-2" title="Permalink"></a></h3><ol><li>It is possible use the product derivative rule to replace <span>$u\cdotp{}u^\prime=½(u^2)^\prime$</span> in advection equation, what is known as its <em>conservative</em> form. How would you implement this in Julia and what are the implications of this on solution in terms of space and time discretization? Provide some numerical examples.</li></ol><p>For playing with the code, please find a <a href="../001-advection-1d.jl">Pluto notebook here</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Transport Phenomena</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Monday 27 November 2023 06:09">Monday 27 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
