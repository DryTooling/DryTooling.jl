<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>More advection... · DryTooling.jl</title><meta name="title" content="More advection... · DryTooling.jl"/><meta property="og:title" content="More advection... · DryTooling.jl"/><meta property="twitter:title" content="More advection... · DryTooling.jl"/><meta name="description" content="Documentation for DryTooling.jl."/><meta property="og:description" content="Documentation for DryTooling.jl."/><meta property="twitter:description" content="Documentation for DryTooling.jl."/><meta property="og:url" content="https://DryTooling.github.io/DryTooling.jl/Learning/TransportPhenomena/002-advection-1d/"/><meta property="twitter:url" content="https://DryTooling.github.io/DryTooling.jl/Learning/TransportPhenomena/002-advection-1d/"/><link rel="canonical" href="https://DryTooling.github.io/DryTooling.jl/Learning/TransportPhenomena/002-advection-1d/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">DryTooling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Core</span><ul><li><a class="tocitem" href="../../../DryToolingCore/">DryToolingCore</a></li><li><a class="tocitem" href="../../../DryToolingCore/abstract/">Abstract types</a></li></ul></li><li><a class="tocitem" href="../../../DryToolingGranular/">Granular</a></li><li><a class="tocitem" href="../../../DryToolingKinetics/">Kinetics</a></li><li><a class="tocitem" href="../../../DryToolingSimulation/">Simulation</a></li><li><a class="tocitem" href="../../../references/">References</a></li><li><span class="tocitem">Validation Studies</span><ul><li><a class="tocitem" href="../../../DryToolingGranular/validation/kramers-model/">Kramers&#39; model</a></li></ul></li><li><a class="tocitem" href="../../../api/">Reference API</a></li><li><a class="tocitem" href="../../../toc/">Table of Contents</a></li><li><a class="tocitem" href="../../../dev/">Developement</a></li><li><span class="tocitem">Learning</span><ul><li><a class="tocitem" href="../../">Learning</a></li><li><input class="collapse-toggle" id="menuitem-11-2" type="checkbox"/><label class="tocitem" for="menuitem-11-2"><span class="docs-label">Julia para Cientistas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../JuliaParaCientistas/">Julia para Cientistas</a></li><li><a class="tocitem" href="../../JuliaParaCientistas/001-primeiros-passos/">Parte 1 - Primeiros passos</a></li><li><a class="tocitem" href="../../JuliaParaCientistas/002-manipulacao-textual/">Parte 2 - Manipulação textual</a></li><li><a class="tocitem" href="../../JuliaParaCientistas/003-estruturas-de-dados/">Parte 3 - Estruturas de dados I</a></li><li><a class="tocitem" href="../../JuliaParaCientistas/004-estruturas-de-dados/">Parte 4 - Estruturas de dados II</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11-3" type="checkbox"/><label class="tocitem" for="menuitem-11-3"><span class="docs-label">Transport Phenomena</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Transport Phenomena</a></li><li><a class="tocitem" href="../001-advection-1d/">Introduction to Advection in 1-D</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>More advection...</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>More advection...</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DryTooling/DryTooling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/DryTooling/DryTooling.jl/blob/main/docs/src/Learning/TransportPhenomena/002-advection-1d.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="More-advection..."><a class="docs-heading-anchor" href="#More-advection...">More advection...</a><a id="More-advection...-1"></a><a class="docs-heading-anchor-permalink" href="#More-advection..." title="Permalink"></a></h1><h2 id="Courant-Friedrichs-Lewy-criterium"><a class="docs-heading-anchor" href="#Courant-Friedrichs-Lewy-criterium">Courant-Friedrichs-Lewy criterium</a><a id="Courant-Friedrichs-Lewy-criterium-1"></a><a class="docs-heading-anchor-permalink" href="#Courant-Friedrichs-Lewy-criterium" title="Permalink"></a></h2><p>The previous examples and proposed exercises have shown that the explicit numerical scheme that was introduced does not lead to a correct problem solution no matter the choice of number of time steps and nodes. In fact, we have discussed the idea that these are actually mutually dependent and provided a tip regarding the origin of the Courant number <span>$\alpha$</span>. In order to ensure the stability of this explicit scheme, we apply the Courant–Friedrichs–Lewy (CFL) condition which states that:</p><p>$</p><p>\alpha = c \frac{\tau}{\delta} \le \alpha_{crit} $</p><p>Here the value of <span>$\alpha_{crit}$</span> changes with the integration method. Before proceeding with the numerical analysis, let&#39;s start again with some numerical experimentation. To do so we will conceive a few methods for automating multiple solutions of linear advection equation with different discretization levels. The idea is to have the possibility to solve a Courant number constrained problem as well as a free discretization. The first step is to conceive a method <code>compute_cfl</code> which will discretize space as provided by the user, then compute time step in a CFL-constrained way it the number to time steps is not provided, or simply discretize time with a user-defined number of steps.</p><pre><code class="language- hljs">function compute_cfl(T, L, c, nₓ, nₜ)
    δ = L / (nₓ - 1);
    x = collect(0.0u&quot;m&quot;:δ:L);
    
    if !isnothing(nₜ)
        τ = T / (nₜ - 1)
        α = c * τ / δ
    else
        τ = δ / c
        nₜ = convert(Int, floor(T / τ)) + 1
        α  = 1.0
    end
    
    return α, nₜ, τ, x
end</code></pre><p>Below we test the method with the inputs inherited from previous examples. The underscore in front of returned values is a reminder that these parameters are to be discarded in what follows.</p><pre><code class="language- hljs">_α, _nₜ, _τ, _x = compute_cfl(T, L, c, nₓ, nₜ)
_α, _nₜ, _τ</code></pre><p>If the number of time steps is not provided with a <code>nothing</code> instead of an integer, the method performs the CFL-constrained discretization a wished.</p><pre><code class="language- hljs">_α, _nₜ, _τ, _x = compute_cfl(T, L, c, nₓ, nothing);
_α, _nₜ, _τ</code></pre><p>Now we put together everything we learned about the solution of advection equation in a single method <code>linear_advection_explicit</code> which will ingest our space and time domain, fluid velocity, wave parameters, and discretization, to then output the solution with respective space and time axes.</p><pre><code class="language- hljs">function linear_advection_explicit(T, L, c, xᵤ, u₀, nₓ, nₜ)
    # Compute time-stepping parameters as required.
    α, nₜ, τ, x = compute_cfl(T, L, c, nₓ, nₜ);
    
    # Create time points iterator (no need to collect).
    t = 0u&quot;s&quot;:τ:(nₜ-1)*τ;
    
    # Create wave compatible with space discretization.
    mask = ((xᵤ[1] .&lt; x) .&amp; (x .&lt; xᵤ[2]));
    u = u₀ * ones(Float64, (length(x), 1));
    u[.~mask] .= 0.5 .* u₀;
    
    # Allocate memory for solution.
    solution = 0u&quot;m/s&quot; * zeros(Float64, (nₜ, nₓ));
    
    # Time integration loop.
    for (k, _) in enumerate(t)
        solution[k, :] = copy(u);
        u[2:end] = (1 - α) * u[2:end] + α * u[1:end-1];
    end
    
    return x, collect(t), solution, α
end</code></pre><p>Before going further we test it is working as expected.</p><pre><code class="language- hljs">x, t, solution = linear_advection_explicit(T, L, c, xᵤ, u₀, nₓ, nₜ);
kymograph_advection(solution)</code></pre><p>To perform an automated numerical experiment we put it all together in <code>scan_advection</code>. This method will receive everything to setup the problem as provided above, but instead of a single space discretization, it takes a range of number of nodes. This way it will be able to show us the role of nodal length over the accuracy of the solution. It also takes an optional number of time steps, which will be useful for testing the CFL-bounded integration.</p><pre><code class="language- hljs">function scan_advection(T, L, c, xᵤ, u₀, min_nₓ, max_nₓ, dnₓ;
                        nₜ=nothing, boundy=true)
    p = plot();
    
    for (k, nₓ) in enumerate(min_nₓ:dnₓ:max_nₓ)
        x, t, solution, α = linear_advection_explicit(T, L, c, xᵤ, u₀, nₓ, nₜ);
        uₖ = ustrip(solution[end, :]);
        
        sα = @sprintf(&quot;%.2f&quot;, α);
        st = @sprintf(&quot;%.2f&quot;, ustrip(t[end]));
        label = &quot;nₓ = $(nₓ) / α = $(sα) / T = $(st)&quot;;
        plot!(p, x, uₖ, label=label, linewidth=2);
    end

    # Get initial state from the fine-grid solution.
    uᵢ = ustrip(solution[1, :]);
    plot!(p, x, uᵢ, label=&quot;Initial state&quot;, linewidth=2);
    
    xlabel!(p, &quot;Coordinate, \$\\mathrm{m}\$&quot;);
    ylabel!(p, &quot;Velocity, \$\\mathrm{m.s^{-1}}\$&quot;);
    
    if boundy
        ylims!(p, 0.5, 1.0);
    end

    return p;
end</code></pre><p>The following examples were integrated for a shorter physical time to allow faster and didactic computations when scanning over different number of nodes in space domain.</p><pre><code class="language- hljs">T = 0.66u&quot;s&quot;;</code></pre><p>Now we discretize the spacial axis with different number of nodes in the range <span>$[40;70]$</span>. As you may observe in the figure below, numerical diffusion decreases for larger <span>$n_x$</span>, as it was expected from previous discussion. The number of time points is held constant here and equal to 24. Solution seems to better preserve wave shape when <span>$\alpha$</span> approaches unity.</p><pre><code class="language- hljs">scan_advection(T, L, c, xᵤ, u₀, 40, 70, 15; nₜ=24)</code></pre><p>Next we increase the upper limit of the number of space nodes <span>$n_x$</span> to 85, while keeping <span>$n_t$</span> as before. Apparently the solution <em>exploses</em>. If we check the value of <span>$\alpha$</span>, for 85 nodes it has reached 1.21.</p><pre><code class="language- hljs">scan_advection(T, L, c, xᵤ, u₀, 40, 85, 15; nₜ=24, boundy=false)</code></pre><p>Following the observations made on the first trial, we can increase <span>$n_t$</span> to force <span>$\alpha\le1$</span>. Apparently we identified <em>empirically</em> the critical value of CFL for this problem integration method. What happens if you further increase <span>$n_t$</span>, and why does it happen?</p><pre><code class="language- hljs">scan_advection(T, L, c, xᵤ, u₀, 40, 85, 15; nₜ=29)</code></pre><hr/><h2 id="A-(not-so)-formal-stability-analysis"><a class="docs-heading-anchor" href="#A-(not-so)-formal-stability-analysis">A (not so) formal stability analysis</a><a id="A-(not-so)-formal-stability-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#A-(not-so)-formal-stability-analysis" title="Permalink"></a></h2><p>One important question that arrises when solving PDE&#39;s numerically is whether the system is <em>stable</em>, <em>i.e.</em> if the numerical solution remains bounded as time-step goes to zero. That means that perturbations such as the rounding error do not increase in time. There are no general methods for perform such analysis and one gets restricted to linear problems. The standard method for this was proposed by John von Neumann, who proposes to use Fourier series to represent the rounding error. Notice that this implies periodic boundary conditions, otherwise these need to be artificially introducted to the problem in order to be tractable.</p><p>Suppose the numerical scheme used for integration can be represented by a nonlinear operator <span>$\mathcal{J}$</span>, allowing for the progression in time as:</p><p>$</p><p>u^{n+1}=\mathcal{J}[u^{n}] $</p><p>This operator will produce a sequence of values <span>$u(t_{n})=\{u^0,u^1,u^2,...,u^n\}$</span> Since the numerical scheme is only an approximation, each step introduces a small cummulative error such that this sequence is in fact <span>$\{u^0+\varepsilon^0,u^1+\varepsilon^1,u^2+\varepsilon^2,...,u^n+\varepsilon^n\}$</span>, what can be represented by:</p><p>$</p><p>u^{n+1}+\varepsilon^{n+1}=\mathcal{J}(u^{n}+\varepsilon^{n}) $</p><p>Assuming the Taylor series expansion of <span>$\mathcal{J}$</span> is possible, after linearization we can express the amplification of the error as the next expression, known as the <em>error propagation law</em>. Matrix <span>$G$</span> is called the <em>amplification matrix</em>. We promptly identify that this is an eigenvalue problem.</p><p>$</p><p>\varepsilon^{n+1}=\frac{\partial{}\mathcal{J}(u^{n})}{\partial{}u^{n}}\varepsilon^{n}=G\varepsilon^{n} $</p><p>The numerical stability of the system depends on the eigenvalues <span>$g_{\mu}$</span> of <span>$G$</span>. In order that the error remains bounded, the following condition is required for stability:</p><p>$</p><p>\vert{}g_{\mu}\vert\le{}1\qquad\forall\mu $</p><p>In general the solution of a PDE will be represented by <span>$u(t_{n},x_{p})\equiv{}u^{n}_{p}$</span> (notice the change of the subscript used for position here to avoid confusion with the imaginary unit <span>$i$</span> and the wave-number <span>$k$</span> that will be used later). The error propagation at one node <span>$p$</span> is coupled to every other node <span>$q$</span> by means of the Jacobian matrix element <span>$G_{pq}$</span>, what is expressed by:</p><p>$</p><p>\varepsilon^{n+1}<em>{p}=\sum</em>{q}G<em>{pq}\varepsilon^{n}</em>{q} \qquad\text{where}\qquad G<em>{pq}=\frac{\partial{}\mathcal{J}(u^{n}</em>{p})}{\partial{}u^{n}_{q}} $</p><p>The error <span>$\varepsilon^{n}_{p}$</span> can be expanded as a Fourier series of wavenumbes <span>$k$</span> over the problem domain. Since the cummulative error must decay or grow exponentially in time, we can assume that the Fourier coefficients <span>$\hat{\varepsilon}^{n}(k)$</span> vary as <span>$\exp{(\omega{}t_{n})}$</span>, where the frequency <span>$\omega$</span> is a constant.</p><p>$</p><p>\varepsilon^{n}<em>{p}=\sum</em>{k}\hat{\varepsilon}^{n}(k)\exp{(ikx<em>{p})}=\sum</em>{k}\exp{(\omega{}t<em>{n})}\exp{(ikx</em>{p})} $</p><p>It is important to notice that the functions <span>$\exp{(ikx_{p})}$</span> are eigenfunctions of <span>$G$</span>, so the last expression can be interpreted as an expansion of eigenfunctions og <span>$G$</span>. Furthermore, since the equation for the error is linear, it is enough to study the growth of an arbitrary element in the sum, such as \varepsilon^{n}<em>{p}=\exp{(\omega{}t</em>{n})}\exp{(ikx_{p})} $. From this we have:</p><p>$</p><p>\varepsilon^{n+1}<em>{p}=g(k)\varepsilon^{n}</em>{p} $</p><p>As such, one can take the <span>$\exp{(ikx_{p})}$</span> as an eigenvector corresponding to eigenvalue <span>$g(k)$</span>, which is known as the amplification factor. The <em>von Neumann stability criterium</em> is then:</p><p>$</p><p>\vert{}g(k)\vert\le{}1\qquad\forall{}k $</p><h3 id="Application-to-1-D-convection"><a class="docs-heading-anchor" href="#Application-to-1-D-convection">Application to 1-D convection</a><a id="Application-to-1-D-convection-1"></a><a class="docs-heading-anchor-permalink" href="#Application-to-1-D-convection" title="Permalink"></a></h3><p>To start with, at an arbitrary point <span>$p$</span> in the grid we inject the corresponding error propagation term <span>$\hat{\varepsilon}^{n}(k)\exp{(ikp\Delta{}x)}$</span> at the correct time instant. Notice here that we made <span>$x_{p}=p\Delta{}x$</span> for allowing proper manipulation in what follows. Using the <em>upwind explicit</em> scheme we are dealing with one produces:</p><p>$</p><p>\hat{\varepsilon}^{n+1}(k)\exp{(ikp\Delta{}x)}= \hat{\varepsilon}^{n}(k)\exp{(ikp\Delta{}x)}- \alpha\left[     \hat{\varepsilon}^{n}(k)\exp{(ikp\Delta{}x)}-     \hat{\varepsilon}^{n}(k)\exp{(ik(p-1)\Delta{}x)} \right] $</p><p>The error amplification factor <span>$g(k)$</span> can then be identified by simultaneously dividing the previous expression by <span>$\hat{\varepsilon}^{n}(k)\exp{(ikp\Delta{}x)}$</span>. Notice that this expression is independent of the position <span>$p$</span> and thus remains valid for the whole domain.</p><p>$</p><p>g(k)=\frac{\hat{\varepsilon}^{n+1}(k)}{\hat{\varepsilon}^{n}(k)}= 1-\alpha+\alpha\exp{(-ik\Delta{}x)} $</p><p>In order to respect von Neumann stability condition for all <span>$k$</span> we need <span>$1-\alpha\le{}0$</span>, what provides the value of <span>$\alpha_{crit}=1$</span> that we previously identified through our numerical experiments. Thus, we say the <em>upwind explicit</em> scheme for 1-D convection is <em>conditionally stable</em>, <em>i.e</em> the physical velocity <em>c</em> must not be bigger than the numerical <em>spreading velocity</em> <span>$\frac{\Delta{}x}{\Delta{}t}$</span>.</p><p>By not providing the number of time steps in our scanning model forces CFL criterium to be respected for all number of nodes in space, as expected from the previous analysis. In this case, we cannot ensure that the time step required to respect CFL will produce an integer number of steps to reach exactly the time position we wish the calculation to terminate at. In another moment we will deal with this.</p><pre><code class="language- hljs">scan_advection(T, L, c, xᵤ, u₀, 40, 85, 15)</code></pre><hr/><h2 id="Courant-Friedrichs-Lewy-criterium-2"><a class="docs-heading-anchor" href="#Courant-Friedrichs-Lewy-criterium-2">Courant-Friedrichs-Lewy criterium</a><a class="docs-heading-anchor-permalink" href="#Courant-Friedrichs-Lewy-criterium-2" title="Permalink"></a></h2><p>The previous examples and proposed exercises have shown that the explicit numerical scheme that was introduced does not lead to a correct problem solution no matter the choice of number of time steps and nodes. In fact, we have discussed the idea that these are actually mutually dependent and provided a tip regarding the origin of the Courant number <span>$\alpha$</span>. In order to ensure the stability of this explicit scheme, we apply the Courant–Friedrichs–Lewy (CFL) condition which states that:</p><pre><code class="nohighlight hljs">\alpha = c \frac{\tau}{\delta} \le \alpha_{crit}</code></pre><p>Here the value of <span>$\alpha_{crit}$</span> changes with the integration method. Before proceeding with the numerical analysis, let&#39;s start again with some numerical experimentation. To do so we will conceive a few methods for automating multiple solutions of linear advection equation with different discretization levels. The idea is to have the possibility to solve a Courant number constrained problem as well as a free discretization. The first step is to conceive a method <code>compute_cfl</code> which will discretize space as provided by the user, then compute time step in a CFL-constrained way it the number to time steps is not provided, or simply discretize time with a user-defined number of steps.</p><p>Below we test the method with the inputs inherited from previous examples. The underscore in front of returned values is a reminder that these parameters are to be discarded in what follows.</p><p>If the number of time steps is not provided with a <code>nothing</code> instead of an integer, the method performs the CFL-constrained discretization a wished.</p><p>Now we put together everything we learned about the solution of advection equation in a single method <code>linear_advection_explicit</code> which will ingest our space and time domain, fluid velocity, wave parameters, and discretization, to then output the solution with respective space and time axes.</p><p>Before going further we test it is working as expected.</p><p>To perform an automated numerical experiment we put it all together in <code>scan_advection</code>. This method will receive everything to setup the problem as provided above, but instead of a single space discretization, it takes a range of number of nodes. This way it will be able to show us the role of nodal length over the accuracy of the solution. It also takes an optional number of time steps, which will be useful for testing the CFL-bounded integration.</p><p>The following examples were integrated for a shorter physical time to allow faster and didactic computations when scanning over different number of nodes in space domain.</p><p>Now we discretize the spacial axis with different number of nodes in the range <span>$[40;70]$</span>. As you may observe in the figure below, numerical diffusion decreases for larger <span>$n_x$</span>, as it was expected from previous discussion. The number of time points is held constant here and equal to 24. Solution seems to better preserve wave shape when <span>$\alpha$</span> approaches unity.</p><p>Next we increase the upper limit of the number of space nodes <span>$n_x$</span> to 85, while keeping <span>$n_t$</span> as before. Apparently the solution <em>exploses</em>. If we check the value of <span>$\alpha$</span>, for 85 nodes it has reached 1.21.</p><p>Following the observations made on the first trial, we can increase <span>$n_t$</span> to force <span>$\alpha\le1$</span>. Apparently we identified <em>empirically</em> the critical value of CFL for this problem integration method. What happens if you further increase <span>$n_t$</span>, and why does it happen?</p><h2 id="A-(not-so)-formal-stability-analysis-2"><a class="docs-heading-anchor" href="#A-(not-so)-formal-stability-analysis-2">A (not so) formal stability analysis</a><a class="docs-heading-anchor-permalink" href="#A-(not-so)-formal-stability-analysis-2" title="Permalink"></a></h2><p>One important question that arrises when solving PDE&#39;s numerically is whether the system is <em>stable</em>, <em>i.e.</em> if the numerical solution remains bounded as time-step goes to zero. That means that perturbations such as the rounding error do not increase in time. There are no general methods for perform such analysis and one gets restricted to linear problems. The standard method for this was proposed by John von Neumann, who proposes to use Fourier series to represent the rounding error. Notice that this implies periodic boundary conditions, otherwise these need to be artificially introducted to the problem in order to be tractable.</p><p>Suppose the numerical scheme used for integration can be represented by a nonlinear operator <span>$\mathcal{J}$</span>, allowing for the progression in time as:</p><pre><code class="nohighlight hljs">u^{n+1}=\mathcal{J}[u^{n}]</code></pre><p>This operator will produce a sequence of values <span>$u(t_{n})=\{u^0,u^1,u^2,...,u^n\}$</span> Since the numerical scheme is only an approximation, each step introduces a small cummulative error such that this sequence is in fact <span>$\{u^0+\varepsilon^0,u^1+\varepsilon^1,u^2+\varepsilon^2,...,u^n+\varepsilon^n\}$</span>, what can be represented by:</p><pre><code class="nohighlight hljs">u^{n+1}+\varepsilon^{n+1}=\mathcal{J}(u^{n}+\varepsilon^{n})</code></pre><p>Assuming the Taylor series expansion of <span>$\mathcal{J}$</span> is possible, after linearization we can express the amplification of the error as the next expression, known as the <em>error propagation law</em>. Matrix <span>$G$</span> is called the <em>amplification matrix</em>. We promptly identify that this is an eigenvalue problem.</p><pre><code class="nohighlight hljs">\varepsilon^{n+1}=\frac{\partial{}\mathcal{J}(u^{n})}{\partial{}u^{n}}\varepsilon^{n}=G\varepsilon^{n}</code></pre><p>The numerical stability of the system depends on the eigenvalues <span>$g_{\mu}$</span> of <span>$G$</span>. In order that the error remains bounded, the following condition is required for stability:</p><pre><code class="nohighlight hljs">\vert{}g_{\mu}\vert\le{}1\qquad\forall\mu</code></pre><p>In general the solution of a PDE will be represented by <span>$u(t_{n},x_{p})\equiv{}u^{n}_{p}$</span> (notice the change of the subscript used for position here to avoid confusion with the imaginary unit <span>$i$</span> and the wave-number <span>$k$</span> that will be used later). The error propagation at one node <span>$p$</span> is coupled to every other node <span>$q$</span> by means of the Jacobian matrix element <span>$G_{pq}$</span>, what is expressed by:</p><pre><code class="nohighlight hljs">\varepsilon^{n+1}_{p}=\sum_{q}G_{pq}\varepsilon^{n}_{q}
\qquad\text{where}\qquad
G_{pq}=\frac{\partial{}\mathcal{J}(u^{n}_{p})}{\partial{}u^{n}_{q}}</code></pre><p>The error <span>$\varepsilon^{n}_{p}$</span> can be expanded as a Fourier series of wavenumbes <span>$k$</span> over the problem domain. Since the cummulative error must decay or grow exponentially in time, we can assume that the Fourier coefficients <span>$\hat{\varepsilon}^{n}(k)$</span> vary as <span>$\exp{(\omega{}t_{n})}$</span>, where the frequency <span>$\omega$</span> is a constant.</p><pre><code class="nohighlight hljs">\varepsilon^{n}_{p}=\sum_{k}\hat{\varepsilon}^{n}(k)\exp{(ikx_{p})}=\sum_{k}\exp{(\omega{}t_{n})}\exp{(ikx_{p})}</code></pre><p>It is important to notice that the functions <span>$\exp{(ikx_{p})}$</span> are eigenfunctions of <span>$G$</span>, so the last expression can be interpreted as an expansion of eigenfunctions og <span>$G$</span>. Furthermore, since the equation for the error is linear, it is enough to study the growth of an arbitrary element in the sum, such as \varepsilon^{n}<em>{p}=\exp{(\omega{}t</em>{n})}\exp{(ikx_{p})} $. From this we have:</p><pre><code class="nohighlight hljs">\varepsilon^{n+1}_{p}=g(k)\varepsilon^{n}_{p}</code></pre><p>As such, one can take the <span>$\exp{(ikx_{p})}$</span> as an eigenvector corresponding to eigenvalue <span>$g(k)$</span>, which is known as the amplification factor. The <em>von Neumann stability criterium</em> is then:</p><pre><code class="nohighlight hljs">\vert{}g(k)\vert\le{}1\qquad\forall{}k</code></pre><h3 id="Application-to-1-D-convection-2"><a class="docs-heading-anchor" href="#Application-to-1-D-convection-2">Application to 1-D convection</a><a class="docs-heading-anchor-permalink" href="#Application-to-1-D-convection-2" title="Permalink"></a></h3><p>To start with, at an arbitrary point <span>$p$</span> in the grid we inject the corresponding error propagation term <span>$\hat{\varepsilon}^{n}(k)\exp{(ikp\Delta{}x)}$</span> at the correct time instant. Notice here that we made <span>$x_{p}=p\Delta{}x$</span> for allowing proper manipulation in what follows. Using the <em>upwind explicit</em> scheme we are dealing with one produces:</p><pre><code class="nohighlight hljs">\hat{\varepsilon}^{n+1}(k)\exp{(ikp\Delta{}x)}=
\hat{\varepsilon}^{n}(k)\exp{(ikp\Delta{}x)}-
\alpha\left[
    \hat{\varepsilon}^{n}(k)\exp{(ikp\Delta{}x)}-
    \hat{\varepsilon}^{n}(k)\exp{(ik(p-1)\Delta{}x)}
\right]</code></pre><p>The error amplification factor <span>$g(k)$</span> can then be identified by simultaneously dividing the previous expression by <span>$\hat{\varepsilon}^{n}(k)\exp{(ikp\Delta{}x)}$</span>. Notice that this expression is independent of the position <span>$p$</span> and thus remains valid for the whole domain.</p><pre><code class="nohighlight hljs">g(k)=\frac{\hat{\varepsilon}^{n+1}(k)}{\hat{\varepsilon}^{n}(k)}=
1-\alpha+\alpha\exp{(-ik\Delta{}x)}</code></pre><p>In order to respect von Neumann stability condition for all <span>$k$</span> we need <span>$1-\alpha\le{}0$</span>, what provides the value of <span>$\alpha_{crit}=1$</span> that we previously identified through our numerical experiments. Thus, we say the <em>upwind explicit</em> scheme for 1-D convection is <em>conditionally stable</em>, <em>i.e</em> the physical velocity <em>c</em> must not be bigger than the numerical <em>spreading velocity</em> <span>$\frac{\Delta{}x}{\Delta{}t}$</span>.</p><p>By not providing the number of time steps in our scanning model forces CFL criterium to be respected for all number of nodes in space, as expected from the previous analysis. In this case, we cannot ensure that the time step required to respect CFL will produce an integer number of steps to reach exactly the time position we wish the calculation to terminate at. In another moment we will deal with this.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.0 on <span class="colophon-date" title="Thursday 30 November 2023 06:49">Thursday 30 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
