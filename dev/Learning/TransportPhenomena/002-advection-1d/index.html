<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>More advection... · DryTooling.jl</title><meta name="title" content="More advection... · DryTooling.jl"/><meta property="og:title" content="More advection... · DryTooling.jl"/><meta property="twitter:title" content="More advection... · DryTooling.jl"/><meta name="description" content="Documentation for DryTooling.jl."/><meta property="og:description" content="Documentation for DryTooling.jl."/><meta property="twitter:description" content="Documentation for DryTooling.jl."/><meta property="og:url" content="https://DryTooling.github.io/DryTooling.jl/Learning/TransportPhenomena/002-advection-1d/"/><meta property="twitter:url" content="https://DryTooling.github.io/DryTooling.jl/Learning/TransportPhenomena/002-advection-1d/"/><link rel="canonical" href="https://DryTooling.github.io/DryTooling.jl/Learning/TransportPhenomena/002-advection-1d/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">DryTooling.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Core</span><ul><li><a class="tocitem" href="../../../DryToolingCore/">DryToolingCore</a></li><li><a class="tocitem" href="../../../DryToolingCore/abstract/">Abstract types</a></li></ul></li><li><a class="tocitem" href="../../../DryToolingGranular/">Granular</a></li><li><a class="tocitem" href="../../../DryToolingKinetics/">Kinetics</a></li><li><a class="tocitem" href="../../../DryToolingSimulation/">Simulation</a></li><li><a class="tocitem" href="../../../references/">References</a></li><li><span class="tocitem">Validation Studies</span><ul><li><a class="tocitem" href="../../../DryToolingGranular/validation/kramers-model/">Kramers&#39; model</a></li></ul></li><li><a class="tocitem" href="../../../api/">Reference API</a></li><li><a class="tocitem" href="../../../toc/">Table of Contents</a></li><li><a class="tocitem" href="../../../dev/">Developement</a></li><li><span class="tocitem">Learning</span><ul><li><a class="tocitem" href="../../">Learning resources</a></li><li><a class="tocitem" href="../../JuliaParaCientistas/">Julia para Cientistas</a></li><li><a class="tocitem" href="../">Transport Phenomena</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>More advection...</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>More advection...</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/DryTooling/DryTooling.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/DryTooling/DryTooling.jl/blob/main/docs/src/Learning/TransportPhenomena/002-advection-1d.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="More-advection..."><a class="docs-heading-anchor" href="#More-advection...">More advection...</a><a id="More-advection...-1"></a><a class="docs-heading-anchor-permalink" href="#More-advection..." title="Permalink"></a></h1><p><strong>DRAFT</strong></p><p>Other higher order expansions are available in the literature, but they are not well-suited for an introductory course on numerical implementation of the solution of PDE&#39;s, so we stick with this low order approximation in what follows. An analogous expansion can be performed for the time derivative of the advection equation. Notice that for time the expansion is performed towards the <em>future</em>. This leads to the following space-time discretization to the problem</p><pre><code class="nohighlight hljs">\frac{u(t+\Delta{}t)-u(t)}{\Delta{}t}+c\frac{u(x)-u(x-\Delta{}x)}{\Delta{}x}=0</code></pre><p>This approximate representation of the advection PDE is difficult to read and distant from what it would look in a computer, where it can be represented through indexed arrays or matrices. It is common in the FDM to use subscripts for denoting space indices, and superscript for time-steps. This way we translate <span>$t+\Delta{}t$</span> as <span>$n+1$</span>, where <span>$n$</span> is the time-step number, and <span>$x-\Delta{}x$</span> becomes <span>$i-1$</span>, where <span>$i$</span> is the index of the FDM space coordinate node. Also it is useful to maker shorthands <span>$\tau=\Delta{}t$</span> and <span>$\delta=\Delta{}x$</span>. The equation becomes</p><pre><code class="nohighlight hljs">\frac{u_{i}^{n+1}-u_{i}^n}{\tau}+c\frac{u_{i}^n-u_{i-1}^n}{\delta}=0</code></pre><p>Our goal of approaching the equation to the computer implementation format has been reached. So far we are only considering fixed time-steps <span>$\tau$</span> and node distances <span>$\delta$</span>, and constant advection velocity <span>$c$</span>, thus there are still a three constants hanging around. Since problem initial state is <em>a priori</em> knowledge for PDE integration, at <span>$n=0$</span> and <span>$\forall{}i$</span> we dispose of the state <span>$u_{i}^{n}=u_{i}^{0}$</span>, so the only unknown in the above equation is <span>$u_{i}^{n+1}$</span>, for which it can be solved</p><pre><code class="nohighlight hljs">u_{i}^{n+1}=(1-\alpha)u_{i}^{n}+\alpha{}u_{i-1}^n</code></pre><p>Such approximation that makes use of current state to predict a future one is called an <em>explicit</em> time-stepping scheme and has been implied without explanation in the above discretization approach. With this expression we have the complete mathematical tooling to solve the simplest advection equation. Notice that for <span>$c&lt;0$</span> the direction of the upwind space derivative would change and the solution becomes <span>$u_{i}^{n+1}=(1+\alpha)u_{i}^{n}-\alpha{}u_{i+1}^n$</span>.</p><p>Now suppose we want to solve advection of a given wave over a 1-D space domain. The discrete solution derived above provides most information we need to gather before starting to develop a computer solution, but it says nothing about the sizes of discrete steps <span>$\tau$</span> and <span>$\delta$</span>. For now we rely only on the mathematical background we have on Taylor series expansion to think about it, and we postpone the methods of computing suitable steps for later. Let&#39;s experiment with a hand-on example to get some insights.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>For allocating arrays of same shapes, Julia provides the method <code>similar</code>. Since we are using units with our values, that method cannot be used here with array for <span>$x$</span> to allocate the density array <span>$u$</span>, otherwise the result would carray space dimensions. Instead we create a <code>ones</code> array of appropriate numerical type and dimensions and provide it with units carried by <span>$u_{0}$</span>. Notice that this initializes the whole array with the value found in the square wave.</p><p>To modify the regions ouside the peak we create a boolean mask. In Julia, to evaluate a binary operation elementwise, a dot is placed in front of the operator. So here <code>xᵤ[1] .&lt; x</code> means true where elements of <code>x</code> are less than the first element of <code>xᵤ</code>, for instance. Since the mask we created represent the square wave region, we negate the resulting array to set zero elsewhere in the density array <code>u</code>. Also observe the <code>.=</code> notation to attribute results. This vectorized operations supported by Julia avoid the excessive use of loops and result in easier to maintain code.</p><p><strong>Note:</strong> method <code>ustrip</code> from <code>Uniful</code> was used to remove units from arrays before plotting because their rendering is not converted to <span>$\LaTeX$</span> in axes.</p><p>With all this elements we prepare the solution. We start by computing the constant <span>$\alpha$</span> known as <em>Courant number</em>. Observe that this is a dimensionless number since it results from the product of a velocity by the inverse of a <em>numerical velocity</em>. Depending on the choice of derivative approximations there may be a upper limit for which the numerical integration will be <em>stable</em>. We are not entering in these details yet, for now you can read more about this <a href="https://en.wikipedia.org/wiki/Courant%E2%80%93Friedrichs%E2%80%93Lewy_condition">here</a> to get a taste of the numerical analysis to come.</p><p>In the present case we might want to store the solution of all time steps for performing an animation or display a kymograph, what will be the case here. For small to medium sized problems, it is more effecient to allocate the memory for solution storage ahead of time, especially when working with fixed time steps. For larger problems or variable time step size, it is sometimes necessary to allocate memory for part of the solution and from times to times dump current chunk to the disk, or handle a buffer with limited memory.</p><p>Since this is a very simple 1-D problem, we chose to have a matrix will one row per time step, so its dimensions are <span>$n_t\times{}n_x$</span>, as follows.</p><p>Because they will be reused several times in this chapter, we wrap the kymograph and comparison plotting in the functions given below. It is generally a good idea to follow some <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY directives</a>, but care must be take not to create new methods for simple one-liners, which could become hard to maintain later.</p><p>The solution loop is straightforward: we store the current state and solve over the same array the next time solution, what constitutes a simple explicit <em>Euler</em> time-stepping scheme. Since Julia supports vectorized operations we use the slice syntax to evaluate <span>$(1-\alpha)u_{i}^{n}+\alpha{}u_{i-1}^n$</span> and attribute it elementwise to <span>$u_{i}^{n+1}$</span>. Notice that element <code>u[1]</code> is never updated here, think for a moment what are the implications of this.</p><p>The analytical solution to this problem states that the shape of the density profile should not evolve in time, just its position. In the kymograph above that would mean that the only valid values in the heat map would be those originally in the initial state array. This is not actually what we observe. We get just qualitative agreement between the expected and actual position of our moving hump <span>$u$</span>, which apparently <em>diffused</em> over the domain. And this exaclty what happened, from a numerical standpoint. When we approximated the spacial derivative, we were actually truncating a Taylor series expansion of <span>$u$</span> at the first term, as in:</p><pre><code class="nohighlight hljs">u(x) = u(x-\Delta{}x) + \frac{(\Delta{}x)^{1}}{1!}\frac{\mathrm{d}u}{\mathrm{d}x} +
                        \frac{(\Delta{}x)^{2}}{2!}\frac{\mathrm{d}^{2}u}{\mathrm{d}x^{2}} +
                        \mathcal{O}((\Delta{}x)^{3})</code></pre><p>so that the derivative we approximated was in fact:</p><pre><code class="nohighlight hljs">\frac{u(x) - u(x-\Delta{}x)}{\Delta{}x} =
    \frac{\mathrm{d}u}{\mathrm{d}x} +
    \frac{(\Delta{}x)}{2!}\frac{\mathrm{d}^{2}u}{\mathrm{d}x^{2}} +
    \mathcal{O}((\Delta{}x)^{2}) =
    \frac{\mathrm{d}u}{\mathrm{d}x} +
    \mathcal{O}((\Delta{}x)^1)</code></pre><p>Our numerical approximation to the first derivative implicitly contains a <em>diffusion</em> term in the truncation error! The same is valid for the time derivative. We could use higher order schemes but always there will be some numerical diffusion in upwind schemes for convection. From the expression above we see that this diffusion term is proportional to <span>$\Delta{}x$</span>, so increasing the number of points in space could be a solution, but this can become prohibitive in real-world 3-D problems.</p><p>Below we display a comparison between initial and final states of the advected wave.</p><h3 id="Exercises"><a class="docs-heading-anchor" href="#Exercises">Exercises</a><a id="Exercises-1"></a><a class="docs-heading-anchor-permalink" href="#Exercises" title="Permalink"></a></h3><ol><li><p>Solve the problem with an increasingly larger number of space nodes and plot the MSE of the difference between the numerical and analytical solutions. What kind of behavior do you observe? Is there any limiting value for the number of nodes under constant time discretization? Discuss your findings.</p></li><li><p>Increase the integration interval to <span>$T=3\:\mathrm{s}$</span> and adapt problem solution to handle periodic boundary conditions. Does the meaning of space coordinates remain the same all over the array? Do not forget to use an adequate number of time steps for keeping solution stable.</p></li></ol><h2 id="Nonlinear-advection"><a class="docs-heading-anchor" href="#Nonlinear-advection">Nonlinear advection</a><a id="Nonlinear-advection-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-advection" title="Permalink"></a></h2><p>In order to introduce more complex phenomena, we modify the advection equation so that there is no external field transporting the wave but itself. In this case the previous <span>$c$</span> is replaced by <span>$u$</span> and the equation writes</p><pre><code class="nohighlight hljs">\frac{\partial{}u}{\partial{}t} + u \frac{\partial{}u}{\partial{}x} = 0</code></pre><p>Applying the same approach and symbol convention used before, we can find that</p><pre><code class="nohighlight hljs">u_{i}^{n+1}=(1-\alpha_{i})u_{i}^{n}+\alpha_{i}u_{i-1}^n\qquad\text{where}\qquad\alpha_{i}=\frac{\tau}{\delta}u_{i}^{n}</code></pre><h3 id="Example-2"><a class="docs-heading-anchor" href="#Example-2">Example</a><a class="docs-heading-anchor-permalink" href="#Example-2" title="Permalink"></a></h3><p>As an example we solve the transport of the same wave integrated in linear advection example with a self-advective transport instead. Other than a small rearrangement in the equation there are no changes in the time-stepping.</p><p>Analysing the <span>$u\cdotp{}u^\prime$</span> term in the nonlinear advection equation we see that it has units of acceleration. Because now the transport coefficient is the local velocity itself, different locations accelerate at different rates, leading to the <em>shock wave</em> phenomenon. Below we compare the initial and final waves.</p><h3 id="Exercises-2"><a class="docs-heading-anchor" href="#Exercises-2">Exercises</a><a class="docs-heading-anchor-permalink" href="#Exercises-2" title="Permalink"></a></h3><ol><li>It is possible use the product derivative rule to replace <span>$u\cdotp{}u^\prime=½(u^2)^\prime$</span> in advection equation, what is known as its <em>conservative</em> form. How would you implement this in Julia and what are the implications of this on solution in terms of space and time discretization? Provide some numerical examples.</li></ol><h2 id="Courant-Friedrichs-Lewy-criterium"><a class="docs-heading-anchor" href="#Courant-Friedrichs-Lewy-criterium">Courant-Friedrichs-Lewy criterium</a><a id="Courant-Friedrichs-Lewy-criterium-1"></a><a class="docs-heading-anchor-permalink" href="#Courant-Friedrichs-Lewy-criterium" title="Permalink"></a></h2><p>The previous examples and proposed exercises have shown that the explicit numerical scheme that was introduced does not lead to a correct problem solution no matter the choice of number of time steps and nodes. In fact, we have discussed the idea that these are actually mutually dependent and provided a tip regarding the origin of the Courant number <span>$\alpha$</span>. In order to ensure the stability of this explicit scheme, we apply the Courant–Friedrichs–Lewy (CFL) condition which states that:</p><pre><code class="nohighlight hljs">\alpha = c \frac{\tau}{\delta} \le \alpha_{crit}</code></pre><p>Here the value of <span>$\alpha_{crit}$</span> changes with the integration method. Before proceeding with the numerical analysis, let&#39;s start again with some numerical experimentation. To do so we will conceive a few methods for automating multiple solutions of linear advection equation with different discretization levels. The idea is to have the possibility to solve a Courant number constrained problem as well as a free discretization. The first step is to conceive a method <code>compute_cfl</code> which will discretize space as provided by the user, then compute time step in a CFL-constrained way it the number to time steps is not provided, or simply discretize time with a user-defined number of steps.</p><p>Below we test the method with the inputs inherited from previous examples. The underscore in front of returned values is a reminder that these parameters are to be discarded in what follows.</p><p>If the number of time steps is not provided with a <code>nothing</code> instead of an integer, the method performs the CFL-constrained discretization a wished.</p><p>Now we put together everything we learned about the solution of advection equation in a single method <code>linear_advection_explicit</code> which will ingest our space and time domain, fluid velocity, wave parameters, and discretization, to then output the solution with respective space and time axes.</p><p>Before going further we test it is working as expected.</p><p>To perform an automated numerical experiment we put it all together in <code>scan_advection</code>. This method will receive everything to setup the problem as provided above, but instead of a single space discretization, it takes a range of number of nodes. This way it will be able to show us the role of nodal length over the accuracy of the solution. It also takes an optional number of time steps, which will be useful for testing the CFL-bounded integration.</p><p>The following examples were integrated for a shorter physical time to allow faster and didactic computations when scanning over different number of nodes in space domain.</p><p>Now we discretize the spacial axis with different number of nodes in the range <span>$[40;70]$</span>. As you may observe in the figure below, numerical diffusion decreases for larger <span>$n_x$</span>, as it was expected from previous discussion. The number of time points is held constant here and equal to 24. Solution seems to better preserve wave shape when <span>$\alpha$</span> approaches unity.</p><p>Next we increase the upper limit of the number of space nodes <span>$n_x$</span> to 85, while keeping <span>$n_t$</span> as before. Apparently the solution <em>exploses</em>. If we check the value of <span>$\alpha$</span>, for 85 nodes it has reached 1.21.</p><p>Following the observations made on the first trial, we can increase <span>$n_t$</span> to force <span>$\alpha\le1$</span>. Apparently we identified <em>empirically</em> the critical value of CFL for this problem integration method. What happens if you further increase <span>$n_t$</span>, and why does it happen?</p><h2 id="A-(not-so)-formal-stability-analysis"><a class="docs-heading-anchor" href="#A-(not-so)-formal-stability-analysis">A (not so) formal stability analysis</a><a id="A-(not-so)-formal-stability-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#A-(not-so)-formal-stability-analysis" title="Permalink"></a></h2><p>One important question that arrises when solving PDE&#39;s numerically is whether the system is <em>stable</em>, <em>i.e.</em> if the numerical solution remains bounded as time-step goes to zero. That means that perturbations such as the rounding error do not increase in time. There are no general methods for perform such analysis and one gets restricted to linear problems. The standard method for this was proposed by John von Neumann, who proposes to use Fourier series to represent the rounding error. Notice that this implies periodic boundary conditions, otherwise these need to be artificially introducted to the problem in order to be tractable.</p><p>Suppose the numerical scheme used for integration can be represented by a nonlinear operator <span>$\mathcal{J}$</span>, allowing for the progression in time as:</p><pre><code class="nohighlight hljs">u^{n+1}=\mathcal{J}[u^{n}]</code></pre><p>This operator will produce a sequence of values <span>$u(t_{n})=\{u^0,u^1,u^2,...,u^n\}$</span> Since the numerical scheme is only an approximation, each step introduces a small cummulative error such that this sequence is in fact <span>$\{u^0+\varepsilon^0,u^1+\varepsilon^1,u^2+\varepsilon^2,...,u^n+\varepsilon^n\}$</span>, what can be represented by:</p><pre><code class="nohighlight hljs">u^{n+1}+\varepsilon^{n+1}=\mathcal{J}(u^{n}+\varepsilon^{n})</code></pre><p>Assuming the Taylor series expansion of <span>$\mathcal{J}$</span> is possible, after linearization we can express the amplification of the error as the next expression, known as the <em>error propagation law</em>. Matrix <span>$G$</span> is called the <em>amplification matrix</em>. We promptly identify that this is an eigenvalue problem.</p><pre><code class="nohighlight hljs">\varepsilon^{n+1}=\frac{\partial{}\mathcal{J}(u^{n})}{\partial{}u^{n}}\varepsilon^{n}=G\varepsilon^{n}</code></pre><p>The numerical stability of the system depends on the eigenvalues <span>$g_{\mu}$</span> of <span>$G$</span>. In order that the error remains bounded, the following condition is required for stability:</p><pre><code class="nohighlight hljs">\vert{}g_{\mu}\vert\le{}1\qquad\forall\mu</code></pre><p>In general the solution of a PDE will be represented by <span>$u(t_{n},x_{p})\equiv{}u^{n}_{p}$</span> (notice the change of the subscript used for position here to avoid confusion with the imaginary unit <span>$i$</span> and the wave-number <span>$k$</span> that will be used later). The error propagation at one node <span>$p$</span> is coupled to every other node <span>$q$</span> by means of the Jacobian matrix element <span>$G_{pq}$</span>, what is expressed by:</p><pre><code class="nohighlight hljs">\varepsilon^{n+1}_{p}=\sum_{q}G_{pq}\varepsilon^{n}_{q}
\qquad\text{where}\qquad
G_{pq}=\frac{\partial{}\mathcal{J}(u^{n}_{p})}{\partial{}u^{n}_{q}}</code></pre><p>The error <span>$\varepsilon^{n}_{p}$</span> can be expanded as a Fourier series of wavenumbes <span>$k$</span> over the problem domain. Since the cummulative error must decay or grow exponentially in time, we can assume that the Fourier coefficients <span>$\hat{\varepsilon}^{n}(k)$</span> vary as <span>$\exp{(\omega{}t_{n})}$</span>, where the frequency <span>$\omega$</span> is a constant.</p><pre><code class="nohighlight hljs">\varepsilon^{n}_{p}=\sum_{k}\hat{\varepsilon}^{n}(k)\exp{(ikx_{p})}=\sum_{k}\exp{(\omega{}t_{n})}\exp{(ikx_{p})}</code></pre><p>It is important to notice that the functions <span>$\exp{(ikx_{p})}$</span> are eigenfunctions of <span>$G$</span>, so the last expression can be interpreted as an expansion of eigenfunctions og <span>$G$</span>. Furthermore, since the equation for the error is linear, it is enough to study the growth of an arbitrary element in the sum, such as \varepsilon^{n}<em>{p}=\exp{(\omega{}t</em>{n})}\exp{(ikx_{p})} $. From this we have:</p><pre><code class="nohighlight hljs">\varepsilon^{n+1}_{p}=g(k)\varepsilon^{n}_{p}</code></pre><p>As such, one can take the <span>$\exp{(ikx_{p})}$</span> as an eigenvector corresponding to eigenvalue <span>$g(k)$</span>, which is known as the amplification factor. The <em>von Neumann stability criterium</em> is then:</p><pre><code class="nohighlight hljs">\vert{}g(k)\vert\le{}1\qquad\forall{}k</code></pre><h3 id="Application-to-1-D-convection"><a class="docs-heading-anchor" href="#Application-to-1-D-convection">Application to 1-D convection</a><a id="Application-to-1-D-convection-1"></a><a class="docs-heading-anchor-permalink" href="#Application-to-1-D-convection" title="Permalink"></a></h3><p>To start with, at an arbitrary point <span>$p$</span> in the grid we inject the corresponding error propagation term <span>$\hat{\varepsilon}^{n}(k)\exp{(ikp\Delta{}x)}$</span> at the correct time instant. Notice here that we made <span>$x_{p}=p\Delta{}x$</span> for allowing proper manipulation in what follows. Using the <em>upwind explicit</em> scheme we are dealing with one produces:</p><pre><code class="nohighlight hljs">\hat{\varepsilon}^{n+1}(k)\exp{(ikp\Delta{}x)}=
\hat{\varepsilon}^{n}(k)\exp{(ikp\Delta{}x)}-
\alpha\left[
    \hat{\varepsilon}^{n}(k)\exp{(ikp\Delta{}x)}-
    \hat{\varepsilon}^{n}(k)\exp{(ik(p-1)\Delta{}x)}
\right]</code></pre><p>The error amplification factor <span>$g(k)$</span> can then be identified by simultaneously dividing the previous expression by <span>$\hat{\varepsilon}^{n}(k)\exp{(ikp\Delta{}x)}$</span>. Notice that this expression is independent of the position <span>$p$</span> and thus remains valid for the whole domain.</p><pre><code class="nohighlight hljs">g(k)=\frac{\hat{\varepsilon}^{n+1}(k)}{\hat{\varepsilon}^{n}(k)}=
1-\alpha+\alpha\exp{(-ik\Delta{}x)}</code></pre><p>In order to respect von Neumann stability condition for all <span>$k$</span> we need <span>$1-\alpha\le{}0$</span>, what provides the value of <span>$\alpha_{crit}=1$</span> that we previously identified through our numerical experiments. Thus, we say the <em>upwind explicit</em> scheme for 1-D convection is <em>conditionally stable</em>, <em>i.e</em> the physical velocity <em>c</em> must not be bigger than the numerical <em>spreading velocity</em> <span>$\frac{\Delta{}x}{\Delta{}t}$</span>.</p><p>By not providing the number of time steps in our scanning model forces CFL criterium to be respected for all number of nodes in space, as expected from the previous analysis. In this case, we cannot ensure that the time step required to respect CFL will produce an integer number of steps to reach exactly the time position we wish the calculation to terminate at. In another moment we will deal with this.</p></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Saturday 18 November 2023 17:41">Saturday 18 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
